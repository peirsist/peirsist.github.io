<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.2.1/css/all.min.css" integrity="sha256-Z1K5uhUaJXA7Ll0XrZ/0JhX4lAtZFpT6jkKrEDT0drU=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"peirsist.github.io","root":"/","images":"/images","scheme":"Pisces","darkmode":false,"version":"8.14.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>

    <meta property="og:type" content="website">
<meta property="og:title" content="EEWIKI">
<meta property="og:url" content="https://peirsist.github.io/page/4/index.html">
<meta property="og:site_name" content="EEWIKI">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Peirsist">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://peirsist.github.io/page/4/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"en","comments":"","permalink":"","path":"page/4/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>EEWIKI</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">EEWIKI</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="Search" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a></li><li class="menu-item menu-item-schedule"><a href="/schedule/" rel="section"><i class="fa fa-calendar fa-fw"></i>Schedule</a></li><li class="menu-item menu-item-sitemap"><a href="/sitemap.xml" rel="section"><i class="fa fa-sitemap fa-fw"></i>Sitemap</a></li><li class="menu-item menu-item-commonweal"><a href="/404/" rel="section"><i class="fa fa-heartbeat fa-fw"></i>Commonweal 404</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Peirsist</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">98</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">16</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">34</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://peirsist.github.io/2022/11/04/%E8%AE%BA%E6%96%87/2019-ByteCuts/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Peirsist">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="EEWIKI">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | EEWIKI">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/11/04/%E8%AE%BA%E6%96%87/2019-ByteCuts/" class="post-title-link" itemprop="url">ByteCuts</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2022-11-04 10:06:48" itemprop="dateCreated datePublished" datetime="2022-11-04T10:06:48+08:00">2022-11-04</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2022-11-13 23:04:25" itemprop="dateModified" datetime="2022-11-13T23:04:25+08:00">2022-11-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E8%AE%BA%E6%96%87/" itemprop="url" rel="index"><span itemprop="name">论文</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="Word count in article">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">Word count in article: </span>
      <span>2.3k</span>
    </span>
    <span class="post-meta-item" title="Reading time">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">Reading time &asymp;</span>
      <span>2 mins.</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="启示">1 启示</h1>
<h1 id="摘要">2 摘要</h1>
<h1 id="基础知识">3 基础知识</h1>
<h2 id="预备知识">3.1 预备知识</h2>
<h2 id="文中基础概念">3.2 文中基础概念</h2>
<h1 id="introduction">4 Introduction</h1>
<h1 id="background">5 Background</h1>
<h1 id="方案">6 方案</h1>
<h2 id="b.-树状选择">B. 树状选择</h2>
<p>基于树的方法，包括 ByteCuts，存在着一个叫做规则复制的问题。规则复制是由于通配符造成的规则落入多个分区，迫使它们被多次复制。这可以从图 5 中看出，规则 ra 和 rb 都被复制到了多个分区。现有的方法，如 EffiCuts[3]和 SmartSplit[4]，试图通过对规则进行分区，使同一分区的所有规则具有类似的特征来缓解这一问题。这大大减少了所需的复制量，因为更容易找到不触发任何通配符的好切割。</p>
<p>我们还根据规则的特征将规则列表 <span class="math inline">\(L\)</span> 划分为一个树的列表 <span class="math inline">\(T\)</span>。我们试图将具有相似特征的规则放在同一棵树上，因为这将导致更短的树。我们通过确保同一棵树上的所有规则都使用相同的核心比特集来做到这一点。这确保了至少有一个好的切割会存在。使用一个更大的核心将允许更多的良好切割，减少树的高度，但会排除不符合更严格要求的规则，增加树的数量。我们通过在排除的规则数量和给定切割的预期最大分区大小之间取得平衡来处理这个问题。为了提高效率，我们只使用连续的比特（以小数点为单位）作为核心；对于前缀字段，这相当于测量该特定字段的长度。</p>
<p>我们定义了两个阈值：一个是切割效率，一个是树的大小。我们定义 <span class="math inline">\(c\)</span> 为最大碰撞率，<span class="math inline">\(n_c=c-n_L\)</span>，其中 <span class="math inline">\(n_L\)</span> 是 <span class="math inline">\(L\)</span> 中尚未被放入树中的规则数量。同样地，我们定义<span class="math inline">\(χ\)</span>为最大排除率，<span class="math inline">\(n_χ=χ-n_L\)</span> 。<span class="math inline">\(n_c\)</span> 和 <span class="math inline">\(n_χ\)</span> 在以后的树中都会变小，因为 <span class="math inline">\(n_L\)</span> 会变小；<span class="math inline">\(n_c\)</span> 定义了可接受的碰撞极限，而 <span class="math inline">\(n_χ\)</span> 定义了所需的最大排除规则数。</p>
<p>我们的目标是在满足某些平衡要求的情况下，使规则数量最大化（从而使树的数量最小化）。如果任何 filed 长对 <span class="math inline">\((f, w_f)\)</span> 的碰撞限制低于 <span class="math inline">\(n_c\)</span>，那么我们选择使排除的规则数量最小化的对。否则，从那些最多排除 <span class="math inline">\(n_χ\)</span> 条规则中，我们选择碰撞限制最小的一对。如果这两个目标都无法达到，我们就选择 <em>碰撞大小+排除规则 (collision size + rules excluded)</em> 之和最小的一对。</p>
<p>一旦选择了一个字段长度对（f，wf），我们就从字段 f 的前缀长度至少为 wf 的所有规则中创建一棵树，如下一节所述。然后我们在剩下的规则上重复树的选择过程。</p>
<p>一旦剩余规则的数量低于某个阈值 <span class="math inline">\(τ\)</span>（在我们的实验中为<em>5%</em>），我们就宣布剩余的规则为 "坏"（并推而广之，以前的规则为 "好"）。<strong>坏规则</strong> 通常在两个地址字段中都有相对较少的比特。如果 TCAM 是可用的，我们就把坏规则放到 TCAM 中。对于一个纯粹的 <em>ByteCuts</em> 解决方案，我们试图用所有的坏规则建立一个单一的树，只有当规则在切割阶段需要太多的规则复制时才会被移除（见第三部分-C）。具体来说，如果一条规则在树上的任何单独的切割中具有 <em>5</em> 个或更多的通配符位，我们才会因为规则复制而将其从树上删除。</p>
<p>对于每个字段，我们考虑每个可能的最左边的位，并为每个 <span class="math inline">\(0 &lt; δ ≤ k\)</span> 选择下一个可能的<span class="math inline">\(δ\)</span> 位，这给我们一个 <span class="math inline">\(δ\)</span> 位的选择。从每个规则 <span class="math inline">\(r_i\)</span> 中，我们然后提取这些比特，并将其解释为一个数字。带有通配符的规则计算多个数字（通过用 0 和 1 替换 * ）。我们计算每个数字出现多少次。我们<strong><em>选择具有最小的最大频率</em></strong>的切割。这种切割将<strong>使最大的子树最小化</strong>。在出现平局的情况下，我们倾向于选择δ较小的切割，因为这样可以节省内存。</p>
<p>一旦选择了一个切割，我们就对规则进行分区。我们创建 <span class="math inline">\(2^δ\)</span> 个分区。与上面类似，从每个规则 <span class="math inline">\(r_i\)</span> 中，我们提取选定的 <span class="math inline">\(δ\)</span> 位，将其解释为一个数字，然后将 <span class="math inline">\(r_i\)</span> 放入与该数字对应的分区中。带有通配符的规则将被放置到多个分区中。然后我们对每个分区进行递归，创建一个新的子树。有些列表包含相同的规则集（因为有通配符）。我们检测到这一点，并只创建一个子节点，为这些子列表中的每一个共享。</p>
<p>例如，考虑分类器 I 的规则。在第三部分 B 中，我们选择了规则 r1 到 r7。如果我们选择源字段的前两位，那么一个分区将包含规则 r3、r4 和 r4，但如果我们选择最后两位，那么每个分区至多有 2 条规则，使其成为更好的选择。命运字段上的切割都没有那么好，因为它们需要将 r6 和 r7 复制到所有分区。因此，我们选择（011，000）作为我们切割的掩码。这就产生了四个孩子，其中 00 部分包含 r1 和 r6，01 包含 r2，10 包含 r3 和 r7，11 包含 r4 和 r5。在这种切割之后，每个分区只有 <span class="math inline">\(2≤n_{leaf}\)</span> 规则，所以我们为每个部分创建一个叶子结点。</p>
<p>我们有两个优化，使切割选择更快。首先，如果一个规则在选择的位上有超过 4 个通配符，我们就认为它最终会出现在每个分区中。我们将这种规则的数量作为惩罚，而不是将其计入各个分区。这就避免了为有许多通配符的规则增加成千上万的频率。</p>
<p>第二个优化是，我们把所有的切割都对准了 <em>nybble</em> 边界：我们的最小切割尺寸是 1 <em>nybble</em> ，我们把切割长度增加 1 <em>nybble</em> ，在我们的实验中，我们的最大切割长度是 <span class="math inline">\(k=4\)</span> <em>nybbles</em> （16 位）。这限制了子数组的大小，最多只能有 65536 个节点；增加这个限制会使数组大小增加，从而使潜在的内存使用量呈指数增长。我们只选择 <em>nybbles</em> ，因为在实践中，这些长度明显比其他长度更常见。因此，更精细的切割带来的好处很少，而时间成本却很高。</p>
<h1 id="实验">7 实验</h1>
<h1 id="结论">8 结论</h1>
<h1 id="参考文献">9 参考文献：</h1>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://peirsist.github.io/2022/11/03/%E9%9A%8F%E7%AC%94%E4%B8%8E%E4%B8%AA%E4%BA%BA%E6%96%87%E9%9B%86/%E8%A6%81%E8%AF%BB%E5%8D%9A%E5%90%97/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Peirsist">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="EEWIKI">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | EEWIKI">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/11/03/%E9%9A%8F%E7%AC%94%E4%B8%8E%E4%B8%AA%E4%BA%BA%E6%96%87%E9%9B%86/%E8%A6%81%E8%AF%BB%E5%8D%9A%E5%90%97/" class="post-title-link" itemprop="url">要读博吗</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2022-11-03 12:57:41" itemprop="dateCreated datePublished" datetime="2022-11-03T12:57:41+08:00">2022-11-03</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2023-01-05 16:08:30" itemprop="dateModified" datetime="2023-01-05T16:08:30+08:00">2023-01-05</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E9%9A%8F%E7%AC%94%E4%B8%8E%E4%B8%AA%E4%BA%BA%E6%96%87%E9%9B%86/" itemprop="url" rel="index"><span itemprop="name">随笔与个人文集</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="Word count in article">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">Word count in article: </span>
      <span>2.7k</span>
    </span>
    <span class="post-meta-item" title="Reading time">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">Reading time &asymp;</span>
      <span>2 mins.</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <ol type="1">
<li><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1ge4y177dV/?spm_id_from=333.1007.tianma.2-1-3.click&amp;vd_source=83831fc0970a6c8704479f7cfc679937">不要盲目追求学历，读博士是什么体验</a></li>
<li><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/468564547/answer/1972180362?utm_campaign=shareopn&amp;utm_content=group3_Answer&amp;utm_medium=social&amp;utm_oi=910069747331248128&amp;utm_psn=1576492511123415040&amp;utm_source=wechat_session">网传 top2 高校某院士团队的博士生大面积延毕，实际情况如何？ - 知乎 (zhihu.com)</a></li>
<li><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/pliljqn7yo1dxccmkgQDxQ">家境不好应不应该读博？ (qq.com)</a></li>
<li><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/4WzwCfMhY5utJyDlrFOKZw">【学术相关】从长远来看读博的收益是巨大的，为什么读博的人却很少？ (qq.com)</a></li>
</ol>
<p>先陈述几个事实（转载）：</p>
<ol type="1">
<li>工作了之后个人的学习能力和学习机会一定会断崖式下降，唯一能够积累的是“经验”。（获得经验不属于学习，属于应用，是知识的输出）</li>
<li>高科技行业薪资往往倒挂严重，个人薪资的增长远远赶不上市场的变化，工作几年后可能入手还不如高点入市的新人，这几年 ai 行业尤其明显。</li>
<li>出去工作基本上都是在搬砖，本硕毕业出去90%的工作都是搬砖，剩下的10%的高价值创新性工作只留给领域内的顶级专家（一般都有博士学位）或高管。</li>
<li>高附加值岗位的竞争日益激烈，从最开始的c9本科间竞争，慢慢发展到c9研究生竞争（研究生一般都自带论文和项目经验，默认优于本科生），再到今天的全球名校毕业生竞争，高价值岗位的放出速度已经逐渐赶不上本硕的产出速度。</li>
<li><strong>读博士可能是你这辈子唯一的，有可能成为领域内顶级专家的机会</strong>，如果放弃了这个机会，就意味着你要在社会上摸爬滚打数十年，从底层的一颗螺丝钉做起，走无数的弯路，做无数个项目（真的好项目得运气好才能接触到），保持极高的情商才能到达这一步。</li>
</ol>
<p>陈述完上述五个事实以后，<strong>如果你不想搬砖，有意愿成为领域内的顶级专家，从事创新性工作，那么读博似乎是唯一的途径。</strong>（尽管并不是所有人都能做到，但其他的途径因为在工作后基本上没条件学习了，所以能成为顶级专家的概率几乎为0）</p>
<p>如果你并没有此等打算，那么你最好优秀（竞争的过其他高手），并且运气够好（最好撞上风口）。</p>
<p>如果家境贫寒急需用钱，博士也有基本工资，也有奖学金，只是这比硕士工作要少很多，不过也勉强够用。但记住博士的价值爆发来自于学位拿到之后，不来自于之前之中。</p>
<p>如果你想enjoy your life，那么国企或者闲职比较适合你，反正薪水都不是很高，也不996。</p>
<p>最后，以上都是基于利益的考虑，如果非要抠钱数的话可以参考一下，但真正是否读博士和以上的关系并不是最大的，有很多家境不好也拿了奖学金去读phd的，也有家境好的毕业了就去工作的。真正最重要的部分是你是否对研究感兴趣，不感兴趣的话就是给你奖学金怕是也不会去啊。</p>
<p><strong>工作5年，带你的人就是个比你多了2-3年工作经验的小破领导，读博5年，你跟的人起码是个技术总监</strong> <strong>级别的科学家，最后哪个收益大不言自明。</strong></p>
<p><strong>如果你有幸拜在大牛门下，那么恭喜你，带你的就是Top公司CTO级别的人，那你的前路绝对比工作出来要长远多了，最起码大牛这个资源是你用得上的，别的人要想获得同样的支持，你知道要花掉多少钱吗？</strong></p>
<p><strong>人啊，还是不要太短视，什么需要“早日工作养家糊口”根本就是短视的借口，山区出来拿tx顶薪的ai博士还历历在目，不浮躁的人最终有更好的归宿。</strong></p>
<p><strong>不要甘于落入局部最优解，人生是场长跑，你年轻时获得的资源才是决定你日后成败的关键。</strong></p>
<p>有的人可能不太理解“有机会”和“一定是”的差别。</p>
<p>在这里解释一下，有机会代表着有可能，但不是100%，一定是代表着绝对，100%的几率。</p>
<p>不管承认与否，想在一个领域内成为专家，phd确实是最好的机会，这就是现在的一个事实，并非抬举博士。如果你想通过搬砖搬成专家也不是不行，只不过你要花上10-20年，这其中一半的时间还要在养家糊口，买车买房，还房车贷，办公室政治等等一系列琐事上花费时间精力，然后你还要在这样的情况下抽出时间学习提高，这几乎没人能做得到吧，这可比读博士难了不止一倍。</p>
<p>有的人可能会提到所谓的“读博造成阶级回落”，我想申明一下，所谓的“阶级论”只是一群不上不下的小资/中产制造出来的一种贩卖焦虑的东西罢了。对于寒门学子来说，本身就是无产阶级，一年全家就几千的收入，置于社会底层，本身就没有回落的空间，一旦上了大学就是完成了阶级跨越。而且大多数寒门学子也没有像小资中产那么奢靡浮躁的“跨越到资产阶级”的需求。很多城市出身的中产把自己代入了无产阶级，然后用自己的经历告诉别人不该这样那样，殊不知先是自己的屁股坐歪了，得出来的结论自然也很歪很奇怪。</p>
<hr>
<p>博士招生名额非常有限。所以导致读博的人很少，这是根本原因。</p>
<p>但是不可否认的是，不同专业的读博兴趣是不一样的。像我所读的计算机这类热门工科专业，硕士毕业找工作难度并不大，出路多，薪资可观。我们班上三四十人，选择读博的我印象中好像有一个去的ucla，其他多数基本都选择就业。</p>
<p>选择读博的这个同学，读研期间就发了顶会，学术潜质比较好。自己对钻研学术的兴趣也高，申请国外博士的道路也顺理成章。</p>
<p>那么大多数同学为什么没考虑读博，我总结一些身边朋友的想法供大家参考。</p>
<ol type="1">
<li><p>对我们专业来说，想读博并不难。但读博之路真的艰辛，耗时又久，博士的毕业要求相比硕士高的程度是明显超过硕士之于本科的。况且，博士的实际收益也没有我们想象的高。博士毕业大多选择进高校任教。但高校教师待遇说实话不算太高。以我导为例，他说他过的很轻松，但是每个月到手就五六千块（现在可能涨了），其他奖金绩效之类的收入，是有一些。但是我导直言，『你们将来毕业去企业，工资是要吊打我们的。我虽然没什么本事，但带出来的学生就业都挺好的」。</p></li>
<li><p><strong>博士的实际就业面其实并不宽。</strong>虽然你可以选择向下兼容的岗位，但是用人单位却不一定敢用你，如果招了博士却给不出相应的待遇，那是要挨巴掌的。有些博士会选择引进到机关或机关下辖单位，但干的会比较别扭。首先<strong>博士年龄层是偏大的，其次科研水平较好</strong>，但是文人气息更重。一些短视的当地中层领导看到新进博士占用了本属于自己晋升的坑位，必然会对你使绊子。所以博士进机关及机关下辖事业单位，一般干的并不舒服。</p></li>
<li><p>个人以为，<strong>博士最好的就业去处依旧是教育系统（含高校与科研院所）</strong>。非升即走的 985211 待遇是相当高，但是也别只盯着那些学校。<strong>想要舒服你可以去直接给编的双非院校</strong>，乃至职业院校和中小学都是很不错的出路。</p></li>
<li><p>高中同学是国外某知名院校博士毕业，有过博后科研经历。回国后坦言国内好卷，目前在珠三角Q某知名院校，非升即走奋斗中。因为是某有钱院校，加上非升即走的高薪，所以目前年薪应该有个四五十万。希望他顺利卷上岸。在国内没 title 真的很难搞。</p></li>
</ol>
<p><strong>综合来说长远看来，读博的收益未必有很多人想象中的那么大，但是风险无疑是巨大的。</strong> 光是<strong>博士毕业这个压力就真的像大山一样压得你喘不过气来。</strong>前面我提到过，博士毕业的难度相比硕士毕业的难度，是远大于硕士毕业的难度之于本科毕业的难度。光是这一点就劝退多想读博的人了。<strong>想一下毕导大佬，如果博士能轻松毕业，那他会选择不毕业吗？</strong>虽然自媒体确实占用了时间，<strong>但如果不是博士的毕业压力过大，他总不可能放弃这个博士毕业证吧。</strong></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://peirsist.github.io/2022/11/03/%E8%AE%BA%E6%96%87/%E6%95%B0%E6%8D%AE%E5%8C%85%E5%88%86%E7%B1%BB%E6%96%B9%E6%A1%88%E6%95%B4%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Peirsist">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="EEWIKI">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | EEWIKI">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/11/03/%E8%AE%BA%E6%96%87/%E6%95%B0%E6%8D%AE%E5%8C%85%E5%88%86%E7%B1%BB%E6%96%B9%E6%A1%88%E6%95%B4%E7%90%86/" class="post-title-link" itemprop="url">数据包分类方案整理</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2022-11-03 10:06:48" itemprop="dateCreated datePublished" datetime="2022-11-03T10:06:48+08:00">2022-11-03</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2022-12-01 16:34:11" itemprop="dateModified" datetime="2022-12-01T16:34:11+08:00">2022-12-01</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E8%AE%BA%E6%96%87/" itemprop="url" rel="index"><span itemprop="name">论文</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="Word count in article">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">Word count in article: </span>
      <span>2.6k</span>
    </span>
    <span class="post-meta-item" title="Reading time">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">Reading time &asymp;</span>
      <span>2 mins.</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>2022&#x2F;12&#x2F;01</p>
<p><a target="_blank" rel="noopener" href="http://www.wenjunli.com/">土鳖云 | Wenjun’s Academic Space (wenjunli.com)</a></p>
<ol>
<li><a target="_blank" rel="noopener" href="http://wenjunli.com/CutTSS/">CutTSS (wenjunli.com)</a></li>
<li><a target="_blank" rel="noopener" href="http://wenjunli.com/CutTSS/observations/index.html">Observations (wenjunli.com)</a></li>
<li><a target="_blank" rel="noopener" href="http://wenjunli.com/CutSplit/">CutSplit (wenjunli.com)</a></li>
<li><a target="_blank" rel="noopener" href="http://wenjunli.com/HybridTSS/">HybridTSS (wenjunli.com)</a></li>
<li><a target="_blank" rel="noopener" href="http://wenjunli.com/TabTree/">TabTree (wenjunli.com)</a></li>
<li><a target="_blank" rel="noopener" href="http://www.wenjunli.com/HybridCuts/">HybridCuts (wenjunli.com)</a></li>
</ol>
<p><strong>2022&#x2F;11&#x2F;16晚思考bit cutting</strong></p>
<p>bit cutting 本质也是 Equi size cutting，但是不是一种“简单的”Equi size cutting，bit cutting 考虑了规则集的分布，Equi size cutting 并没有考虑规则集的分布（我认为 bit cutting 是可以较少 overlapping 的）。</p>
<p>bit cutting 通过不同的算法选择不同的 effective bits，对应着不同的切割方案，而规则的分布决定了如何选择 effective bits。bit cutting既可以减少overlapping，又可以加速索引。<br><img src="https://cdn.staticaly.com/gh/peirsist/blog_img@master/%E4%BD%8D%E5%88%87%E5%89%B2.75nmcu7rtww0.png" alt="位切割"></p>
<p>effective bit 的多少决定了树的高低，effective bit 中 0、1 分布决定了树的平衡性，effective bit 中 * 的多少决定 overlapping 多少。我们期望 overlapping 越少越好，树高度越低越好，树越平衡越好。</p>
<p>由此得到，选择effective bits需要遵循以下原则：</p>
<ol>
<li>尽可能不选择含有通配符 * 的那一列 → 减少 overlapping（2021 MBitTree 启发得来）</li>
<li>选的列 0 1 尽可能分布均匀 → 树会平衡（2021 MBitTree 启发得来）</li>
<li>可以选多个 effective bit → 树的高度会降低</li>
</ol>
<hr>
<h1 id="1-硬件"><a href="#1-硬件" class="headerlink" title="1 硬件"></a>1 硬件</h1><h1 id="2-软件"><a href="#2-软件" class="headerlink" title="2 软件"></a>2 软件</h1><h2 id="2-1-决策树"><a href="#2-1-决策树" class="headerlink" title="2.1 决策树"></a>2.1 决策树</h2><h3 id="2-1-1-规则集分组"><a href="#2-1-1-规则集分组" class="headerlink" title="2.1.1 规则集分组"></a>2.1.1 规则集分组</h3><p>事实上，规则集中部分规则之间存在明显的差异。对访问控制列表 <em>( access control list， ACL)</em> 、防火墙 <em>( firewall，FW)</em> 和 IP 链 <em>( IP chain， IPC)</em> 类型规则集进行统计分析，结果如图 3 所示。从图中可得，IP 地址字段前缀长度为边缘分布，即大部分位于 0 附近或 32 附近。因此不加任何区分直接切割整个搜索空间将导致严重的规则复制，其中一个解决方案便是分治思想，<strong>即将具有相似特征的规则放到一个规则子集中，然后应用节点切割技术为每个子集单独构建决策树</strong>，最后形成多棵决策树。规则集分组方式分为：</p>
<ol>
<li><strong>按字段大小分组</strong>。根据规则在每个字段覆盖的范围来划分规则子集，该类方法应用最广泛。<ul>
<li><del>HiCuts(1999), HyperCuts(2004)</del>, <em>Efficuts(2010)</em>, <del>HyperSplit(2011),</del> <em>SmartSplit(2014), CutSplit(2018)</em></li>
</ul>
</li>
<li><strong>按前缀长度分组</strong>。根据规则在特定字段的前缀长度来划分规则集。<ul>
<li>HashTable</li>
<li><em>ByteCuts(2018)</em></li>
</ul>
</li>
<li><strong>基于聚类算法分组</strong>。使用聚类算法来划分规则子集。<ul>
<li><em>ParaSplit</em></li>
</ul>
</li>
<li><strong>基于深度神经网络模型分组</strong>。将机器学习技术应用到报文分类问题中，如使用深度神经 网络模型来学习优化节点切割和规则集分组，以 获得最大的奖励函数( 分类速度、内存消耗等) ， 从而构建性能优异的决策树。<ul>
<li><em>NeuroCuts(2019)</em></li>
</ul>
</li>
</ol>
<p>按字段大小、前缀长度分组等启发式策略建立在对规则集分布特征观察的基础之上，原理相 对简单、容易实现，但对于不同的规则集，往往需 要手动调整部分参数以获得理想结果; 聚类算法、 神经网络模型则可以使用机器学习来替代人工调 整，实现对规则子集的自适应划分，但需要经过大 量的训练和迭代才能收敛。</p>
<h3 id="2-1-2-节点切割"><a href="#2-1-2-节点切割" class="headerlink" title="2.1.2 节点切割"></a>2.1.2 节点切割</h3><p>节点切割基本思想是将整个多维规则集视为树的根节点，然后沿一个或多个特定的维度迭代地切割节点，直到每个叶节点包含的规则数不大于预定义的阈值时停止切割，从而构建单棵决策树。</p>
<p>各类决策树算法在节点切割方面的主要区别为:</p>
<ol>
<li><p>**<font color="red">切割维度的选择</font>**。选择哪个维度切割最优; 一次选择单个维度还是多个维度进行切割。</p>
</li>
<li><p><strong><font color="red">切割端点的选择</font></strong></p>
<ol>
<li><strong>Equi - size</strong><ul>
<li>快速将节点等分为 $2^n$ 个子节点，但会带来严重的规则复制问题,即同一条规则分布在多个子节点中</li>
<li><em>HiCuts(1999), HyperCuts(2004), Efficuts(2010)</em></li>
</ul>
</li>
<li><strong>Equi-dense</strong><ul>
<li>而等密切割能够缓解规则复制问题，但也存在树深度增加、节点索引复杂等问题。</li>
<li><em>HyperSplit(2011), SmartSplit(2014)</em></li>
</ul>
</li>
<li><strong>Bit cutting</strong><ul>
<li>利用规则每一位都可表示为 0、1 或者 * ( 通配符) 的特点，选择其中有效比特将规则映射到各个子节点中，从而避免了盲目地切割整个搜索空间。</li>
<li><em>BitCuts(2017), ByteCuts(2018), MBitTree(2021)</em></li>
</ul>
</li>
</ol>
</li>
</ol>
<blockquote>
<p>另一个角度看，等分切割也是一种特殊的比特切割，但只允许使用连续的最高有效位。</p>
</blockquote>
<h3 id="2-1-3-HiCuts"><a href="#2-1-3-HiCuts" class="headerlink" title="2.1.3 HiCuts"></a>2.1.3 HiCuts</h3><ol>
<li><strong>思路</strong>： 一次选择单个维度，将搜索 空间划分为等大小的子空间</li>
<li><strong>规则集分组方式</strong>：无</li>
<li><strong>节点切割方式</strong>：<em><strong>equi-size</strong></em></li>
<li><strong>优点</strong>：首个决策树分类算法，快速 切割规则空间</li>
<li><strong>缺点</strong>：树深度较大，规则复制问 题严重，内存消耗大</li>
</ol>
<h3 id="2-1-4-HyperCuts"><a href="#2-1-4-HyperCuts" class="headerlink" title="2.1.4 HyperCuts"></a>2.1.4 HyperCuts</h3><ol>
<li><strong>思路</strong>： 一次选择多个维度，将搜索 空间划分为等大小的子空间</li>
<li><strong>规则集分组方式</strong>：无</li>
<li><strong>节点切割方式</strong>：<em><strong>equi-size</strong></em></li>
<li><strong>优点</strong>：HiCuts 的改进，树深度较小， 分类速度较快，规则复制相 比 HiCuts 有所优化</li>
<li><strong>缺点</strong>：内存消耗仍然较大，可扩展性较差</li>
</ol>
<h3 id="2-1-5-EffiCuts"><a href="#2-1-5-EffiCuts" class="headerlink" title="2.1.5 EffiCuts"></a>2.1.5 EffiCuts</h3><ol>
<li><strong>思路</strong>： </li>
<li><strong>规则集分组方式</strong>：</li>
<li><strong>节点切割方式</strong>：<em><strong>equi-size</strong></em></li>
<li><strong>优点</strong>：大大减少了规则复制</li>
<li><strong>缺点</strong>：划分树的数目太多，查找速度慢</li>
</ol>
<h3 id="2-1-6-HyperSplit"><a href="#2-1-6-HyperSplit" class="headerlink" title="2.1.6 HyperSplit"></a>2.1.6 HyperSplit</h3><p>HyperSplit 算法提出了等密切割的思路，进一 步缓解了规则复制问题，但由于算法构建的决策树 为二叉树，且每次只能判断一次维度，因此随着规 则集规模的扩大和维度的增加，树的深度也会增 加，相应的遍历决策树所需的访存次数也将增加。</p>
<ol>
<li><strong>思路</strong>： 一次选择单个维度和特定的 端点，将搜索空间划分为两 个规则数几乎相等的子空间</li>
<li><strong>规则集分组方式</strong>：无</li>
<li><strong>节点切割方式</strong>：<em><strong>equi-dense</strong></em></li>
<li><strong>优点</strong>：进一步优化规则复制问题， 内存消耗小</li>
<li><strong>缺点</strong>：树深度较大，遍历树所需 的访存次数较多</li>
</ol>
<h3 id="2-1-7-BitCuts"><a href="#2-1-7-BitCuts" class="headerlink" title="2.1.7 BitCuts"></a>2.1.7 BitCuts</h3><ol>
<li><strong>思路</strong>： 选择规则中的有效比特来划分搜索空间</li>
<li><strong>规则集分组方式</strong>：无</li>
<li><strong>节点切割方式</strong>：<em><strong>bit-cutting</strong></em></li>
<li><strong>优点</strong>：分类速度在 4 种算法中最快，吞吐量高</li>
<li><strong>缺点</strong>：树深度较大，规则复制问题严重，内存消耗大</li>
</ol>
<h2 id="2-2-哈希表"><a href="#2-2-哈希表" class="headerlink" title="2.2 哈希表"></a>2.2 哈希表</h2><h2 id="2-3-决策树结合哈希表"><a href="#2-3-决策树结合哈希表" class="headerlink" title="2.3 决策树结合哈希表"></a>2.3 决策树结合哈希表</h2><h2 id="2-4-机器学习"><a href="#2-4-机器学习" class="headerlink" title="2.4 机器学习"></a>2.4 机器学习</h2><h2 id="2-5-其他"><a href="#2-5-其他" class="headerlink" title="2.5 其他"></a>2.5 其他</h2>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://peirsist.github.io/2022/11/03/%E8%AE%BA%E6%96%87/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0-%E8%83%8C%E6%99%AF-RelatedWork/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Peirsist">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="EEWIKI">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | EEWIKI">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/11/03/%E8%AE%BA%E6%96%87/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0-%E8%83%8C%E6%99%AF-RelatedWork/" class="post-title-link" itemprop="url">论文笔记-背景-RelatedWork</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2022-11-03 10:06:48" itemprop="dateCreated datePublished" datetime="2022-11-03T10:06:48+08:00">2022-11-03</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2022-11-24 21:08:22" itemprop="dateModified" datetime="2022-11-24T21:08:22+08:00">2022-11-24</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E8%AE%BA%E6%96%87/" itemprop="url" rel="index"><span itemprop="name">论文</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="Word count in article">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">Word count in article: </span>
      <span>21k</span>
    </span>
    <span class="post-meta-item" title="Reading time">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">Reading time &asymp;</span>
      <span>19 mins.</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="面向未来网络的高性能数据包查找与分类技术研究">2019面向未来网络的高性能数据包查找与分类技术研究</h1>
<p>沈潼 张大方 湖南大学 信息科学与工程学院</p>
<p>本文提出了范围向量的概念，并依据这个概念提出了一种基于散列函数的支持规则快速更新的高性能包分类算法。本文根据真实规则的源与目的地址前缀长度的分布将规则映射到不同的范围向量空间，数据包分类时需要在各个范围向量空间内查找，通常需要遍历所有范围向量空间。基于这个观察，本文设计并实现了一种基于范围向量的散列算法。每一个范围向量对应的散列表使用各字段的最大公共比特长度进行散列计算。范围向量散列算法具有常数级的规则更新速度。由于数据包分类是根据匹配规则的最高优先级决定，因此该算法需要搜索所有散列表。本文通过定义散列表的优先级对散列表进行优先级排序。因此，该算法可以在不降低更新性能和不增加内存消耗的前提下，进一步提高包分类的速度。</p>
<p>现有的基于软件的包分类算法大多是单线程，少数算法能够扩展到多线程，因此研究多线程包分类算法具有非常重要理论依据和应用意义。本文针对不同的算法逻辑和数据结构，合理运用数据并行模式和流水线并行模式，设计了一个通用的多线程包分类框架。同时，本文还对多线程的锁机制进行优化，利用原子操作和硬件同步原语设计无锁化多线程版本，实现真正意义上每个线程的独立运行。</p>
<h2 id="背景">背景</h2>
<p>互联网实际上就是由网络节点和网络链路组成的一个庞大系统。其中，网络节点负责网络功能的实现与运行，而网络链路负责数据与信息的传输。网络链路的传输速度由链路介质及传输技术决定，而网络节点的性能则由数据层的相关技术决定。</p>
<p>数据包分类是指根据指定的数据包携带的一系列信息（如源地址、目的地址、源端口号、目的端口号和协议等）在一套规则集中按照最高优先级匹配的原则，找到该数据包待执行的操作或任务。</p>
<p><mark>软件定义网络是什么？</mark></p>
<p>包分类是交换机、路由器和其他网络设备中用于支持安全性[56]、QoS[57,58]和高级功能[59,60]的基本操作之一，其中数据包在分类器中根据多字段规则集进行匹配。 例如，为了保护网络资源不被攻击，五元组防火墙规则通常被添加到交换机以筛选 哪些数据包应该被通过哪些应该被丢弃。在传统的网络应用中，规则保持相对静态。 因此，离线构建的分类器通常拥有设计精良的数据结构，这类分类器可以实现高效 的数据包分类。数据包分类器设计的主要目标是通过合理的内存占用来执行高速数 据包转发。由于规则更新不频繁，分类器可以离线构建。</p>
<p>软件定义网络[50,61,62]（SDN）的出现为网络创新提供了巨大的机会，以使网 络支持新的特性和增值功能。这些功能包括流量工程[63]、网络功能虚拟化[64,65]（NFV）和高性能云计算[66,67]的支持。然而，这些新功能除了依赖于基本的快速包 分类外，还依赖于分类器中规则的动态更新能力[40,68]。一方面，网络应用必须对大 量的用户和请求进行即时响应，使得分类器规则必须频繁更新，以满足不同的需求。 另一方面，网络功能的常规迁移或变更总是会改变拓扑结构和策略，从而分类器的 规则必定会有相应的更新。因此，快速的规则更新对于当前的分类器是绝对必要且 有意义的。</p>
<p>尽管包分类非常重要，并且已经吸引了很多研究者的关注，但是现有的算法往往不能同时满足上述两个要求，即快速包分类的同时支持快速规则更新。决策树的算法，如HyperCuts[36]、EffiCuts[37]和SmartSplit[38]，都能实现快速的包分 类，但不能实现快速的规则更新。基于哈希的算法，比如在Open vSwitch[69]（OVS） 中实现的元组空间搜索[39]（TSS），可以实现快速规则更新但不能实现高速包分类。 PartitionSort[40]（PS）和TupleMerge[41]（TM）可以提升包分类的速度但都牺牲了规 则更新的性能。同时实现快速的包分类和规则更新是满足先进的网络管理和高效云 计算的新需求和基本挑战之一。</p>
<h2 id="现状">现状</h2>
<p>在工业界，大型路由器以及高端分类器都是利用硬件设备，如三态内容寻址存储器（TCAM）、现场可编程门阵列（FPGA）和专门的网络处理器芯片，来实现高性能的数据包查找和分类。尽管这些器件设备具有非常好的性能，也能满足当前的大多数需求，但是它们的成本非常昂贵，导致它们的售价非常高。</p>
<p>路由查找算法根据数据结构的不同可分为基于字典树的算法、基于决策搜索树的算法以及基于哈希表过滤器的算法，而包分类算法则可以分为基于维度降解的算法和基于空间划分的算法。本文所提出的所有方法，都是基于软件的，并不针对某一类特殊硬件。</p>
<p>高性能在线包分类算法的研究。该研究点是对匹配内容的维度的扩展。即从单维度扩展到了多维度。包分类从匹配过程这个角度来看是多个字段的查找匹配，或者说路由查找是包分类在单维度上的特例。为了解决包分类规则频繁更新的问题，本文提出了一种基于范围向量哈希的在线包分类算法，在保证高效的数据包分类的同时，提供快速的规则更新。</p>
<p>包分类技术不仅仅会被应用在路由器上，它们还可能会被应用在网管、防火墙、端系统等所有可能的网络节点上。而这些设备往往不仅仅只是用于包分类，而是集成了其它的功能。通常，<strong>用于包分类的那部分功能会被作为模块抽取出来，形成分类器</strong>，便于重复利用。图2.2为一个普通分类器的结构和功能图。通常分类器会包含一个规则集，当数据包到达时，先对包头进行解析，然后根据包头字段在规则集找到匹配的规则，并实行匹配规则规定的行为。</p>
<blockquote>
<p>通常在传统的TCP/IP协议里为5个字段，在OpenFlow协议[32]里可以达到40多个字段。</p>
</blockquote>
<figure>
<img src="https://cdn.staticaly.com/gh/peirsist/blog_img@master/分类器.5fwaxpgm8nk0.png" alt="分类器"><figcaption aria-hidden="true">分类器</figcaption>
</figure>
<p>包分类规则集是分类器中最关键的数据结构之一。规则集通常是由控制器生成并进行维护的。规则集包含一系列分类规则，每一个规则又包含了用于分类数据包 需要判断的所有包头字段（匹配域）、规则优先级以及一个或多个行为（操作）。包 分类规则集通常包含几十万条规则，因此存储在片外存储器上。为了加快分类速度， 分类器通常会在片上存储器中维护一个或多个小规则集作为大规则集缓存。在数据 包分类的过程中，可能会有多个规则与分类对象匹配，这时根据最高优先级匹配的 原则，选择这些匹配规则中优先级最高的规则作为最终的匹配结果，并执行其规定的操作。</p>
<h2 id="包分类算法">包分类算法</h2>
<p>基于维度降解的算法 Cross-producting[33]和RFC[34]将多维规则分割成若干个单维规则。它们逐个与单维规则进行匹配，然后合并各个匹配的结果。这类方法的更新速度非常缓慢，因为 每个单维规则都对应一次规则更新。此外，最终的合并过程将成为性能瓶颈，尤其 当规则集较大时。</p>
<p>基于空间划分的方法通常将 <strong>整个规则空间划分为若干个子空间，将规则集分为几组分别放入每个子空间中</strong>。 分为两个步骤，<strong>1）确定要搜索的子空间</strong> ，以及 <strong>2）将数据包与相应子空间中的子规则集进行匹配</strong>，而不是将传入的数据包直接与整个规则集进行匹配。这种类型的方法进一步分为两个主要的子类别：基于决策树的方法和基于哈希的方法。</p>
<p>基于决策树的方法，它们的关键思想如HiCuts[35]和HyperCuts[36]是将搜索空间 <strong>递归划分</strong> 成若干子区域，直到每个区域中的规则数量低于某一阈值。由于决策树的效率，这些方法可以实现高速数据包分类。然而，其中一个缺点是由于规则复制而导致大量内存消耗，因为有些规则可能需要复制到多个分区中。<strong>缓慢和复杂的规则更新是这些方法的另一个缺点</strong>。虽然EffiCuts[37]和SmartSplit[38]基于规则分布，采用不同的规则空间分区策略来减少规则复制和内存访问量，但它们仍然不能支持快速更新。</p>
<p><strong>现有的基于散列的方法可以实现快速规则更新，但不能高效分类</strong>。在OVS中实现的元组空间搜索方法[39]（TSS）基于元组将规则划分成不同的子集。<strong>一个元组是一组前缀长度构成的向量</strong>，每个前缀长度对应于规则集中各个字段的长度。<strong>每个子集部署为哈希表</strong> 以实现数据包的快速索引分类和快速规则更新。为了对数据包进行分类并遵循优先级优先的原则，需要搜索所有的哈希表，从而其分类时间将随着哈希表的数量线性增加。 修剪元组空间搜索算法[39]（PTSS）通过元组按照包含关系以字典树的形式过滤掉那些不可能匹配的远足空间来提升分类性能。虽然在PTSS中确实可以减少用于 匹配的元组的数量，但是合并结果非常耗时，并且更新操作仍然很复杂。</p>
<p>PartitionSort[40]（PS）结合了TSS和决策树的优点。PS不是基于元组划分规则，而是将规则划分成可排序的规则集，并通过平衡搜索树存储它们。因此，PS以处理可排序规则集为代价，减少了哈希计算次数，实现了比TSS更快的数据包分类。换 句话说，与TSS相比，PS以降低规则更新的速度来加快数据包的分类速度。</p>
<p>TupleMerge[41]（TM）通过减少得到的哈希表的数量来改进TSS的分类。TM重新定义了规则和元组之间的兼容性，以便那些相似但不完全相同的规则可以放在同 一个哈希表（元组）中。然而，这种方法可能导致哈希表的重叠，这将导致一个规则可能映射到的哈希表是不确定的，从而严重损害了规则更新的性能。此外，哈希表的数量会随着时间的推移而增加，因此，在一定时间后其分类性能会急剧下降。 为了重新提升性能，当哈希表的数量超过某一阈值时，必须重新构建所有哈希表。 这使得它不能应用于在线包分类。</p>
<blockquote>
<p>什么是OVS? OVS是一个高质量的，多层虚拟交换机。虚拟交换呢？就是，利用软件的方式形成交换部件，所以也叫软件交换机，跟传统的物理交换机相比，虚拟交换机同要具备很多有点：1.配置灵活，因为是软件实现的，一台物理服务器上可以配置数十太或者数百台虚拟交换机，而且端口数目可以灵活选择 2. 成本低廉，通过软件的方式可轻易达到10Gbps的交换速度。 <a target="_blank" rel="noopener" href="https://blog.csdn.net/sqx2011/article/details/39344869">OVS - 简介</a></p>
</blockquote>
<p><strong>数据包查找和分类技术本身并不复杂，但是随着网络技术和网络功能的不断更新和发展，已有的算法已经不适应当前网络对于性能以及功能的需求</strong>。 尤其，面向未来的高性能网络，数据包查找和分类技术还需要进一步被研究和发展。通常情况下，判断一个路由查找算法或数据包分类算法的好坏，往往会从以下四个方面进行 评估。 1. <strong>查找（分类）速度</strong>。算法的性能是判断该算法最直接的评价指标之一。通常， 对于路由查找算法以及数据报分类算法都会使用<strong>每秒完成多少次查找（lps）</strong> 来定量评价算法的性能。在某些时候可以用每秒完成千次查找（Klps）和每 秒完成兆次查找（Mlps）来更合理地描述。 2. <strong>更新速度</strong>。除了查找（分类）性能之外，前缀（规则）更新的速度也是重要 的评价指标之一。尤其近年来，查找和分类算法的更新速度越来越受到重视， 因为当前及未来网络对路由器和分类器的更新性能需求非常高。一般地，对于前缀或规则更新的速度都会使用<strong>每秒完成多少次更新（ups）</strong>、每秒完成多少千次（Kups）或兆次（Mups）更新来定量评价。 3. <strong>内存需求</strong>。一般而言，<strong>对于任何算法它的运行内存占用必定越小越好</strong>。因为 <strong>内存越小就越有可能放入片上存储器，通过提高缓存的命中率来提高算法的性能</strong>。另一方面，对于一些存储非常有限的设备，如TCAM等，内存占用是 一个非常重要的指标。通常情况下，兆字节（MB）会用来评估一个算法运行 内存的大小。对于内存需求很大的算法，往往很难被实际部署。</p>
<h1 id="基于范围向量的高性能在线数据包分类算法">基于范围向量的高性能在线数据包分类算法</h1>
<h1 id="基于-gpu-加速的包分类算法研究与实现">2020基于 GPU 加速的包分类算法研究与实现</h1>
<p>华南理工大学 专业硕士学位答辩 电子与信息学院 王君君</p>
<p>虽然 SDN网络有诸多优点，能满足当前或者未来网络的的业务需求，但由于刚起步，整体技术还不完善，性能上存在诸多瓶颈，OpenFlow作为数据层面转 发数据包依据的主流协议，它打破了传统网络分层的概念，所有需要匹配的字段 都包括在一张流表里面，实现了协议的扁平化[2-3]。随着时间的推移，OpenFlow 协议的版本从最初的 1.0，逐渐发展到 1.1，1.2，1.3，1.4 等版本协议，从协议版 本的升级来看，流表里面用来匹配的字段数量不断增加，从最初 1.0 版本的 15 匹配字段，发展到如今高达 45 个匹配字段，其中有 15 个必检字段[4]。而传统五 元组包分类的算法已经无法满足OpenFlow协议字段匹配的需求，由此OpenFlow 协议的匹配成为了数据平面的一个主要的性能瓶颈。</p>
<p>包分类是一种在预定义规则集中匹配数据包从而根据规则定义的动作处理数据包的方法，其中输入包可以匹配一个或多个规则，我们选择具有最高优先级的规则定义的动作处理输入数据包[5]。</p>
<h1 id="introduction">Introduction</h1>
<h2 id="bytecuts-fast-packet-classification-by-interior-bit-extraction"><em>2018-ByteCuts: Fast Packet Classification by Interior Bit Extraction</em></h2>
<p>Packet classification is an important part of many network devices such as firewalls, routers, and other services. When these devices receive a packet, they must decide how to handle it. <strong>Most packet classifiers are defined by a list of rule.</strong> Each rule matches certain packet headers and defines an action for those packets. <strong>Possible actions include “forward onto physical port 1”, “send to the web server running on this device”, and “discard”.</strong> The classifier finds the first rule that matches a given packet and follows the action associated with that rule.</p>
<p>Rule list sizes have been increasing. As new vulnerabilities are found and new devices are added to the network, new rules are added to deal with these new situations. Rule lists with thousands of rules are now commonplace. Any packet classifier used must be able to handle these increasingly large rule lists.</p>
<p><strong>Packet classifiers must be fast. These network devices have real-time constraints</strong>; delays caused at one device propagate through the network as packet take longer to be forwarded between devices.</p>
<p>数据包分类是许多网络设备的一个重要部分，如防火墙、路由器和其他服务。当这些设备收到一个数据包时，它们必须决定如何处理它。大多数数据包分类器是由一个规则列表定义的。每个规则匹配某些数据包头，并为这些数据包定义一个动作。可能的行动包括 "转发到物理端口1"、"发送到在此设备上运行的网络服务器 "和 "丢弃"。分类器找到第一个匹配给定数据包的规则，并遵循与该规则相关的行动。 规则列表的大小一直在增加。随着新的漏洞被发现和新的设备被添加到网络中，新的规则也被添加进来以处理这些新情况。现在，拥有数千条规则的规则列表已经很常见了。任何使用的数据包分类器必须能够处理这些越来越大的规则列表。 数据包分类器必须是快速的。这些网络设备有实时限制；在一个设备上造成的延迟会通过网络传播，因为数据包在设备之间需要更长的时间来转发。</p>
<p>The packet classification problem is as follows. <strong>Given a rule list L and packet p, find the first (highest-priority) rule in L that matches packet p. This should be done as fast as possible.</strong></p>
<p>This yields the following objective. <strong>Given a rule list L, construct a classifier, subject to memory or other constraints, that minimizes the expected search time for incoming packets.</strong></p>
<p>数据包分类问题如下。给定一个规则列表L和数据包p，找到L中第一个（优先级最高的）与数据包p相匹配的规则，这应该尽可能快地完成。</p>
<p>这就产生了以下目标。给定一个规则列表L，在内存或其他约束条件下，构建一个分类器，使传入数据包的预期搜索时间最小。</p>
<p>Most existing decision trees, such as HyperCuts [1] and HyperSplit [2] have <strong>favored</strong> spending more memory for fast searches. These methods build a search tree by cutting the rules into several sets spacially. This yields O(log n) expected search times. <strong>However, the cuts are not clean</strong>; some rules are copied into multiple subtrees which produces super-linear memory.</p>
<p><strong>Later decision tree variants</strong>, such as EffiCuts [3] and SmartSplit [4] have introduced better tools for <strong>controlling memory usage at the cost of search times</strong>. These methods define several categories of rules which are expected not to require much rule replication, which reduces memory consumption, but it produces multiple trees, which increases search times.</p>
<p>Other methods, such as Tuple Space Search [5], TupleMerge [6], and PartitionSort [7] are able to use only linear memory.</p>
<p><strong>These methods partition the rules into other sets</strong> and then <strong>use either hashing (Tuple Space Search, TupleMerge) or sorting (PartitionSort) to be able to search them</strong>. Classification time is thus tied to the number of partitions required. If the number of partitions becomes large, then search times suffer.</p>
<p>These methods used in OpenFlow and other software-defined networks because they support fast updates.</p>
<p>大多数现有的决策树，如HyperCuts[1]和HyperSplit[2]都倾向于为快速搜索花费更多的内存。这些方法通过在空间上将规则切割成几组来建立搜索树。这产生了O（log n）的预期搜索时间。然而，切割并不干净；一些规则被复制到多个子树中，产生了超线性的内存。</p>
<p>后来的决策树变体，如EffiCuts[3]和SmartSplit[4]引入了更好的工具，以搜索时间为代价控制内存使用。这些方法定义了几类规则，预计不需要太多的规则复制，这就减少了内存的消耗，但是它产生了多个树，增加了搜索时间。</p>
<p>其他的方法，如Tuple Space Search[5]、TupleMerge[6]和PartitionSort[7]，能够只使用线性内存。</p>
<p><strong>这些方法将规则分割成其他的集合，然后使用散列（Tuple Space Search, TupleMerge）或排序（PartitionSort）来能够搜索它们</strong>。因此，<strong>分类时间与所需分区的数量有关</strong>。如果分区的数量变得很大，那么搜索时间就会受到影响。</p>
<p>这些方法在OpenFlow和其他软件定义的网络中使用，因为它们支持快速更新。</p>
<hr>
<p><strong>Rule replication is caused by rules falling into multiple partitions due to wildcards which forces them to be copied multiple times.</strong></p>
<p><strong>规则复制</strong>是由于通配符造成的规则落入多个分区，这迫使它们被多次复制。</p>
<p>Existing methods, such as EffiCuts [3] and SmartSplit [4] have attempted to <strong>alleviate this problem</strong> by <strong>partitioning rules</strong> such that <strong>all rules in the same partition have similar characteristics</strong>. This <strong>significantly</strong> reduces the amount of replication required as <strong>it is easier to find good cuts that do not trigger any of the wildcards.</strong></p>
<p>现有的方法，如EffiCuts[3]和SmartSplit[4]，试图通过对规则进行分区，使同一分区的所有规则具有类似的特征来缓解这一问题。这大大减少了所需的复制量，因为更容易找到不触发任何通配符的良好切割。</p>
<h2 id="fast-packet-classification-using-bloom-filters">2006-Fast Packet Classification Using Bloom Filters</h2>
<p>The general packet classification problem has received a great deal of attention over the last decade. The ability to classify packets into flows based on their packet headers is important for QoS, security, virtual private networks (VPN) and packet filtering applications. Conceptually, a packet classification system must compare each packet header received on a link against a large set of rules, and return the identity of the highest priority rule that matches the packet header (or in some cases, all matching rules). Each rule can match a large number of packet headers, since the rule specification supports address prefixes, wild cards and port number ranges. Much of the research to date has concentrated on the algorithmic techniques which use hardware or software lookup engines, which access data structures stored in commodity memory. However none of the algorithms developed to date has been able to displace TCAMs, in practical applications.</p>
<p>在过去的十年中，一般的数据包分类问题得到了大量的关注。根据数据包头将数据包分类为流量的能力对于QoS、安全、虚拟专用网络（VPN）和数据包过滤应用非常重要。<strong>从概念上讲，数据包分类系统必须将一条链路上收到的每个数据包头与一大批规则进行比较，并返回与数据包头相匹配的最高优先级规则的身份（或在某些情况下，所有匹配规则）。</strong>由于规则规范支持地址前缀、通配符和端口号范围，每个规则都可以匹配大量的数据包头。迄今为止，大部分研究都集中在使用硬件或软件查找引擎的算法技术上，该引擎访问存储在商品内存中的数据结构。然而，迄今为止开发的算法中没有一个能够在实际应用中取代TCAMs。</p>
<p>However, we can use Bloom filters to avoid lookups in subsets that contain no matching rules, making it possible to sustain high throughput.</p>
<p>然而，我们可以<strong>使用布鲁姆过滤器来避免在不包含匹配规则的子集中进行查找，从而使维持高吞吐量成为可能</strong>。</p>
<blockquote>
<p><strong>规则集分成子集，如何避免每一个子集查找是提升速度的关键，通过设立树的优先级、这篇文章提到了布鲁姆过滤器</strong></p>
</blockquote>
<p>In particular, we demonstrate a method, based on Bloom filters and hash tables, that can classify a packet in 4 + p + ? memory accesses where ? is a small constant ? 1 determined by the false positive proba- bility of the Bloom filters. The first four memory accesses are required to perform a Longest Prefix Matching (LPM) on the source/destination addresses and the source/destination ports.</p>
<p>特别是，我们展示了一种基于布隆过滤器和哈希表的方法，它可以在4+p+? 的内存访问中对一个数据包进行分类，其中? 是一个小常数? 1，由布隆过滤器的假阳性率决定。<strong>前四个内存访问需要对源/目的地址和源/目的端口进行最长前缀匹配（LPM）。</strong></p>
<p>The next p memory accesses are requires to lookup the p matching rules for a given packet. Furthermore, the LPM phase and the rule lookup phase can be pipelined with two independent memory chips such that the memory accesses per packet can be reduced to max{4, p}.</p>
<p><strong>接下来的p个内存访问需要为一个给定的数据包查找p个匹配规则。</strong>此外，LPM阶段和规则查询阶段可以用两个独立的内存芯片进行流水线处理，这样每个数据包的内存访问量可以减少到最大{4, p}。</p>
<h1 id="related-work">Related Work</h1>
<h2 id="bytecuts-fast-packet-classification-by-interior-bit-extraction-1"><em>2018-ByteCuts: Fast Packet Classification by Interior Bit Extraction</em></h2>
<p>Packet classification is a well studied problem. Taylor [8] divides packet classification algorithms into four general area: <strong>exhaustive search, decision trees, field decomposition, and tuple space.</strong> Our proposed ByteCuts classifier <strong>falls into</strong> the decision tree category.</p>
<p>数据包分类是一个研究得很好的问题。Taylor[8]将数据包分类算法分为四个大的领域：穷举搜索、决策树、场分解和元组空间。我们提出的ByteCuts分类器属于决策树的范畴。</p>
<p><strong>Summary and Limitations of Prior Art（现有技术的总结和限制）</strong></p>
<p>Decision trees are a well-studied area of packet classification. HiCuts [9] is one of the oldest and most well-known classifiers of this type and has spawned several derivatives. In HiCuts, one field of the packet domain is partitioned (or cut) into several equal-sized pieces. The rules are then allocated to the partitions that they correspond to. This process is repeated for each of these sublists until only a few rules remain. One problem with HiCuts is that the rule and domain boundaries do not always align and rules that cross these boundaries must be replicated into multiple partitions. Rules that are orthogonal to the field being cut are especially problematic since they must be replicated into each partition. This can result in a significant memory blowup.</p>
<p>决策树是数据包分类的一个被充分研究的领域。HiCuts[9]是这种类型的最古老和最著名的分类器之一，并且已经产生了几个衍生产品。在HiCuts中，数据包领域的一个领域被分割（或切割）成几个大小相等的部分。然后，规则被分配到它们所对应的分区中。这个过程对每个子列表重复进行，直到只剩下几条规则。HiCuts的一个问题是，规则和领域的边界并不总是一致的，跨越这些边界的规则必须被复制到多个分区。与被切割领域正交的规则尤其成问题，因为它们必须被复制到每个分区。这可能会导致显著的内存爆炸。</p>
<p>HyperCuts [1] is a variant on HiCuts. Its chief improvement is that it allows cutting on multiple fields at once. This allows the overall tree height to be lower resulting in faster classification times, but it suffers from the same rule replication problem as HiCuts does. The tree that HyperCuts produces for Classifier I can be seen in Figure 2.</p>
<p>HyperCuts[1]是HiCuts的一个变种。它的主要改进之处在于，它允许一次对多个字段进行切割。这使得整个树的高度降低，从而加快了分类的速度，但是它和HiCuts一样存在着规则复制的问题。图2中可以看到HyperCuts为分类器I生成的树。</p>
<p>HyperSplit [2] takes a slightly different approach. Instead of creating many equal-sized cuts, HyperSplit creates a single cut (or split) of variable size. This split is chosen to balance the number of rules in the two resulting partitions. Compared to HiCuts and HyperCuts, this results in less replication and lower memory requirements since each rule is copied into at most two partitions. However, the tree height is normally higher since it has a smaller branching factor. The tree that HyperSplit produces for Classifier I can be seen in Figure 3.</p>
<p>Each of these algorithms has memory problems caused by significant rule replication. ByteCuts prevents this rule replication by separating incompatible rules into different trees.</p>
<p>HyperSplit[2]采取了一种略有不同的方法。HyperSplit不是创建许多大小相等的切割，而是创建一个大小可变的单一切割（或分割）。选择这种分割是为了平衡所产生的两个分区中的规则数量。与HiCuts和HyperCuts相比，这导致了较少的复制和较低的内存需求，因为每个规则最多复制到两个分区中。然而，树的高度通常较高，因为它有一个较小的分支因子。HyperSplit为分类器I产生的树可以在图3中看到。</p>
<p>这些算法中的每一种都有因大量规则复制而引起的内存问题。ByteCuts通过将不兼容的规则分离到不同的树中来防止这种规则的复制。</p>
<p>EffiCuts [3] attempts to solve the rule replication problem by dividing the rules into multiple HyperCuts trees. It classifies rules as being either long or short on a particular field (similar to a tuple space method) and all rules with the same classification are placed into the same tree. Since all of the rules in a given tree have similar properties, it is expected that there will not be much replication required. The downside is that searching multiple trees is likely to take longer than searching a single tree.</p>
<p>SmartSplit [4] tries a similar strategy to EffiCuts except it only considers two fields: source and destination address. This results in fewer trees and thus generally faster search times <strong>at the expense of greater rule replication (though generally less than HyperCuts)</strong>. Additionally, they can estimate the memory usage and tree heights of a rule list to determine whether one or multiple trees would be better as well as if they should use HyperCuts or HyperSplit trees. This allows them to better balance the tradeoffs between speed and memory. This can be seen by comparing the trees in Figure 4 to those in Figures 2 and 3.</p>
<p>SmartSplit has a small, fixed set of trees available and EffiCuts has a limited ability to merge the rule lists for its larger, otherwise fixed set of trees. <strong>In contrast, ByteCuts has a larger, more flexible, set to choose from. This allows it to better fit the rules to trees which leads to less replication and faster searches.</strong></p>
<p>EffiCuts[3]试图通过将规则分为多个HyperCuts树来解决规则复制的问题。它将规则分类为特定领域的长或短（类似于元组空间方法），所有具有相同分类的规则都被放入同一棵树中。由于一个给定的树中的所有规则都有类似的属性，预计不会有太多的复制要求。缺点是搜索多棵树的时间可能比搜索一棵树要长。</p>
<p><strong>SmartSplit[4]尝试了一种与EffiCuts类似的策略，只是它只考虑两个字段：源地址和目的地址。</strong>这导致了更少的树，因此通常更快的搜索时间，代价是更大的规则复制（尽管通常比HyperCuts少）。<strong>此外，他们可以估计内存使用量和规则列表的树高，以确定一个或多个树会更好，以及他们是否应该使用HyperCuts或HyperSplit树。</strong>这使他们能够更好地平衡速度和内存之间的权衡。通过比较图4中的树和图2和图3中的树，可以看出这一点。</p>
<p>SmartSplit有一个小的、固定的树集可用，EffiCuts有一个有限的能力来合并其较大的、其他固定的树集的规则列表。相比之下，ByteCuts有一个更大、更灵活的集合可供选择。这使得它能够更好地将规则与树相匹配，从而减少复制和加快搜索。</p>
<p>PartitionSort [7] bases its trees on the rules themselves rather than the decision space. It defines several partial orderings on the rule list and then partitions the list so that each partition is totally ordered on one of these orderings, which can be binary searched. This allows them to completely do away with rule replication (each rule appears only once). PartitionSort’s tree selection strategy is more stringent than ByteCuts, so it requires more trees resulting in slower classification.</p>
<p>PartitionSort[7]将其树建立在规则本身而不是决策空间上。它在规则列表上定义了几个部分排序，然后对列表进行分区，这样每个分区都是在这些排序中的一个上完全排序，这可以进行二进制搜索。<strong>这使他们能够完全摒弃规则复制（每条规则只出现一次）</strong>。PartitionSort的树选择策略比ByteCuts更严格，<strong>所以它需要更多的树，导致分类更慢。</strong></p>
<p>With exact match, all of the rules in the list are searched.</p>
<p>This normally is done in hardware with TCAMs, which can search the entire list in parallel. Unfortunately, TCAMs do not scale very well. Thus methods such as Firewall Compressor [10], TCAM Razor [11], or Diplomat [12] are used to compress the rule list into a smaller list with identical behavior.</p>
<p>One-dimensional packet classification is a much easier problem; linear-memory solutions with O(log n) search times exist. Field decomposition methods like [13] and [14] classify each field (often in parallel) to acquire some sort of token or partial result. They then use the tokens to determine the matching rule.</p>
<p>In tuple space classifiers, such as Tuple Space Search [5] and TupleMerge [6], each rule is tagged with a tuple denoting which bits it uses. Rules with the same tuple are grouped together into a hash table. By extracting only the bits associated with that tuple, a consistent hash key can be produced from either rules or packets, allowing each table to be searched in constant time.</p>
<p>在精确匹配的情况下，列表中的所有规则都被搜索到。</p>
<p>这通常是在硬件上用TCAM完成的，它可以并行地搜索整个列表。不幸的是，TCAM的规模不是很好。因此，诸如Firewall Compressor[10]、TCAM Razor[11]或Diplomat[12]等方法被用来将规则列表压缩成一个具有相同行为的较小列表。</p>
<p>一维数据包分类是一个更容易的问题；存在搜索时间为O（log n）的线性内存解决方案。像[13]和[14]这样的字段分解方法对每个字段进行分类（通常是并行的）以获得某种标记或部分结果。然后，他们使用令牌来确定匹配规则。</p>
<p>在元组空间分类器中，如元组空间搜索[5]和元组合并[6]，每个规则都被标记为元组，表示它使用了哪些位。具有相同元组的规则被归入一个哈希表。通过只提取与该元组相关的比特，可以从规则或数据包中产生一个一致的哈希密钥，允许在恒定时间内搜索每个表。</p>
<h2 id="fast-packet-classification-using-bloom-filters-1">2006-Fast Packet Classification Using Bloom Filters</h2>
<p>There is a vast body of literature on packet classification.</p>
<p>An excellent survey and taxonomy of the existing algorithms and architectures can be found in [11]. Here, we discuss only the algorithms that are closely related to our work. Algorithms that can provide deterministic lookup throughput is somewhat akin to the basic crossproduct algorithm [9].</p>
<p>The basic idea of the crossproduct algorithm is to perform a lookup on each field first and then combine the results to form a key to index a crossproduct table. The best-matched rule can be retrieved from the crossproduct table in only one memory access. The single field lookup can be performed by direct table lookup as in the RFC algorithm [5] or by using any range searching or LPM algorithms. The BV [6] and ABV [3] algorithms use bit vector intersections to replace the crossproduct table lookup. However, the width of a bit vector equals to the number of rules and each unique value on each field needs to store such a bit vector. Hence, the storage requirement is significant, which limits its scalability.</p>
<p>关于数据包分类有大量的文献。</p>
<p>现有算法和架构的优秀调查和分类法可以在[11]中找到。在这里，我们只讨论与我们工作密切相关的算法。能够提供确定性查找吞吐量的算法有点类似于基本的交叉产品算法[9]。</p>
<p>交叉产品算法的基本思想是先对每个字段进行查找，然后结合结果形成一个键来索引交叉产品表。只需一次内存访问就可以从交叉产品表中检索出最佳匹配的规则。单一字段的查找可以通过RFC算法[5]中的直接查表或使用任何范围搜索或LPM算法来进行。BV[6]和ABV[3]算法使用位向量交集来代替交叉产品表的查找。然而，<strong>位向量的宽度等于规则的数量，每个字段上的每个唯一值都需要存储这样一个位向量。因此，存储需求很大</strong>，这限制了它的可扩展性。</p>
<p>For example, at the first level, if a packet matches m nested source IP address prefixes and n nested destination IP address prefixes, we need m × n hash queries to the hash table with the keys that combine these two fields and the lookups typically result in multiple valid outputs that require further lookups. For a multi-dimensional packet classification, this incurs a large performance penalty.</p>
<p>例如，在第一层，如果一个数据包匹配了m个嵌套的源IP地址前缀和n个嵌套的目的IP地址前缀，<strong>我们需要用结合这两个字段的键对哈希表进行m×n个哈希查询，而且查询通常会产生多个有效输出，需要进一步查询。对于一个多维的数据包分类来说，这产生了一个很大的性能损失。</strong></p>
<p>DIRPE [7], uses a clever technique to encode ranges differently which results in overall lesser rule expansion compared to the traditional method.</p>
<p><strong>DIRPE[7]，使用了一种巧妙的技术对范围进行不同的编码，与传统方法相比，其结果是整体上较少的规则扩展。</strong></p>
<p>Yu et. al. described a different algorithm for multimatch packet classification based on geometric intersection of rules [13]. A packet can match multiple rules because the rules overlap. However, if the rules are broken into smaller sub-rules such that all the rules are mutually exclusive then the packet can match only one rule at a time</p>
<p>Yu等人描述了一种不同的算法，用于基于规则的几何交叉的多匹配包分类[13]。<strong>一个数据包可以匹配多个规则，因为这些规则是重叠的。然而，如果规则被分解成更小的子规则，使所有规则相互排斥，那么数据包一次只能匹配一条规则</strong></p>
<p>This overlap-free rule set is obtained through geometric intersection. Unfortunately, the rule set expansion due to the newly introduced rules by the intersection can be very large.</p>
<p>这个无重叠的规则集是通过几何交叉得到的。不幸的是，由于相交所引入的新规则，规则集的扩展可能非常大。</p>
<p>At the same time one would need to probe each subset independently to search a matching rule. Our algorithm is similar to SSA in that we also try to reduce the overlap between the rules by partitioning them into multiple subsets and thus reduce the overall expansion.</p>
<p>同时，人们需要独立地探测每一个子集来搜索一个匹配的规则。我们的算法与SSA类似，我们也试图通过将规则划分为多个子集来减少规则之间的重叠，从而减少整体的扩展。</p>
<p>However, while SSA only cares about an overlap in all the dimensions, our algorithm considers the overlap in any dimension for the purpose of partitioning. Hence the partitioning technique are different.</p>
<p>Moreover, SSA is a TCAM based algorithm whereas ours is memory based. Finally, SSA requires to probe all the subsets formed, one by one, requiring as many TCAM accesses whereas our algorithm needs only p memory accesses, just as many matching rules as there are per packet.</p>
<p>然而，SSA只关心所有维度上的重叠，而我们的算法为了分区的目的考虑任何维度上的重叠。因此，分区技术是不同的。</p>
<p>此外，SSA是一个基于TCAM的算法，而我们的算法是基于内存的。最后，SSA需要逐一探测所有形成的子集，需要同样多的TCAM访问，而我们的算法只需要p个内存访问，就像每个数据包有多少个匹配规则一样。</p>
<p>For 5-tuple classification, we don’t need to perform the LPM for the protocol field; it can be a direct lookup in a small on-chip table</p>
<p>对于5元组分类，我们不需要对协议字段进行LPM，它可以直接在一个小型片上表中进行查找</p>
<blockquote>
<p>前人只关注源IP、目的IP，却没有说源port和目的port怎么查找，源port和目的port是范围</p>
</blockquote>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://peirsist.github.io/2022/11/02/%E8%AE%BA%E6%96%87/2017-BitCuts/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Peirsist">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="EEWIKI">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | EEWIKI">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/11/02/%E8%AE%BA%E6%96%87/2017-BitCuts/" class="post-title-link" itemprop="url">BitCuts</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2022-11-02 10:06:48" itemprop="dateCreated datePublished" datetime="2022-11-02T10:06:48+08:00">2022-11-02</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2022-11-13 23:04:16" itemprop="dateModified" datetime="2022-11-13T23:04:16+08:00">2022-11-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E8%AE%BA%E6%96%87/" itemprop="url" rel="index"><span itemprop="name">论文</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="Word count in article">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">Word count in article: </span>
      <span>51</span>
    </span>
    <span class="post-meta-item" title="Reading time">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">Reading time &asymp;</span>
      <span>1 mins.</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="启示">启示</h1>
<h1 id="摘要">摘要</h1>
<h1 id="基础知识">基础知识</h1>
<h2 id="预备知识">预备知识</h2>
<h2 id="文中基础概念">文中基础概念</h2>
<h1 id="introduction">Introduction</h1>
<h1 id="background">Background</h1>
<h1 id="方案">方案</h1>
<h1 id="实验">实验</h1>
<h1 id="结论">结论</h1>
<h1 id="参考文献">参考文献：</h1>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://peirsist.github.io/2022/10/31/%E8%AE%BA%E6%96%87/2021-MBitTree/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Peirsist">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="EEWIKI">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | EEWIKI">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/10/31/%E8%AE%BA%E6%96%87/2021-MBitTree/" class="post-title-link" itemprop="url">MBitTree</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2022-10-31 19:06:48" itemprop="dateCreated datePublished" datetime="2022-10-31T19:06:48+08:00">2022-10-31</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2022-11-13 23:04:30" itemprop="dateModified" datetime="2022-11-13T23:04:30+08:00">2022-11-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E8%AE%BA%E6%96%87/" itemprop="url" rel="index"><span itemprop="name">论文</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="Word count in article">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">Word count in article: </span>
      <span>10k</span>
    </span>
    <span class="post-meta-item" title="Reading time">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">Reading time &asymp;</span>
      <span>9 mins.</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="启示">启示</h1>
<ol type="1">
<li>位切割</li>
<li>为每一颗树设立优先级</li>
<li>划分方法，不采用规则范围，采用前缀长度，来聚类，似乎更合理。</li>
</ol>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/wolfzone025/article/details/6577668">IP数据包分类经典算法总结</a></p>
<h1 id="摘要">摘要</h1>
<p>摘要--数据包分类是许多网络服务的关键组成部分，如服务质量和网络安全。这些网络服务要求数据包分类尽可能快，同时使用较少的内存并支持可扩展性。此外，软件定义的网络交换机在规则集的高维度和大尺度方面对数据包分类提出了新的挑战。在本文中，我们提出了一个名为MBitTree的新解决方案，它包括对现有决策树算法的两个主要改进。首先，我们引入了一种新的规则集划分技术，以实现自适应和快速的规则集划分。第二，采用新的多比特切割方案来构建短树，同时很少造成规则复制。</p>
<p>MBitTree可以提供较高的分类速度，并具有良好的可扩展性。实验结果表明，与CutSplit相比，MBitTree实现了高达6.8倍的内存消耗，以及高达1.7倍的内存访问次数的减少。此外，我们在FPGA上实现了MBitTree的原型，实施结果表明，我们的方法对于10K的规则集可以实现超过100Gbps的吞吐量，在NetFPGA上可以处理超过100K的规则集。</p>
<p>Index Terms-packet classification, decision tree, bit cutting, FPGA</p>
<h1 id="基础知识">基础知识</h1>
<h2 id="预备知识">预备知识</h2>
<ol type="1">
<li>K-means聚类分析
<ol type="1">
<li>与分类、序列标注等任务不同，聚类是在事先并不知道任何样本标签的情况下，通过数据之间的内在关系把样本划分为若干类别，使得同类别样本之间的相似度高，不同类别之间的样本相似度低（即增大类内聚，减少类间距）。</li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_43741312/article/details/97128745">K-means聚类算法原理及python实现</a></li>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/184686598">KMeans聚类算法详解</a></li>
</ol></li>
<li>距离的度量
<ol type="1">
<li><a target="_blank" rel="noopener" href="https://img-blog.csdn.net/20161218152146962?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdGFveWFucWk4OTMy/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast">距离的度量</a></li>
</ol></li>
</ol>
<h2 id="文中基础概念">文中基础概念</h2>
<ol type="1">
<li>IP地址的前缀长度倾向于分布在边缘，即很大一部分前缀长度位于0或32附近，如图3所示。因此，我们使用IP地址作为聚类的基础。</li>
<li>FW规则集中有更复杂的几何结构</li>
</ol>
<h1 id="introduction">Introduction</h1>
<p>数据包分类是许多网络服务的关键组成部分，例如服务质量(QoS)、网络安全和策略路由。数据包分类的速度对这些网络服务的性能有着重要的影响。因此，包分类是网络研究中一个非常活跃的课题。</p>
<p>当前的数据包分类解决方案可以大致分为两类:基于硬件的解决方案和基于软件的解决方案[1]。使用三态内容可寻址存储器(TCAM) [2]、[3]、[4]的基于硬件的解决方案已成为行业中数据包分类的主要实施方式。它们利用TCAM将所有规则存储在关联存储器中，然后并行地将数据包与所有这些规则进行匹配。TCAM提供了恒定的分类时间并保证了高性能，但它有一些明显的限制，如高成本和高能耗[5]，使其无法实现大型分类器。相比之下，基于软件的解决方案，也称为算法解决方案，因其低成本和灵活性而受到广泛关注。随着软件定义网络(SDN)的出现，对高性能分组分类算法有着强烈的需求。</p>
<p>有两种类型的包分类软件算法:基于散列和基于决策树的解决方案。其中，基于哈希的解决方案[6]、[7]、[8]支持快速更新，并使用线性内存，但由于大型规则集中的哈希冲突和元组扩展，它们存在性能问题。另一方面，决策树算法正被积极地研究，因为它们适合于处理具有许多领域的分类器，并且有助于在硬件上实现。在过去的二十年里，人们提出了大量的决策树算法，如基于等长切割的决策树[9]、[10]和基于等密切割的决策树[11]。这些算法的总体目标是在降低内存消耗的同时提供高吞吐量。</p>
<p>然而，由于这些算法没有充分利用规则集的分布特征，随着字段数量和规则集大小的增长，设计高效的决策树算法非常具有挑战性。例如，OpenFlow交换机需要检查超过15个字段来对传入的数据包进行分类[12]，并且字段的数量预计在未来会增加。现代数据中心中大型规则集的规模可能达到数十万条规则[13]。</p>
<p>此外，随着软件交换机的部署，在吞吐量、内存占用、可扩展性和更新性能方面对分组分类算法提出了更严格的要求。</p>
<p>为了更好地利用规则集的分布特性，本文提出了一种新的决策树算法MBitTree，该算法能够以适中的内存占用提供较高的分类速度，并具有良好的可扩展性。</p>
<p>MBitTree分两个阶段构建决策树。首先，我们提出了一种基于聚类算法的高效规则集划分技术，以实现自适应的快速规则集划分。这样就得到几个子集，其中特定领域前缀长度比较接近的规则属于同一个子集。第二，由于大多数规则属于前缀长度较长的子集，并且有更多的可选位来分隔规则，同时很少在这些子集中引起规则复制，因此使用新的多位切割方案来为这些子集构建短树。还有少数规则前缀长度短，可选位数少，所以使用优先级排序元组搜索空间[7]等其他算法辅助。</p>
<p>本文的主要贡献如下: 1. 提出了一种新的<strong>规则集划分技术</strong>，能够实现快速、自适应的规则集划分，适用于各种类型的规则集。 2. 提出了一种新的<strong>位切割方案</strong>，它可以构建一个短树，同时很少引起规则复制。 3. 我们揭示了为什么我们提出的多位切削是可行和有效的原因。 4. 我们在FPGA上实现了MBitTree的原型，我们的方法可以为10K规则集实现超过100 Gbps的吞吐量，并且可以处理超过100K个规则集</p>
<p>我们使用ClassBench [14]来评估我们的方法。实验结果表明，MBitTree可以生成有限数量的短决策树，并且具有适中的内存占用。与CutSplit [15]相比，MBitTree的内存消耗减少了6.8倍，平均内存访问次数减少了1.7倍。MBitTree可以在100k规则集上以毫秒而不是秒的速度构建决策树。此外，我们在FPGA上实现了MBitTree的原型。</p>
<p>本文的其余部分组织如下。第二节介绍了研究背景，并对相关工作进行了总结。第三节介绍了MBitTree的技术细节。</p>
<p>第四节提供了实验结果。最后，第五部分得出结论和我们未来的工作</p>
<h1 id="background">Background</h1>
<p>在本节中，我们首先回顾了数据包分类的背景。之后，我们简要介绍两种相关的算法方法：决策树和基于哈希的解决方案。</p>
<h2 id="a.-数据包分类问题">A. 数据包分类问题</h2>
<p>一个数据包分类器包含一个规则列表，每个规则由多个匹配字段和数据包匹配时要采取的行动组成。例如，在标准的5元分类器中，有IP地址、端口号和协议类型。</p>
<p>OpenFlow 1.0扩展了标准5元组，增加了7个头字段[12]。数据包分类的目的是从规则列表中找到一个传入的数据包所匹配的具有最高优先级的规则。表一显示了一个2元组分类器的例子。</p>
<h2 id="b.-基于决策树的解决方案">B. 基于决策树的解决方案</h2>
<p>数据包分类可以被看作是计算几何学中的点定位问题[16]。数据包头中的字段对应于几何空间的尺寸。而一个数据包表示一个点，而一条规则表示空间中的一个超矩形。那么，对一个数据包进行分类就相当于找到包含代表数据包的点的最高优先级的超矩形。表一中的规则集的几何视图如图1所示。 <img src="https://cdn.staticaly.com/gh/peirsist/blog_img@master/1.3x6q7w68qew0.png" alt="规则集"></p>
<p>在基于决策树的解决方案中，数据包分类问题的几何视图被采纳，并建立了一棵决策树。树的根节点覆盖了包含所有规则的整个搜索空间。然后迭代地将搜索空间划分为更小的子空间，直到每个子空间所覆盖的规则不超过一个称为binth的桶大小。接下来，我们将讨论建立决策树进行数据包分类的两种常见技术：节点切割和规则集分区。</p>
<h3 id="节点切割">1）节点切割。</h3>
<p>根据搜索空间的划分方法，节点切割技术可分为三种主要方法：等尺寸切割、等密度切割和比特切割。</p>
<ol type="1">
<li><strong>等大小切割。</strong></li>
</ol>
<p>HiCuts[9]对搜索空间进行切割，以创建一组等大小的子空间，这些子空间将规则尽可能均匀地分开。然而，HiCuts只考虑在一个节点上切割一个维度，所以HiCuts构建的树的深度会很高。HyperCuts[17]是HiCuts的一个改进。首先，HyperCuts提出在一个节点上同时切割多个维度。其次，HyperCuts提出了一个优化方案，将所有兄弟姐妹共有的规则移到父节点。然而，在HyperCuts中仍然存在相当多的规则冗余。原因是，等密切割适合于规则集分布均匀的情况，但在现实中并不均匀。</p>
<ol start="2" type="1">
<li><strong>等密切割。</strong></li>
</ol>
<p>HyperSplit[11]提出沿规则边界切割搜索空间，构建一个平衡的二叉树，使规则均匀地分布在子节点。HyperSplit在一定程度上减少了内存消耗，但它只考虑一个节点的一个维度。随着规则集规模的扩大，HyperSplit构建的树的深度将迅速增加。等密切割基本上是牺牲了分类速度来换取较低的内存使用量。</p>
<ol start="3" type="1">
<li><strong>比特切割。</strong></li>
</ol>
<p><strong>位切割的想法是从规则中提取一些离散的位，将这些位解释为一个数字，并将这个数字作为索引放入子节点的阵列中。</strong></p>
<p>与等尺寸切割和等密度切割相比，位切割更加灵活，但其性能取决于位选择方案。研究人员提出了许多位选择方案，如D2BS中的最大子节点最小化[18]，BitCuts中的规则分离性[19]，MC-SBC中的信息熵[20]，以及ByteCuts中的子节点规则数最小化[21]。这些方案从不同角度对位选择提出了独特的见解。然而，它们也有一些不足之处。例如，它们中的大多数没有考虑到位之间的相关性，很容易陷入局部最优方案中。</p>
<h3 id="规则集的划分">2）规则集的划分。</h3>
<p>通过节点切割建立单一的决策树存在固有的缺陷。它没有考虑规则之间的差异，如表I中的R1和R11，导致了大量的规则复制。解决这个问题的方法之一是规则集分区技术。它根据规则的特点将一个规则集划分为若干个子集，这样可以大大减少内存的消耗，同时对算法的吞吐量造成很小的影响。</p>
<p>EffiCuts[10]是一个著名的算法，它根据字段大小对规则集进行分区。EffiCuts提出了可分离树的思想，将小规则和大规则放在不同的子集中，然后用等大小的切割来为每个子集建立一棵独立的树。EffiCuts的问题是，它使用所有字段来划分规则集，并产生了太多的子集。例如，对于F元组的规则集，最多可以生成2F的子集。HybridCuts[22]和SmartSplit[23]只使用IP地址字段来划分规则集，以避免产生过多的子集。CutSplit[15]和CutTSS[24]通过选择极少数小字段作为规则集划分的基础，进一步将其扩展到多字段规则集。基于字段大小的规则集划分可以有效地分离规则集，它需要定义一个关键阈值来区分大字段和小字段。然而，对于各种类型的规则集来说，很难找到一个最佳阈值。</p>
<p>ParaSplit[25]使用聚类和模拟退火算法来寻找最佳分区，但它需要数万次的迭代才能收敛。最近的工作NeuroCuts[26]使用深度神经网络对规则集进行自适应的分割。在面对各种规则集时，它的通用性更强，但它也需要大量的训练，并且需要很长的时间来收敛到其最佳解决方案。PartitionSort[27]通过将规则集划分为几个可排序的子集并为每个子集构建一个MITree，实现了对数的分类和更新时间。然而，由于对分区的严格限制，PartitionSort比SmartSplit和CutSplit产生更多的树，导致更多的内存访问和更慢的分类速度。</p>
<h2 id="c.-基于哈希的解决方案">C. 基于哈希的解决方案</h2>
<p>元组空间搜索（TSS）[6]将规则划分为不同的元组，每个元组对应一个哈希表，所以它只需要一次内存访问就可以向哈希表插入和删除规则。TSS具有使用线性内存和支持快速更新的优点，但由于哈希碰撞和元组扩展，有一个性能问题。PSTSS [7] 和 TupleMerge [8] 是 TSS 的改进。PSTSS通过对图元按优先级降序排序来减少平均查表次数，但其最差的搜索性能与TSS相同。TupleMerge通过放宽规则可以放在同一个元组中的限制来减少元组的数量，但是合并元组可能导致哈希冲突的增加。</p>
<h1 id="方案">方案</h1>
<p>在本节中，我们首先介绍了MBitTree的框架。然后，我们对规则集的分布做了几个关键的观察，并根据我们的观察结果提出了一个自适应的规则集划分技术。之后，使用多比特切割方案来构建子集的树，以利用规则集的分布特征。最后，我们描述了如何对一个数据包进行分类。</p>
<h2 id="a.-思路与框架">A. 思路与框架</h2>
<p>根据以上回顾，规则集分区可以大大减少规则的复制，同时对吞吐量造成的影响很小。与等尺寸切割和等密度切割相比，位切割是一种更灵活的节点切割方法，其性能取决于位选择方案。因此，我们的想法是将规则集分区和位切割结合起来，建立一个高效的决策树。我们提出了一个自适应的规则集分区技术和一个多比特切割方案来建立一个高效的决策树。</p>
<p>MBitTree的框架包括构建决策树和数据包分类，如图2所示。MBitTree通过两个步骤建立决策树：规则集分区和多比特切割。</p>
<figure>
<img src="https://cdn.staticaly.com/gh/peirsist/blog_img@master/Snipaste_2022-10-31_23-25-10.1p3lqj6awa80.png" alt="MBitTree的框架"><figcaption aria-hidden="true">MBitTree的框架</figcaption>
</figure>
<h3 id="a-自适应规则集分区">a) <strong>自适应规则集分区</strong>。</h3>
<p>我们根据对规则集的观察结果，选择一些适当的字段作为规则集分区的基础。然后使用聚类算法来实现快速和自适应的规则集划分，因此得到了几个子集。</p>
<h3 id="b-多位切割">b) <strong>多位切割</strong>。</h3>
<p>采用多比特切割方案来建立子集的树，它使用比特分离能力和通配符比率作为选择切割比特的标准，称为有效比特。</p>
<h3 id="c-数据包分类">c) <strong>数据包分类</strong>。</h3>
<p>MBitTree搜索每一棵树以找到匹配规则。为了搜索一棵树，我们首先看它的根节点并检查节点的类型。如果它是一个叶子节点。</p>
<p>我们使用线性搜索来获得匹配规则。否则，我们使用存储在内部节点的有效位来遍历树，直到到达一个叶子节点为止。</p>
<h2 id="b.-自适应规则集分区">B. 自适应规则集分区</h2>
<p>规则集的分布有特定的特点，利用这些特点有助于建立一个更好的树。我们对访问控制列表（ACL）、防火墙（FW）和IP链（IPC）规则集做了一些观察。可以发现，IP地址的前缀长度倾向于分布在边缘，即很大一部分前缀长度位于0或32附近，如图3所示。因此，我们使用IP地址作为聚类的基础。具体来说，首先得到每个规则的SrcIP和DstIP前缀长度，并用二维坐标系中的一个点表示，其中X轴代表SrcIP的前缀长度，Y轴代表DstIP的前缀长度。例如，一个SrcIP为8.76.223.16/31，DstIP为184.144.168.0/24的规则被映射到坐标系中的点（31，24）。此外，我们还分析了OpenFlow分类器中IP前缀长度的分布。我们使用ClassBench-ng[28]，一个新的开源工具，来生成OpenFlow 1.0流量规则。类似的趋势也可以在OpenFlow规则集中找到。 <img src="https://cdn.staticaly.com/gh/peirsist/blog_img@master/Snipaste_2022-10-31_23-25-24.4s1lkko2nle0.png" alt="SIP前缀长度分布"></p>
<p>在将规则集中的所有规则映射到二维坐标系后，我们使用基于分区的聚类算法K-means对规则集进行分区，因为其聚类速度快，时间复杂度低。K-means的关键是选择聚类的数量和每个聚类的初始中心点。我们根据规则集的分布特征，设定聚类数k=4，每个聚类的初始中心点为C0（24，24）、C1（24，0）、C2（0，24）、C3（0，0）。需要注意的是，聚类数量和初始聚类中心的选择对聚类结果有很大影响。通过实验证明，我们的选择是合理的。一般来说，完成聚类过程只需要2-4次迭代，所以聚类的时间开销很低。</p>
<p>在选择了k个初始聚类中心后，计算每个规则的点到k个中心的距离，并将该规则归入最近的聚类，然后重新计算新的聚类中心。我们在聚类过程中<strong>使用平方的欧几里得距离</strong>。重复上述过程，直到满足收敛条件，即每个聚类中心的位置没有变化。聚类的目的是把SrcIP和DstIP前缀长度比较接近的规则放到同一个聚类中，每个聚类对应一个子集，这样可以为以后的多比特切割提供更多的可选位。</p>
<p>以表I中的规则为例，由于每个字段的位宽为3，所以每个簇的初始中心分别为C0（3，3）、C1（3，0）、C2（0，3）和C3（0，0）。</p>
<p>规则R1-R11的聚类结果如表二所示。</p>
<p>从这个例子中可以看出，大部分规则被归入前缀较长的集群，包括C0、C1和C2，而C3集群中的规则数量非常少。 <img src="https://cdn.staticaly.com/gh/peirsist/blog_img@master/Snipaste_2022-10-31_23-26-13.6xrnfggmojc0.png" alt="规则R1-R11的聚类结果"></p>
<h2 id="c.-有效位的选择">C. 有效位的选择</h2>
<p>在规则集分割后得到几个子集，然后用多位切割来建立子集的决策树。</p>
<p>关键问题是如何选择最佳的切割位，称为有效位，以均匀地分离规则。对于一个有d个字段和l个长度的规则集（例如，在传统的五元组规则集中，d等于5，l等于104），我们为每条规则创建一个比特串。位串中每个比特的值是0、1和通配符（*）中的一个。</p>
<p>有两个指标被用来选择有效的位：位分离能力和通配符比率。位分离能力决定了规则分布在这个位位置上是否均匀，通配符比率估计了规则复制的程度。 <img src="https://cdn.staticaly.com/gh/peirsist/blog_img@master/Snipaste_2022-10-31_23-25-41.10u4nzrv8068.png" alt="ACL规则集位分布"></p>
<p>Effective Bit选择算法如图所示： <img src="https://cdn.staticaly.com/gh/peirsist/blog_img@master/Snipaste_2022-10-31_23-25-52.4yvd5idejwo0.png" alt="Effective Bit选择算法"></p>
<h2 id="d.-位的相关性">D. 位的相关性</h2>
<p>当面对大规模的规则集时，需要在一个节点上选择多个位来降低树的高度。在随后的位选择中，如果我们只用S（i）和P（i）作为选择标准，就会产生位之间的相关性问题，即这些位上的值大致相同。</p>
<p>例如，对于表二中的规则R1-R7，第3位和第5位上的数值几乎相同，所以选择这两个位作为有效位的结果与选择其中一个位相同。</p>
<p>有两种方法可以解决比特之间的相关性问题：计算比特之间的相关性和从最大的子节点中选择有效比特。然而，计算比特的相关性会带来很多额外的计算。此外，计算两个比特之间的相关性很容易，但要计算三个或更多比特之间的相关性就很难。在实践中，我们经常需要在一个节点上选择三个以上的有效比特。</p>
<p>因此，我们采用第二种方法：从最后一个比特选择过程中形成的规则数量最多的子节点中选择有效比特，这样所选择的有效比特可以进一步分离非叶子节点[29]。这种方法可以保证这次选择的有效位不会与之前的有效位产生关联问题。例如，图4中第一次选位后形成了两个子节点，在接下来的选位过程中，我们将左边的子节点作为计算对象，所以选择了第3位作为有效位。MBitTree对规则R1-R7产生的树如图6所示。 <img src="https://cdn.staticaly.com/gh/peirsist/blog_img@master/Snipaste_2022-10-31_23-26-04.kt4p7eydw5c.png" alt="切割后结果"></p>
<figure>
<img src="https://cdn.staticaly.com/gh/peirsist/blog_img@master/Snipaste_2022-10-31_23-26-26.42pmis2c6te0.png" alt="多位切割"><figcaption aria-hidden="true">多位切割</figcaption>
</figure>
<p>通过多位切割建立的决策树是一个迭代过程，所以我们需要决定何时停止多位切割过程。在节点中的规则数量不超过一个叫做binth的阈值的情况下，多比特切割就会停止。</p>
<h2 id="e.-数据包分类">E. 数据包分类</h2>
<p>通过多位切割建立的树数量有限。为了对一个数据包进行分类，MBitTree搜索每一棵树，以找到匹配的规则。<strong>为了避免不必要的查找，每棵树都引入了一个树的优先级，它被设置为树中最高的规则优先级</strong>。在查找时，如果匹配规则的优先级大于树的优先级，那么就跳过这棵树。为了搜索一棵树，我们首先看它的根节点，并检查节点类型。如果它是一个叶子节点，我们使用线性搜索来获得匹配规则。否则，我们使用存储在内部节点的有效位来遍历树，直到到达一个叶子节点。</p>
<p><strong>MBitTree的节点数据结构</strong>如图7所示。我们用1个字节来表示节点的类型：内部节点或叶子节点。对于每个内部节点，我们用1个字节表示有效位的数量，8个字节用于有效位信息，包括维度和位置。叶子节点用1个字节表示叶子节点所覆盖的规则数。内部节点和叶子节点都使用4个字节来存储阵列指针。 <img src="https://cdn.staticaly.com/gh/peirsist/blog_img@master/Snipaste_2022-10-31_23-26-37.2swxztywvju0.png" alt="MBitTree的节点数据结构"></p>
<h2 id="f-.-基于fpga的实现">F . 基于FPGA的实现</h2>
<p>为了实现高吞吐量，我们将MBitTree构建的决策森林（包括n个子树）映射到具有n个线性管道的并行多管道架构中，如图8所示，其中黄色块表示内部节点的遍历，蓝色块表示叶节点的规则匹配。每条管道都用来遍历决策树，并与树的叶子节点上的规则列表相匹配。树的遍历阶段由一个存储树节点的内存块和一个基于有效位生成内存访问地址的逻辑组成，如图9所示。叶子节点中的规则是并行匹配的，以充分利用FPGA上可用的并行性，包括规则之间和规则内字段之间的并行搜索。优先级解析器从n条流水线的输出中选择具有最高优先级的规则。</p>
<p>此外，由于FPGA上的块RAM支持双端口读取，流水线可以利用这一功能在每个时钟周期内处理两个数据包。因此，一个双包搜索流水线可以实现2倍的速度提升。由于篇幅有限，我们简要介绍一下初步结果。</p>
<p>最大的时钟速率是从后置和路由报告中得到的。使用10K规则集，在NetFPGA上实现的时钟超过150MHz。这相当于64字节最小尺寸数据包的吞吐量超过100Gbps。</p>
<p>我们的架构也可以处理超过100K的规则集。 <img src="https://cdn.staticaly.com/gh/peirsist/blog_img@master/Snipaste_2022-10-31_23-26-53.6mtp2g7e9ok0.png" alt="MBiTree多流水线架构"></p>
<figure>
<img src="https://cdn.staticaly.com/gh/peirsist/blog_img@master/Snipaste_2022-10-31_23-27-13.1mzhoi75kyv4.png" alt="硬件中树遍历过程"><figcaption aria-hidden="true">硬件中树遍历过程</figcaption>
</figure>
<h1 id="实验">实验</h1>
<p>在本节中，我们将MBitTree与HybridCuts[22]、PartitionSort[26]和CutSplit[15]进行比较。我们使用ClassBench[14]来生成实验的规则集。ClassBench包括3个不同类别的12个不同的种子文件。5个访问控制列表（ACL），5个防火墙（FW），和2个IP链（IPC）。我们为每个种子生成3种不同大小的规则集，分别为1k、10k和100k。规则集是用种子类型和大小来命名的，例如，ACL1 1k意味着ACL1类型的规则集有大约1000条规则。此外，我们还为ACL1、FW1和IPC1种子类型生成了500k和1M的规则集，以验证MBitTree的可扩展性。</p>
<p>我们测量了四个指标：内存访问、内存足迹、构建时间和可扩展性。所有的实验都是在一台装有Intel Core i7 CPU @ 1.80GHz和8GB内存的机器上进行的，运行Ubuntu 18.04并使用GCC 7.5.0编译。</p>
<h2 id="a.-内存访问">A. 内存访问</h2>
<p>图10显示了MBitTree以及HybridCuts、PartitionSort和CutSplit的平均内存访问次数。</p>
<p>很明显，MBitTree的表现优于其他算法，而且随着规则集的增大，其改善程度也在增加。例如，对于FW 1k规则集和FW 10k规则集，MBitTree需要20和23次内存访问来分类一个数据包，而CutSplit分别需要31和38次内存访问。MBitTree平均需要16次内存访问来对数据包进行分类，而在HybridCuts、PartitionSort和CutSplit中，它分别需要30、28和38次内存访问。与HybridCuts、PartitionSort和CutSplit相比，MBitTree平均实现了1.9倍、2.4倍和1.7倍的改进。</p>
<p>优先排序树的优化方法可以大大降低平均内存访问量。如果找到一个高优先级的规则，就不需要搜索后面的树，因为这些树中没有更高优先级的规则。因此，MBitTree可能只需要查看一棵大树。此外，MBitTree使用多个比特来分隔规则，所以可以建立更短的决策树。例如，在一个节点上选择i个有效位可以创建2i个子节点。</p>
<p>这些解释了为什么MBitTree在内存访问数量上比HybridCuts和CutSplit表现得好得多。</p>
<p>PartitionSort需要更多的内存访问来对一个数据包进行分类，因为它比其他三种算法产生更多的分区子集。PartitionSort中分区子集的数量从2到49不等，平均为21.8个子集。相比之下，无论规则集的类型和大小如何，MBitTree产生的子集数量相对稳定，平均为3.8个子集。 <img src="https://cdn.staticaly.com/gh/peirsist/blog_img@master/Snipaste_2022-10-31_23-27-29.4qj5clqn0vi0.png" alt="平均内存访问次数"></p>
<h2 id="b.-内存占用">B. 内存占用</h2>
<p>图11显示了MBitTree以及HybridCuts、PartitionSort和CutSplit的内存足迹。对于大多数规则集，MBitTree比HybridCuts、PartitionSort和CutSplit消耗的空间更少。在所有的规则集中，MBitTree平均消耗13.2字节/规则，而在HybridCuts、PartitionSort和CutSplit中，它平均需要35.4字节/规则、55.4字节/规则和90.3字节/规则。MBitTree的低内存占用率意味着在MBitTree构建的树中很少有规则重复。应该注意的是，CutSplit在一些FW规则集上消耗的空间更大。原因是在这些FW规则集中有更复杂的几何结构。而且CutSplit在预切割阶段后使用HyperSplit来构建树，而HyperSplit对这些规则集有某些不兼容的问题，产生了突然的内存爆炸。 <img src="https://cdn.staticaly.com/gh/peirsist/blog_img@master/Snipaste_2022-10-31_23-27-51.ni7s0vsqab4.png" alt="平均内存占用"></p>
<h2 id="c.-构建时间">C. 构建时间</h2>
<p>图12显示了MBitTree以及HybridCuts、PartitionSort和CutSplit在100k规则集上的构建时间。很明显，PartitionSort是其中最快的一个。相比之下，MBitTree比PartitionSort多花了一点时间，因为它在位选择过程中进行了几次迭代。然而，MBitTree仍然可以在一秒钟内为所有100k规则集建立决策树，比HybridCuts和CutSplit快得多。与CutSplit相比，MBitTree对100k规则集的平均构建时间减少了一个数量级。 <img src="https://cdn.staticaly.com/gh/peirsist/blog_img@master/Snipaste_2022-10-31_23-28-00.rba08lozb2o.png" alt="100K规则集构建时间"></p>
<h2 id="d.-可扩展性">D. 可扩展性</h2>
<p>图13显示了MBitTree从1k规则集到1M规则集的内存占用情况。可以发现，内存占用与规则集的规模之间几乎呈线性关系。MBitTree为50万条规则集构建决策树只消耗了几个MBytes，为100万条规则集构建决策树则消耗了大约10Mbytes。内存占用的良好可扩展性使得MBitTree适用于大型分类器。 <img src="https://cdn.staticaly.com/gh/peirsist/blog_img@master/Snipaste_2022-10-31_23-28-13.20ozqkc5j3s0.png" alt="不同大小规则集内存占用"></p>
<h1 id="结论">结论</h1>
<p>我们提供了两个关键的贡献。首先，我们提出了<strong>一种基于聚类的新的规则集划分技术</strong>，以实现自适应和快速的规则集划分。其次，我们提出了<strong>一种新的多比特切割方案</strong>，以建立一个短的树，同时很少引起规则复制，它使用比特分离能力和通配符比例来选择有效的比特。我们一起提出了MBitTree，一个新的基于树的数据包分类解决方案，在内存访问和内存占用方面改进了现有的决策树算法，包括CutSplit。我们还在FPGA上实现了MBitTree的原型，我们的方法可以在NetFPGA上处理超过100K的规则集。</p>
<h1 id="参考文献">参考文献：</h1>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://peirsist.github.io/2022/10/30/%E9%9A%8F%E7%AC%94%E4%B8%8E%E4%B8%AA%E4%BA%BA%E6%96%87%E9%9B%86/%E7%AC%AC315%E5%B0%81%E4%BF%A1%E4%B8%A8%E6%AF%94%E7%A9%B7%E6%9B%B4%E5%8F%AF%E6%80%95%E7%9A%84%E6%98%AF%E4%BB%80%E4%B9%88/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Peirsist">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="EEWIKI">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | EEWIKI">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/10/30/%E9%9A%8F%E7%AC%94%E4%B8%8E%E4%B8%AA%E4%BA%BA%E6%96%87%E9%9B%86/%E7%AC%AC315%E5%B0%81%E4%BF%A1%E4%B8%A8%E6%AF%94%E7%A9%B7%E6%9B%B4%E5%8F%AF%E6%80%95%E7%9A%84%E6%98%AF%E4%BB%80%E4%B9%88/" class="post-title-link" itemprop="url">第315封信《硅谷来信》丨比穷更可怕的是什么</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2022-10-30 19:06:48" itemprop="dateCreated datePublished" datetime="2022-10-30T19:06:48+08:00">2022-10-30</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2023-01-05 16:11:02" itemprop="dateModified" datetime="2023-01-05T16:11:02+08:00">2023-01-05</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E9%9A%8F%E7%AC%94%E4%B8%8E%E4%B8%AA%E4%BA%BA%E6%96%87%E9%9B%86/" itemprop="url" rel="index"><span itemprop="name">随笔与个人文集</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="Word count in article">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">Word count in article: </span>
      <span>2.8k</span>
    </span>
    <span class="post-meta-item" title="Reading time">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">Reading time &asymp;</span>
      <span>3 mins.</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <figure>
<img src="https://cdn.staticaly.com/gh/peirsist/blog_img@master/第315封信丨比穷更可怕的是什么.6fpa2n37z3c.jpg" alt="第315封信丨比穷更可怕的是什么"><figcaption aria-hidden="true">第315封信丨比穷更可怕的是什么</figcaption>
</figure>
<p>（转载）</p>
<p><strong>读者，你好！</strong></p>
<p>一位读者留言说，她的朋友讲，过去穷怕了，因此现在行为有点乖张，请她见谅。虽然她所说的朋友现在不仅不穷，而且拥有多套住房，以中国的房价来衡量，还颇为富有，但是过去的习惯一点也没有改变。</p>
<p>她说的这种现象似乎并不少见，今天总有人讲，小时候穷，一辈子穷，被很多人用来形容逆袭的艰难。<strong>小时候穷确实会带来很多不良的后果，比如缺乏安全感</strong>，一旦有了权力会用非常赤裸裸的手段贪污。台湾的陈水扁就是一个很好的例证。</p>
<p>再比如<strong>容易人穷志短，缺乏远见卓识，以至于走不出原有生活的圈子</strong>，比如美国贫民区家庭的孩子大多如此。又或者受到太多人的冷眼，后来一旦得势，心肠会变得非常冷。电视剧《人民的名义》中那个公安厅长祁同伟就有点这个劲儿。</p>
<p>但是，对于“小时候穷，一辈子穷”这种讲法我并不是很认同，<strong>因为我周围很多人小时候都过的是穷日子、苦日子，长大后身上不仅没有上述毛病，倒是反而因为吃过苦，更有动力努力向上，也懂得珍惜所获得的每一分，每一点，甚至在发了财之后，懂得回报社会，对周围朋友也相当慷慨。</strong></p>
<p>相反，我也看到不少从小锦衣玉食养出来的孩子，除了追求更多的物质享受外，没有什么值得称颂的。如果一些人将来家道中落了，那个日子可以说是相当难过。很多人都奇怪以曹雪芹的才华为什么混得如此惨兮兮的，在历史上雍正皇帝对他们家其实不算太苛刻。</p>
<p>后来我遇到一位身世和曹雪芹类似的长辈文人，就很能体会曹雪芹为什么落得那样的结果了。解放前上海南京路上很多大楼都是他们家的，后来被查抄没收了，生活的落差可想而知，虽然这位长辈才华横溢，但是一辈子仕途平平，过得一般，用别人的话讲，他不谙世事。</p>
<p>想到他们，我就理解了为什么茨威格要自杀，读读他的<strong>《昨日的世界》</strong>就能理解他过去所拥有的自由美好的世界一旦失去，那是一种怎样的绝望。简单地讲，由俭入奢容易，反过来则千难万难。</p>
<p>因此，我的观点是，<strong>小时候穷固然有很多不足，但是和后来的发展关系不是那么大</strong>。如果能重新选择是先穷还是后穷，我想大部分中国人是选择前者，因为先穷毕竟还有希望。相比之下，今天很多欧美人是选择后者，先过两天好日子再说，哪管将来生活怎么样呢！</p>
<p>不过，很多人指出的穷人所带的很多毛病确实存在，那么小时候穷和将来的发展到底有没有关系呢？从统计的结果看，毫无疑问有关系，但是<strong>有时统计的结果并不构成因果关系</strong>。</p>
<p>这就如同在近代之前的德国人一致认为女性比男性更适合酿制啤酒一样，虽然在统计上完全正确，因为事实如此，但真实的原因却是在家里做面包的总是女性，因此她们身上携带酵母。是酵母决定了啤酒的味道好，而不是酿制者的性别。了解了这个因果关系后，男性同样能酿制出上好的啤酒。</p>
<p>类似地，如果我们能够找到穷所导致的影响一个人一生发展的根本原因，那么即便小时候穷，将来也未必没有机会。相反，即便小时候富有，也要杜绝很多坏毛病，否则会成为穷到只剩下钱的地步。</p>
<p><strong>后来我发现，活得诸事不顺的人都有三个共同的问题。</strong></p>
<p><strong><font color="red">首先是缺乏见识。</font></strong>没有见识，视野就被局限了。你可能有这样的体会，和某些人讲道理永远讲不通，这并非那些人故意要和你作对，而是他们实在没有见识，大家的认知水平根本不在一个台阶上。</p>
<p>《庄子》说，“夏天的虫子不可能谈论冰，是因为受到时间的限制（它们活不到冬天）。乡曲之人，无法和他论道，因为他们受制于不高的教育程度”，就是这个道理。关于见识，我在第167封来信《对话庄子（1）：谈谈见识》中已经提到了，就不再赘述了。这里只提醒一点，对于在见识上不长进的人，少和他们来往，更不要和他们争论，因为道理讲不通，徒费口舌。</p>
<p><strong><font color="red">其次是缺乏爱。</font></strong>我们常说<strong>某某太小家子气，成不了大事。小家子气，其实就是缺乏爱的表现。</strong></p>
<p>一些人讲，因为小时候穷，被人瞧不起，于是以后没有安全感，所以对钱特别贪恋。这个解释未必说得通，贪欲其实除了圣人，谁都或多或少有一点。穷人也有不贪的，富人也有极为贪婪的。很多人小时候因为家里穷，父母没有条件太关爱他们，而在学校和社会上又常常遭人冷眼，同样地缺乏关爱。</p>
<p>这就造成了他们<strong>不懂得关爱别人，不懂得分享的结果</strong>。对于一些人来讲，小时候其实家里不穷，但是没有培养孩子关爱他人的习惯，以至于他们长大以后非常小家子气，这在个别的独生子女身上特别明显。</p>
<p>一位自身条件很好的女生有一次讲了她的一个困惑。她交往了几个条件很好的男朋友都吹了，对方给她的评价就是不懂得如何爱别人，开始她以为是对方在分手时恶语相向，也没有在意，到第二次的时候听到同样的话时就有点害怕了，于是她试图去爱，但是做不好。</p>
<p>后来她想可能因为是独生女，从小就没有把好东西分享给大家的习惯，而周围人对她又都是有求必应。她所讲的事情已经过去好几年了，我之所以还记得这件事是因为它引起了我对独生子女问题的思考。</p>
<p>在我看来，<strong>独生子女带来的社会问题，并非将来没有了劳动力，而是很多人没有了原有社会的家庭生活和亲戚关系。</strong>第一代独生子女感受不到兄弟姐妹的关心，到了第二代连堂表兄妹的关系也消失了。这才是可怕之处。<strong>缺乏爱的人难以大气，不大气的人做不成大事。</strong></p>
<p>很多人以为有了钱就有了一切，如果钱只花在自己享受上，并没有发挥它的最大效能，相反，如果能花在别人身上，投入到社会再生产中去，将会获得更高的回报。</p>
<p><strong><font color="red">最后，比贫穷更可怕的是缺乏规矩。</font></strong></p>
<p>缺乏规矩会踩到别人的脚趾而不自知，其结果是，轻则没有人愿意帮他们，重则大家会和他们作对，而这个世界上没有人帮助是不行的。当然，这些人也会感觉到别人对他们不友善，或者敬而远之，但是常常还不知道原因，于是便对别人，对社会产生一种戾气。</p>
<p>前一阵有这样一则新闻，讲一个八十岁的老太太往飞机发动机里撒了一把钱，说是祈福，这不仅造成了不小的经济损失，而且耽误了大家很多时间。在中国没有民事诉讼索赔，在一些国家，航空公司不仅可以起诉她索赔巨款，耽误了时间的乘客也可以要求赔偿时间损失，这可不是一个小事情。</p>
<p>你说这位老人一定有多坏吗？也未必，有人说是没有常识，其实也不是没有常识，而是没有规矩。类似地，更早一些时间，东方航空公司的一个乘客手欠放下了应急滑梯，这也是没有规矩的典型表现。</p>
<p>我们经常会听到“熊孩子”这三个字，熊孩子的特点就是缺乏规矩。小时候缺乏规矩，长大以后就没有守规矩的习惯，那么将来的麻烦就很大。</p>
<p>缺乏<strong>见识</strong>、缺乏<strong>爱</strong>、缺乏<strong>规矩</strong>，是比缺钱更可怕的。没有钱，有一辈子的机会能够获得，而缺乏前面这三样东西，后天再获得的难度就非常大了，而它们的缺乏其实和穷没有必然联系。</p>
<p>很多人在说，现在社会分层了，我们的孩子没有了机会，其实机会总是有的。<strong>缺钱可能会在短期内物质条件差一点，但是并不影响父母在见识、爱和规矩上培养好孩子</strong>，有了意识，做到这些事并不难。反之，家里有钱，孩子也不会一定就有见识，有爱心，守规矩。</p>
<p>因此，对家长和我们自己来讲，小时候穷都不是将来不能成功的理由。</p>
<p><strong>祝好运！</strong></p>
<p>2017年8月23日于硅谷</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://peirsist.github.io/2022/10/29/%E7%BE%BD%E6%AF%9B%E7%90%83/00%E6%89%93%E7%BE%BD%E6%AF%9B%E7%90%83%E4%BC%A4%E7%97%85%E9%A2%84%E9%98%B2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Peirsist">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="EEWIKI">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | EEWIKI">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/10/29/%E7%BE%BD%E6%AF%9B%E7%90%83/00%E6%89%93%E7%BE%BD%E6%AF%9B%E7%90%83%E4%BC%A4%E7%97%85%E9%A2%84%E9%98%B2/" class="post-title-link" itemprop="url">打羽毛球伤病预防</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2022-10-29 18:42:48 / Modified: 21:31:29" itemprop="dateCreated datePublished" datetime="2022-10-29T18:42:48+08:00">2022-10-29</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%BE%BD%E6%AF%9B%E7%90%83/" itemprop="url" rel="index"><span itemprop="name">羽毛球</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="Word count in article">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">Word count in article: </span>
      <span>612</span>
    </span>
    <span class="post-meta-item" title="Reading time">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">Reading time &asymp;</span>
      <span>1 mins.</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p><font size="5"><strong><font color="red">羽毛球鞋比球拍更重要！！！</font></strong></font></p>
<h2 id="脚后跟疼">脚后跟疼</h2>
<p>最近打完球不能快跑和单脚跳，一跳左脚就疼。</p>
<p>很多羽毛球爱好者由于没有受过正式的训练，在预防运动损伤及自我保护意识方面比较薄弱。比如打球过后，有的人会出现脚后跟疼的情况，下面就让我们一起了解一下原因及处理方法。</p>
<ol type="1">
<li><strong>着地姿势错误</strong></li>
</ol>
<p>在羽毛球场地上,处于运动状态时,正确的姿势应该是<strong>前脚掌着地</strong>的,这样做的目的是便于<strong>迅速在场上移动,提高速度</strong>,只有在大跨步上步时才会出现脚后跟先着地,然后前脚掌再缓冲中着地.。</p>
<p>因此，脚后跟疼很有可能是你姿势不对，脚后跟或满脚掌着地，这样对脚后跟的负面刺激较大。</p>
<ol type="1">
<li><strong>鞋子不合格</strong></li>
</ol>
<p>羽毛球场的地板多为木板或塑胶地面，为了获得更好的抓地力，羽毛球鞋大多使用<strong>牛筋底</strong>，这<strong>与常见跑鞋的防滑设计不一样</strong>，因为后者更多是针对水泥地面进行防滑设计，而且侧向的抓地力不如羽毛球鞋。<strong>鞋子和脚的舒适度有直接的关系</strong>，如果穿的鞋子不适合打羽毛球或是鞋子不够舒适的话，脚后跟自然容易疼，因此，在打球时尽量穿着柔软一点的羽毛球鞋。</p>
<h2 id="解决">解决</h2>
<ol type="1">
<li><strong>学习正规的羽毛球步法</strong></li>
</ol>
<p>打球的时候，起跳后落地时正确的姿势应该是<strong>前脚掌着地</strong>，<strong>切忌满脚掌着和脚后跟先着地</strong>,因为这样不仅容易脚后跟疼，还会让启动速度变慢,影响你的步伐效率。</p>
<ol start="2" type="1">
<li><strong>缩短运动时间，减少运动量</strong></li>
</ol>
<p>脚后跟疼时，首先<strong>停止打球一段时间</strong>，等脚部不适消除后，再次运动，每次运动时间缩短，并<strong>保证足够的休息间隔</strong>。<strong>羽毛球经常会快速起动，快速停步，所以脚跟受力还是很大的</strong>，有时候快速停位的时候，脚跟就受力更多。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://peirsist.github.io/2022/10/27/%E9%9A%8F%E7%AC%94%E4%B8%8E%E4%B8%AA%E4%BA%BA%E6%96%87%E9%9B%86/markdown%E8%A1%A8%E6%83%85/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Peirsist">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="EEWIKI">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | EEWIKI">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/10/27/%E9%9A%8F%E7%AC%94%E4%B8%8E%E4%B8%AA%E4%BA%BA%E6%96%87%E9%9B%86/markdown%E8%A1%A8%E6%83%85/" class="post-title-link" itemprop="url">Markdown表情</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2022-10-27 09:06:48 / Modified: 22:26:57" itemprop="dateCreated datePublished" datetime="2022-10-27T09:06:48+08:00">2022-10-27</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E9%9A%8F%E7%AC%94%E4%B8%8E%E4%B8%AA%E4%BA%BA%E6%96%87%E9%9B%86/" itemprop="url" rel="index"><span itemprop="name">随笔与个人文集</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="Word count in article">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">Word count in article: </span>
      <span>112</span>
    </span>
    <span class="post-meta-item" title="Reading time">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">Reading time &asymp;</span>
      <span>1 mins.</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <ol type="1">
<li><a target="_blank" rel="noopener" href="https://www.emojiall.com/zh-hans/categories/I">分类:🛑符号相关的Emoji大全 | EmojiAll</a></li>
<li><a target="_blank" rel="noopener" href="https://apps.timwhitlock.info/emoji/tables/unicode#">Emoji unicode characters for use on the web (timwhitlock.info)</a></li>
<li><a target="_blank" rel="noopener" href="https://www.unicode.org/emoji/charts/full-emoji-list.html">Full Emoji List, v15.0 (unicode.org)</a></li>
<li></li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://peirsist.github.io/2022/10/25/%E7%BE%BD%E6%AF%9B%E7%90%83/01-2%E6%AD%A5%E4%BC%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Peirsist">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="EEWIKI">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | EEWIKI">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/10/25/%E7%BE%BD%E6%AF%9B%E7%90%83/01-2%E6%AD%A5%E4%BC%90/" class="post-title-link" itemprop="url">步伐</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2022-10-25 09:42:48" itemprop="dateCreated datePublished" datetime="2022-10-25T09:42:48+08:00">2022-10-25</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2022-10-28 20:46:42" itemprop="dateModified" datetime="2022-10-28T20:46:42+08:00">2022-10-28</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%BE%BD%E6%AF%9B%E7%90%83/" itemprop="url" rel="index"><span itemprop="name">羽毛球</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="Word count in article">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">Word count in article: </span>
      <span>43</span>
    </span>
    <span class="post-meta-item" title="Reading time">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">Reading time &asymp;</span>
      <span>1 mins.</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="交叉步和并步">交叉步和并步</h2>
<p>并步，快速步伐，小步伐，球速比较快可以用</p>
<p>交叉步，大步步伐，适合球速慢的时候</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://peirsist.github.io/2022/10/25/%E7%BE%BD%E6%AF%9B%E7%90%83/01-1%E5%90%8E%E5%9C%BA%E9%AB%98%E8%BF%9C%E7%90%83/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Peirsist">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="EEWIKI">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | EEWIKI">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/10/25/%E7%BE%BD%E6%AF%9B%E7%90%83/01-1%E5%90%8E%E5%9C%BA%E9%AB%98%E8%BF%9C%E7%90%83/" class="post-title-link" itemprop="url">后场高远球</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2022-10-25 09:06:48" itemprop="dateCreated datePublished" datetime="2022-10-25T09:06:48+08:00">2022-10-25</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2022-10-28 20:46:45" itemprop="dateModified" datetime="2022-10-28T20:46:45+08:00">2022-10-28</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%BE%BD%E6%AF%9B%E7%90%83/" itemprop="url" rel="index"><span itemprop="name">羽毛球</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="Word count in article">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">Word count in article: </span>
      <span>303</span>
    </span>
    <span class="post-meta-item" title="Reading time">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">Reading time &asymp;</span>
      <span>1 mins.</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <ol type="1">
<li>侧身，架拍，展肩（下意识训练出来）</li>
<li>抬左手，抬左腿，重心放到右腿</li>
<li>左腿往下拉，再甩拍</li>
<li>上半身一定要往后拉，架拍为了展肩</li>
<li>腿越直，越没法发力，转不了身，用不上腰</li>
</ol>
<p>🔴 <strong>错误：</strong></p>
<blockquote>
<p>同步发力，右腿跳，甩右手</p>
</blockquote>
<p>🔵 <strong>链接：</strong></p>
<ol type="1">
<li><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV13C4y1t7Sn/?spm_id_from=333.999.0.0&amp;vd_source=83831fc0970a6c8704479f7cfc679937">羽毛球高远球教学之-五分钟教会你羽毛球高远球到底该怎么打！高远球打不到后场？看了视频后这个问题将不再存在！_哔哩哔哩_bilibili</a></li>
<li><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1hZ4y1M7wB/?spm_id_from=333.999.0.0&amp;vd_source=83831fc0970a6c8704479f7cfc679937">羽毛球高远球教学之-教你如何转身挥拍！ 什么？！上一个视频你已经看完了？那来学学怎么转身打高远球吧！（没看上一个视频的一定要回去先看高远球教学视频噢）_哔哩哔哩_bilibili</a></li>
<li><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1Z64y1F7Ys/?spm_id_from=333.999.0.0&amp;vd_source=83831fc0970a6c8704479f7cfc679937">高远球打不到位？转身挥拍老发不上力？来看看你是不是跟他们一样有同样的问题。_哔哩哔哩_bilibili</a></li>
<li></li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://peirsist.github.io/2022/10/24/%E9%9A%8F%E7%AC%94%E4%B8%8E%E4%B8%AA%E4%BA%BA%E6%96%87%E9%9B%86/00%E8%BF%90%E5%8A%A8%E5%BD%A2%E5%BC%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Peirsist">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="EEWIKI">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | EEWIKI">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/10/24/%E9%9A%8F%E7%AC%94%E4%B8%8E%E4%B8%AA%E4%BA%BA%E6%96%87%E9%9B%86/00%E8%BF%90%E5%8A%A8%E5%BD%A2%E5%BC%8F/" class="post-title-link" itemprop="url">每天锻炼</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2022-10-24 16:57:41" itemprop="dateCreated datePublished" datetime="2022-10-24T16:57:41+08:00">2022-10-24</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2022-11-13 23:40:41" itemprop="dateModified" datetime="2022-11-13T23:40:41+08:00">2022-11-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E9%9A%8F%E7%AC%94%E4%B8%8E%E4%B8%AA%E4%BA%BA%E6%96%87%E9%9B%86/" itemprop="url" rel="index"><span itemprop="name">随笔与个人文集</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="Word count in article">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">Word count in article: </span>
      <span>360</span>
    </span>
    <span class="post-meta-item" title="Reading time">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">Reading time &asymp;</span>
      <span>1 mins.</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="section"></h1>
<h2 id="运动形式">运动形式</h2>
<h3 id="跑步">跑步</h3>
<h3 id="跳绳">跳绳</h3>
<h3 id="体能类">体能类</h3>
<ol type="1">
<li>背部和肩部肌肉
<ul>
<li><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1CL411x7gV/?spm_id_from=333.788.recommend_more_video.0&amp;vd_source=83831fc0970a6c8704479f7cfc679937">练出更宽的肩膀和背部，不再瘦弱（一对哑铃在家练）_哔哩哔哩_bilibili</a></li>
<li></li>
</ul></li>
<li>胸部肌肉
<ul>
<li><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1rY411H7V2/?spm_id_from=333.788.recommend_more_video.5&amp;vd_source=83831fc0970a6c8704479f7cfc679937">练出有型胸肌，不再单薄（一对哑铃在家练）_哔哩哔哩_bilibili</a></li>
</ul></li>
<li>手臂/腿部肌肉
<ol type="1">
<li>（负重）深蹲</li>
</ol></li>
<li>手臂肌肉
<ul>
<li>直立哑铃交替</li>
</ul></li>
</ol>
<p>🔵 <strong>链接：</strong></p>
<ol type="1">
<li><a target="_blank" rel="noopener" href="https://www.jirou.com/html/yalingdaquan.html">哑铃健身图解大全（适合在家锻炼</a></li>
<li></li>
</ol>
<h2 id="运动频率">运动频率</h2>
<p><img src="https://cdn.staticaly.com/gh/peirsist/blog_img@master/Snipaste_2022-10-24_17-35-40.66yls7r574w0.webp" style="zoom:150%;"></p>
<p>markdown流程图代码 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">graph TB</span><br><span class="line">    Start(新的一天) --&gt; badminton&#123;&quot;打羽毛球？&quot;&#125;</span><br><span class="line">    </span><br><span class="line">    badminton --&gt;|是| dumbbell[&quot;力量训练&quot;]</span><br><span class="line">     </span><br><span class="line">    badminton --&gt;|否| running[&quot;耐力、爆发力训练&quot;]</span><br><span class="line">    running --&gt; dumbbell</span><br><span class="line">    </span><br><span class="line">    dumbbell --&gt; End(洗洗睡觉)</span><br></pre></td></tr></table></figure></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://peirsist.github.io/2022/10/24/%E9%9A%8F%E7%AC%94%E4%B8%8E%E4%B8%AA%E4%BA%BA%E6%96%87%E9%9B%86/1-0%E6%97%85%E6%B8%B8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Peirsist">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="EEWIKI">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | EEWIKI">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/10/24/%E9%9A%8F%E7%AC%94%E4%B8%8E%E4%B8%AA%E4%BA%BA%E6%96%87%E9%9B%86/1-0%E6%97%85%E6%B8%B8/" class="post-title-link" itemprop="url">旅游</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2022-10-24 16:57:41" itemprop="dateCreated datePublished" datetime="2022-10-24T16:57:41+08:00">2022-10-24</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2022-12-09 20:01:03" itemprop="dateModified" datetime="2022-12-09T20:01:03+08:00">2022-12-09</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E9%9A%8F%E7%AC%94%E4%B8%8E%E4%B8%AA%E4%BA%BA%E6%96%87%E9%9B%86/" itemprop="url" rel="index"><span itemprop="name">随笔与个人文集</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="Word count in article">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">Word count in article: </span>
      <span>59</span>
    </span>
    <span class="post-meta-item" title="Reading time">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">Reading time &asymp;</span>
      <span>1 mins.</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <figure>
<img src="https://cdn.staticaly.com/gh/peirsist/blog_img@master/Snipaste_2022-11-13_12-07-58.437qqwwtyeq0.png" alt="Snipaste_2022-11-13_12-07-58"><figcaption aria-hidden="true">Snipaste_2022-11-13_12-07-58</figcaption>
</figure>
<figure>
<img src="https://cdn.staticaly.com/gh/peirsist/blog_img@master/2f4ae2ea6d6241b34afc38a748ed2e9.32mzf41xs060.jpg" alt="2f4ae2ea6d6241b34afc38a748ed2e9"><figcaption aria-hidden="true">2f4ae2ea6d6241b34afc38a748ed2e9</figcaption>
</figure>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://peirsist.github.io/2022/10/24/%E9%9A%8F%E7%AC%94%E4%B8%8E%E4%B8%AA%E4%BA%BA%E6%96%87%E9%9B%86/00%E5%81%A5%E5%BA%B7%E4%BD%9C%E6%81%AF/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Peirsist">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="EEWIKI">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | EEWIKI">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/10/24/%E9%9A%8F%E7%AC%94%E4%B8%8E%E4%B8%AA%E4%BA%BA%E6%96%87%E9%9B%86/00%E5%81%A5%E5%BA%B7%E4%BD%9C%E6%81%AF/" class="post-title-link" itemprop="url">健康作息</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2022-10-24 16:55:41" itemprop="dateCreated datePublished" datetime="2022-10-24T16:55:41+08:00">2022-10-24</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2022-12-09 19:59:15" itemprop="dateModified" datetime="2022-12-09T19:59:15+08:00">2022-12-09</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E9%9A%8F%E7%AC%94%E4%B8%8E%E4%B8%AA%E4%BA%BA%E6%96%87%E9%9B%86/" itemprop="url" rel="index"><span itemprop="name">随笔与个人文集</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="Word count in article">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">Word count in article: </span>
      <span>1.7k</span>
    </span>
    <span class="post-meta-item" title="Reading time">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">Reading time &asymp;</span>
      <span>2 mins.</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="饮食">饮食</h1>
<ol type="1">
<li>少油少甜</li>
<li>不吃辣</li>
<li>晚上8点后不吃东西</li>
</ol>
<blockquote>
<p><strong><font color="red">饮食是一个大问题，三分练七分吃。乱吃东西</font></strong></p>
</blockquote>
<figure>
<img src="https://cdn.staticaly.com/gh/peirsist/blog_img@master/3c8473cf76b6e625849c5a46edf59ef.785bkzbpd640.jpg" alt="早餐"><figcaption aria-hidden="true">早餐</figcaption>
</figure>
<ol type="1">
<li><strong>高糖高脂食物</strong></li>
</ol>
<ul>
<li><strong>高糖食物</strong>：以糖果、蛋糕、奶油等食物为代表，一些过甜的干果，如蜜饯、桂圆干等也需要控制摄入量，我们总以为两广当地年轻人好长痤疮是因为气候炎热，但也可能是因为当地夏日漫长，大家喜欢吃冰镇糖水解暑；</li>
<li><strong>高脂食物</strong>：不仅仅是五花肉，核桃、芝麻、花生、<strong>油炸食品</strong> 。<strong>油条、炸花生等素食的油脂含量也十分可观；</strong></li>
<li><strong>其他</strong>：一些不起眼的西点，比如曲奇、黄油吐司等，如果你亲自做过，就会很直观地体会到里面的热量有多高，简直再也不想吃</li>
</ul>
<p>2. <strong>远离辛辣食物</strong>：麻辣烫、火锅、辣椒、桂皮、胡椒等。 <strong>因为辛辣温热，引起暗疮复发增长。</strong></p>
<p>3. <strong>远离油腻食物</strong>：<strong>油条、炸鸡、薯条、鸡排、肥肉</strong> 等。</p>
<ol start="4" type="1">
<li><strong>远离上火水果</strong>：荔枝、芒果、龙眼、大枣、榴莲等。</li>
</ol>
<p><strong>这些水果温热容易上火长痘最好不要吃。</strong></p>
<ul>
<li>皮脂溢出者要<strong>适当增加清水洗脸的次数</strong>，但建议每天不超过 3 次，并且不要大力揉搓；</li>
<li>洗完后及时做好<strong>保湿</strong>工作；</li>
<li>少化浓妆，选择<strong>质地清透稀薄的护肤品</strong>；</li>
<li>注意<strong>防晒</strong>，<strong>规律作息</strong>；</li>
<li>最重要的一点：<strong>不要用手挤压、挠抓痘痘</strong>！</li>
</ul>
<p>痤疮是一个慢性皮肤病，生活护理也非一日之功，需要养成习惯，才能长时间保持皮肤的光滑平整</p>
<hr>
<h2 id="建议少吃或不吃的高热量食物">建议少吃或不吃的高热量食物</h2>
<p>需要少吃或不吃的高热量食物，就是大家都知道的大部分「垃圾食品」。包括但不限于以下几种</p>
<p><strong>零食类</strong>：薯片、饼干、含糖饮料、雪饼<a target="_blank" rel="noopener" href="https://www.zhihu.com/search?q=仙贝&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A690519035%7D">仙贝</a>等膨化食品、各种糖果、奶茶、辣条，<a target="_blank" rel="noopener" href="https://www.zhihu.com/search?q=果脯蜜饯&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A690519035%7D">果脯蜜饯</a>、蔬果脆、肉干、蛋糕、冰淇淋等等。</p>
<p>是的你没看错，几乎所有的零食都是不建议食用的高热量食品！可能有人会觉得奇怪了，为什么蔬果脆、果脯和肉干也不能吃？它们看起来都很健康营养，其实市面上的蔬果脆都添加了大量的低质量油，要知道，所有口感酥脆的食物一般都是通过油炸得到的。果脯和肉干也都添加了大量的糖，热量不高是不可能的鸭！</p>
<p><strong>菜品类：</strong></p>
<ul>
<li><strong>所有油炸食物</strong>。一方面，<a target="_blank" rel="noopener" href="https://www.zhihu.com/search?q=油炸食品&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A690519035%7D">油炸食品</a>都会残留有大量的油，光这一点就足以让你放弃吃它了；另一方面，经过高温油炸后，食物中的营养素大量流失，很大几率就变成了妈妈口中的「垃圾食品」。</li>
<li><strong>红烧肉</strong>。虽然我承认，红烧肉真的好吃死了，但是它的热量也是真的高死了！大概4-5小块红烧肉的热量就能赶上你跑步5千米，啊这该死的～无处安放的～卡路里啊！</li>
<li><strong>腊肠腊肉</strong>。腊肠腊肉在制作中为了能拥有不了更好的风味，都会保留或添加肥肉，且腊制后的肉品因为水分的流失，热量密度变得更大，自然热量就随之升高。且往往都含有较多对血压危害不小的盐，一定要少吃或不吃。</li>
<li><strong>肥肉</strong>。一口肥肉=一勺油</li>
<li><strong>榴莲</strong>。做为高碳水、高脂肪、高热量的三高食物，热量比米饭还高。一瓣榴莲的热量等于慢走3小时、骑车40分钟，这惊人的卡路里，你怕了吗？</li>
</ul>
<h2 id="那些你意想不到的高热量食物">那些你意想不到的高热量食物</h2>
<p>这类食物是隐形的炸弹，披着健康的外衣招摇撞骗，诱惑你吃进肚子里然后悄悄变成你身体上的肥肉。现在我就来一一揭穿它们</p>
<ul>
<li><strong>酸奶</strong>。因为无添加的<a target="_blank" rel="noopener" href="https://www.zhihu.com/search?q=原味酸奶&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A690519035%7D">原味酸奶</a>酸奶跟它的名字一样，真的非常酸，商家为了迎合大众口味，会在里面添加大量的糖，糖分过多不仅会破坏酸奶里的益生菌，热量还非常高。在购买酸奶时一定要注意，白砂糖排在前三位的直接pass。顺便推荐给你我最近一直在喝的这款酸奶——如实。它的配料只有2种类，<a target="_blank" rel="noopener" href="https://www.zhihu.com/search?q=生牛乳&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A690519035%7D">生牛乳</a>和菌种。以后大家购买酸奶也一定要先看成分表，最好选择这种配料只有牛乳和菌类的酸奶哦！</li>
</ul>
<figure>
<img src="https://pic1.zhimg.com/80/v2-8acc5b08564653dab42b742ca96b802c_1440w.webp?source=1940ef5c" alt="img"><figcaption aria-hidden="true">img</figcaption>
</figure>
<ul>
<li><strong>各类肉汤</strong>。很多人有煲汤不吃肉的习惯，汤炖好之后就把里面的肉扔掉只喝汤，但其实肉中的营养元素是远多于汤的，而汤中往往隐藏这大量的脂肪，所以，以后炖汤还是要吃肉哦（不过当然还是只能吃瘦肉部分啦）。</li>
<li><strong>餐厅饭馆里的绿叶菜</strong>。虽然蔬菜热量真的很低，但是同时它们也很能吸油，餐厅一般做菜放油量都会比较多，菜就变成了油量炸弹。</li>
<li><strong><a target="_blank" rel="noopener" href="https://www.zhihu.com/search?q=芝麻酱&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A690519035%7D">芝麻酱</a>、蛋黄酱等各类浅色的酱</strong>。很多人在减脂期喜欢吃沙拉，为了让沙拉的味道变得更加美妙，就会在里面添加大量的芝麻酱、<a target="_blank" rel="noopener" href="https://www.zhihu.com/search?q=沙拉酱&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A690519035%7D">沙拉酱</a>等，殊不知，这样一顿沙拉不仅不能让你瘦，反而有可能热量还高于一顿普通的正餐，会让你胖的</li>
</ul>
<h1 id="工作">工作</h1>
<ol type="1">
<li>避免长时间（1小时）看电脑，每1小时，户外5分钟</li>
<li>坐姿端正，避免脖子前倾和弯腰驼背</li>
<li>避免低头、久坐</li>
</ol>
<h1 id="运动">运动</h1>
<ol type="1">
<li>每天<strong>户外运动</strong>大于1小时</li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://peirsist.github.io/2022/10/24/%E9%9A%8F%E7%AC%94%E4%B8%8E%E4%B8%AA%E4%BA%BA%E6%96%87%E9%9B%86/%E5%A6%82%E4%BD%95%E9%AB%98%E6%95%88%E4%BC%91%E6%81%AF/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Peirsist">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="EEWIKI">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | EEWIKI">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/10/24/%E9%9A%8F%E7%AC%94%E4%B8%8E%E4%B8%AA%E4%BA%BA%E6%96%87%E9%9B%86/%E5%A6%82%E4%BD%95%E9%AB%98%E6%95%88%E4%BC%91%E6%81%AF/" class="post-title-link" itemprop="url">科学休息法</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2022-10-24 12:55:41" itemprop="dateCreated datePublished" datetime="2022-10-24T12:55:41+08:00">2022-10-24</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2023-01-05 16:08:50" itemprop="dateModified" datetime="2023-01-05T16:08:50+08:00">2023-01-05</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E9%9A%8F%E7%AC%94%E4%B8%8E%E4%B8%AA%E4%BA%BA%E6%96%87%E9%9B%86/" itemprop="url" rel="index"><span itemprop="name">随笔与个人文集</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="Word count in article">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">Word count in article: </span>
      <span>1.4k</span>
    </span>
    <span class="post-meta-item" title="Reading time">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">Reading time &asymp;</span>
      <span>1 mins.</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="section"></h1>
<h1 id="如何高效休息">如何高效休息</h1>
<p>（转载）</p>
<p>今天不谈工作谈休息。当然休息是为了更好地工作，所以谈休息也是谈工作。</p>
<p>什么样的休息，才能最大限度地让人精神饱满地投入到接下来的工作？</p>
<p>流行的休息法大概有两派，就好像气宗和剑宗。老一辈的人认为应该劳逸结合，每工作一段时间就休息一下，搞个什么工间操之类，就好像学生按节上课一样。年轻人强调拼劲，认为最好猛干一天，然后下班拼命放松。具体的休息内容，老一辈建议出门走两圈，或者跟（真）人聊聊天。年轻人则宁可躺在床上读个什么手机段子。</p>
<p><strong>现在我们有强有力的科学证据，老一辈的做法是对的。</strong></p>
<p>今天要说的是99U上的一篇文章，<em>“<strong>A Science-Backed Guide to Taking Truly Restful Breaks</strong>”</em>（良好休息的科学指南），作者 Christian Jarrett。</p>
<p>文章标题有点像微信朋友圈转发的那种生活小常识，但这篇文章其实是一个最新研究的综述。</p>
<p>科学家对休息效果的定义是，你在办公室工作一天，中间使用了什么休息方法，到下午下班前的精神状态和工作效率仍能保持高水平。</p>
<p>我们先来猜一下，在以下这几种休息活动中，哪个效率最高？</p>
<ol type="1">
<li><p><mark>放松：什么都不干，做做白日梦，或者做几个伸展运动</mark></p></li>
<li><p>给身体补充点什么东西：喝杯咖啡之类</p></li>
<li><p><mark>社交：跟同事聊聊天</mark></p></li>
<li><p>认知：读读新闻，查看邮件</p></li>
</ol>
<p>第4项，是我们大多数人最喜欢的休息方法。而且此前就有研究表明，<strong>一个人越累越困，反而越想上网看点什么东西。这个现象非常有意思，这就是为什么我们越晚睡的时候就越会……更晚睡。</strong></p>
<p>但研究结果非常明确——<strong>上网不但不能休息，反而会让我们变得更累。</strong></p>
<p>这是因为<strong>脑力劳动者最需要花费</strong>，也是最需要<strong>从休息中恢复</strong>的两个资源，是“<strong>意志力</strong>”和“<strong>注意力</strong>”。现在很多心理学实验都认为这是<strong>两个有限的资源，最好用在刀刃上</strong>。</p>
<p>所以休息的目的就是让注意力和意志力回血。但是上网——<strong>阅读会消耗注意力</strong>；决定是否点击，是否购买之类的<strong>各种决策会消耗意志力</strong>。</p>
<p>研究结果，真正有用的休息是1、3这两项。喝咖啡也没用。</p>
<p>所以科学家的<strong><font color="red">第一个建议</font></strong>是要休息，先断网。</p>
<p><strong><font color="red">第二个建议</font></strong>是短而频繁的休息比长时间工作然后长时间休息更好。</p>
<p>这个原理是人体不是汽车，你把油快用完了统一加一次就行，而是必须随时用随时补充。大概每隔半小时或者一小时就休息几分钟，效果良好。另外这种短休息流程要从上午就开始做，不要等到下午很累了再做。</p>
<p><strong><font color="red">第三个建议</font></strong>是最好休息的时候离开办公室。</p>
<p>有的公司喜欢让所有同事留在公司午休，吃个午饭也要在一起，其实并不利于休息。多伦多大学的研究者，最近研究观察了一百多位在大学工作的人，看他们午饭怎么吃。结果是如果你午饭跟同事一起吃，不论聊的是不是工作，休息效果都不好——快下班的时候别人评价你看上去很疲惫。如果这顿午饭还是老板要求全体一起吃的，更累。</p>
<p>所以从休息角度，找同事聊天最好用上班时间，午饭还是自由点好。</p>
<p>研究表明，哪怕出去散步五分钟，效果都要好得多。</p>
<h2 id="评论">| 评论</h2>
<p>我看这些研究中价值最大的还是有关上网的一项。对高强度脑力劳动者来说，“上网休息一下”，拿手机找两个猫的可爱图片看看，简直是再正常不过的事情了。可是现在我们知道<strong>凡是调动了注意力和意志力的行为就是消耗而不是休息。</strong></p>
<p>说白了，就是我们常常把“娱乐”和“休息”给混为一谈。</p>
<h2 id="由此得到">| 由此得到</h2>
<p>娱乐不是休息。</p>
<h2 id="总结">| 总结</h2>
<blockquote>
<p>科学家关于休息的几点建议：</p>
<ol type="1">
<li><p>要休息，先断网。</p></li>
<li><p>短而频繁的休息比长时间工作然后长时间休息更好。</p></li>
<li><p>最好休息的时候离开办公室。</p></li>
</ol>
</blockquote>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" title="Previous page" aria-label="Previous page" href="/page/3/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/page/5/">5</a><span class="space">&hellip;</span><a class="page-number" href="/page/7/">7</a><a class="extend next" rel="next" title="Next page" aria-label="Next page" href="/page/5/"><i class="fa fa-angle-right"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Peirsist</span>
</div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
    <span title="Word count total">187k</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="Reading time total">2:50</span>
  </span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/pisces/" rel="noopener" target="_blank">NexT.Pisces</a>
  </div>

    </div>
  </footer>

  
  <div class="back-to-top" role="button" aria-label="Back to top">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>





  




  

  <script class="next-config" data-name="enableMath" type="application/json">true</script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.4/katex.min.css" integrity="sha256-gMRN4/6qeELzO1wbFa8qQLU8kfuF2dnAPiUoI0ATjx8=" crossorigin="anonymous">



</body>
</html>
