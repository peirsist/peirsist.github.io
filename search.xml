<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>test.md</title>
    <url>/2022/10/20/test-md/</url>
    <content><![CDATA[<h2 id="测试latex">测试latex</h2>
]]></content>
      <tags>
        <tag>test</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2022/10/20/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="quick-start">Quick Start</h2>
<h3 id="create-a-new-post">Create a new post</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="run-server">Run server</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="generate-static-files">Generate static files</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="deploy-to-remote-sites">Deploy to remote sites</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>学习链接</title>
    <url>/2022/10/19/tolearn/</url>
    <content><![CDATA[<h1 id="专业类">1 <strong>专业类</strong></h1>
<h2 id="数学基础">1.1 <strong>数学基础</strong></h2>
<ol type="1">
<li>老齐课程，<a href="http://www.itdiffer.com/">首页 · 老齐教室 (itdiffer.com)</a>
<ul>
<li><strong><a href="http://math.itdiffer.com/">本书说明 · 机器学习数学基础 (itdiffer.com)</a></strong></li>
<li><strong><a href="https://www.bilibili.com/video/BV1QG411t72j/?spm_id_from=333.788&amp;vd_source=83831fc0970a6c8704479f7cfc679937">如何度量距离_哔哩哔哩_bilibili</a></strong></li>
</ul></li>
<li><a href="https://www.bilibili.com/video/BV1pb411u7t1?spm_id_from=333.999.0.0">线性代数基础课程【小元老师】【超级0基础入门】</a></li>
<li><a href="https://www.bilibili.com/video/BV1ib411t7YR?spm_id_from=333.999.0.0">线性代数的本质</a></li>
<li><a href="https://www.bilibili.com/video/BV14b411M7Jn?spm_id_from=333.999.0.0">概率论与数理统计知识详解【小元老师】【考研数学】</a></li>
<li><a href="https://www.bilibili.com/video/BV1ys411472E?spm_id_from=333.999.0.0">【官方双语/合集】线性代数的本质 - 系列合集</a></li>
<li><a href="https://cloud.tencent.com/developer/article/1729545">非常适合初学者的机器学习的数学基础专辑（pdf下载）</a></li>
<li><a href="https://cloud.tencent.com/developer/article/1843235?from=article.detail.1729545">建议初学者收藏的机器学习初学者手抄本：数学基础、机器学习经典算法、统计学习方法等</a></li>
<li>机器学习数学基础pdf
<ul>
<li><a href="https://zhuanlan.zhihu.com/p/104986706">《机器学习数学基础》已开源，附完整下载！ - 知乎 (zhihu.com)</a></li>
<li><a href="https://mml-book.github.io/">Mathematics for Machine Learning | Companion webpage to the book “Mathematics for Machine Learning”.</a></li>
</ul></li>
</ol>
<h2 id="数据结构与算法">1.2 数据结构与算法</h2>
<h2 id="c">1.3 C++</h2>
<ol type="1">
<li>把C++基础过一遍，黑马程序员</li>
<li><a href="https://www.bilibili.com/video/BV1W4411T7wL/?spm_id_from=333.999.0.0&amp;vd_source=83831fc0970a6c8704479f7cfc679937">C++进阶之STL</a></li>
</ol>
<h2 id="计算机网络">1.4 计算机网络</h2>
<h2 id="机器学习">1.5 <strong>机器学习</strong></h2>
<!-- 1. **🔗[线性回归](机器学习/00Tra_ML/02.线性回归.md)** -->
<ol type="1">
<li>🔗<a href="/2022/07/21/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/00Tra_ML/02.%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92/" title="线性回归">线性回归</a></li>
</ol>
<ul>
<li><a href="https://blog.csdn.net/gongxifacai_believe/category_6834186.html">Machine Learning_魏晓蕾的博客-CSDN博客</a><mark>前辈们做的机器学习笔记</mark></li>
<li><a href="https://www.bilibili.com/video/BV1jS4y1j74C?spm_id_from=333.999.0.0">机器学习之路【b站UP主】</a></li>
</ul>
<ol type="1">
<li><a href="https://www.bilibili.com/video/BV1Cx411i7op?spm_id_from=333.999.0.0">林轩田机器学习基石(国语)</a></li>
<li><strong><a href="https://www.bilibili.com/video/BV1aE411o7qd?spm_id_from=333.337.search-card.all.click">【白板推导系列】【合集 1～33】</a></strong></li>
<li><a href="https://www.bilibili.com/video/BV1eT4y1E73x?spm_id_from=333.999.0.0">【手推机器学习】矩阵求导7--最小二乘法举例</a></li>
<li><a href="https://www.bilibili.com/video/BV1ZM4y1w75P?spm_id_from=333.999.0.0">【神经网络】BP误差逆传播算法数学推导</a></li>
<li><a href="https://www.bilibili.com/video/BV13J41157Wq?spm_id_from=333.999.0.0">5字诀搞定BP反向传播算法推导</a></li>
<li><a href="https://github.com/dragen1860/Deep-Learning-with-TensorFlow-book">dragen1860/Deep-Learning-with-TensorFlow-book: 深度学习入门开源书，基于TensorFlow 2.0案例实战。</a></li>
<li><a href="https://christophm.github.io/interpretable-ml-book/preface-by-the-author.html">【英文】机器学习可解释性| Interpretable Machine Learning (christophm.github.io)</a></li>
<li></li>
</ol>
<h2 id="深度学习">1.6 <strong>深度学习</strong></h2>
<ol type="1">
<li><strong><a href="https://www.bilibili.com/video/BV1if4y147hS?spm_id_from=333.999.0.0">动手学深度学习【李沐大神】</a></strong> <!-- 2. **🔗[CNN](机器学习/05DL/CNN.md)** --></li>
<li><a href="/2022/10/16/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/05DL/CNN/" title="CNN">🔗CNN</a></li>
<li><a href="https://github.com/open-mmlab/OpenMMLabCourse/blob/main/lecture_sjtu.md">OpenMMLabCourse/lecture_sjtu.md at main · open-mmlab/OpenMMLabCourse (github.com)</a></li>
<li></li>
</ol>
<h2 id="强化学习">1.7 <strong>强化学习</strong></h2>
<p><strong>西湖大学赵世钰老师</strong>，<strong><font color="red">强烈推荐！！！</font></strong></p>
<p>欢迎大家来到西湖大学赵世钰老师的【强化学习的数学原理】课程。这门课程从零开始、从数学角度、结合大量例子、循序渐进地揭示强化学习的本质原理。如果你学习的时候<strong>喜欢刨根问底“知其然并知其所以然”</strong>，相信这个课程能很好地帮助你透彻理解强化学习！</p>
<ol type="1">
<li><a href="https://www.bilibili.com/video/BV1sd4y167NS/?p=2&amp;spm_id_from=333.880.my_history.page.click&amp;vd_source=83831fc0970a6c8704479f7cfc679937">【强化学习的数学原理】从零开始透彻理解强化学习）_哔哩哔哩_bilibili</a></li>
<li><a href="https://github.com/MathFoundationRL/Book-Mathmatical-Foundation-of-Reinforcement-Learning">课程对应书籍和PPT-MathFoundationRL</a></li>
<li><a href="https://www.zhihu.com/people/kong-zhong-ji-qi-ren-qian-yan">空中机器人前沿 - 知乎 (zhihu.com)</a></li>
</ol>
<hr>
<ol type="1">
<li><strong>🔗<a href="机器学习/03RL/02RL介绍.md">第1节什么是强化学习?-北邮-鲁鹏老师</a></strong></li>
<li><a href="https://blog.csdn.net/SMALL_RL/article/details/123380320">强化学习 (Reinforcement Learning) 基础及论文资料汇总</a></li>
<li><a href="https://www.bilibili.com/video/BV13W411Y75P?spm_id_from=333.999.0.0">【莫烦Python】强化学习 Reinforcement Learning</a></li>
<li><a href="https://www.bilibili.com/video/BV16Y4y1M7DX?spm_id_from=333.999.0.0">强化学习基础 （本科生课程） 北京邮电大学 鲁鹏</a></li>
<li><a href="https://www.bilibili.com/video/BV1XP4y1d7Bk?spm_id_from=333.999.0.0">李宏毅</a></li>
<li><a href="https://www.bilibili.com/video/BV1rv41167yx/?spm_id_from=333.1007.top_right_bar_window_history.content.click&amp;vd_source=83831fc0970a6c8704479f7cfc679937">深度强化学习（全）_哔哩哔哩_bilibili</a></li>
<li><a href="https://www.bilibili.com/video/BV1CB4y1G777/?spm_id_from=333.1007.top_right_bar_window_history.content.click&amp;vd_source=83831fc0970a6c8704479f7cfc679937">【RLChina 2022】前沿进展五：应用多智能体强化学习解决现实问题——机遇和挑战 方飞_哔哩哔哩_bilibili</a></li>
<li><a href="https://www.bilibili.com/video/BV1vG4y1n7Rp/?spm_id_from=333.880.my_history.page.click&amp;vd_source=83831fc0970a6c8704479f7cfc679937">强化学习论文分享2022-10-13_哔哩哔哩_bilibili</a></li>
<li></li>
</ol>
<h2 id="计算机系统">1.8 <strong>计算机系统</strong></h2>
<ol type="1">
<li><strong><a href="https://www.bilibili.com/video/BV1cD4y1D7uR/?spm_id_from=333.337.search-card.all.click&amp;vd_source=83831fc0970a6c8704479f7cfc679937&amp;t=42.5">【CSAPP-深入理解计算机系统】</a></strong></li>
<li><a href="https://www.bilibili.com/video/BV17K4y1N7Q2/?spm_id_from=333.337.search-card.all.click&amp;vd_source=83831fc0970a6c8704479f7cfc679937">深入理解计算机系统合集（周更中）_哔哩哔哩_bilibili</a>
<ul>
<li><a href="https://github.com/yangminz/bcst_csapp">yangminz/bcst_csapp: A C language repo to implement CSAPP (github.com)</a></li>
<li>Hello 观众朋友们大家好，这个Repo是我在做《深入理解计算机系统》（CSAPP）视频时所用到的代码，还包括一本设计手册，设计手册还在慢慢更新。代码、手册以及视频都是为了给大家介绍CSAPP这本书，帮助大家阅读和理解最基础的计算机系统知识。特别是本科低年级的同学（大一大二），准备转专业的同学，以及跨专业考研的同学，<strong>通常会掌握一些基本的编程语言，但是可能对计算机系统本身并不足够了解。</strong>我的视频、代码以及手册就是希望帮助大家学习，尽量通过代码实现CSAPP上的知识点，然后再通过视频讲解，<strong>将基础的计算机系统知识连贯起来。</strong></li>
</ul></li>
<li><a href="https://www.bilibili.com/video/BV1Vh411r7ef/?spm_id_from=333.337.search-card.all.click&amp;vd_source=83831fc0970a6c8704479f7cfc679937">深入理解计算机系统_哔哩哔哩_bilibili</a></li>
<li><a href="https://www.bilibili.com/video/BV1gN411975F?p=16&amp;vd_source=83831fc0970a6c8704479f7cfc679937">第九章 虚拟内存_哔哩哔哩_bilibili</a></li>
<li><strong><a href="https://www.bilibili.com/video/BV1r4411s7Hj/?vd_source=83831fc0970a6c8704479f7cfc679937">【计算机结构 Computer Architecture】-台湾清华大学-黄婷婷教授_哔哩哔哩_bilibili</a></strong></li>
<li><strong><a href="https://www.bilibili.com/video/BV1554y1s7LS?p=1&amp;vd_source=83831fc0970a6c8704479f7cfc679937">【强烈推荐】深入浅出计算机组成原理 - 源自台湾 - 非常值得一看 哔哩哔哩_bilibili</a></strong></li>
</ol>
<h2 id="shell编程">1.9 Shell编程</h2>
<ol type="1">
<li><a href="https://www.bilibili.com/video/BV1G7411K7q8/?spm_id_from=333.337.search-card.all.click&amp;vd_source=83831fc0970a6c8704479f7cfc679937">尚硅谷-Linux视频教程-shell编程（入门到精通）</a>
<ol type="1">
<li><a href="https://juejin.cn/post/6844904158135320584">笔记</a></li>
</ol></li>
<li><a href="https://www.bilibili.com/video/BV12L411T79C/?spm_id_from=333.337.search-card.all.click&amp;vd_source=83831fc0970a6c8704479f7cfc679937">跟我一起写Makefile</a></li>
</ol>
<hr>
<h2 id="数电">1.10 <strong>数电</strong></h2>
<blockquote>
<ol type="1">
<li><a href="https://blog.csdn.net/qq_41193189/article/details/103393850">数字电路时序参数总结_tpd是什么参数</a></li>
<li><a href="http://blog.sina.com.cn/s/blog_5d942c720102woxi.html#:~:text=电路在组合电路中的input-to-output延迟可以用两个参数表示，也即tpd和tcd。%20传输延时%20(Propagation,delay%2C%20tpd)--此物理量表明了输入端信号开始变化到输出端信号稳定所需要的时间。%20组合逻辑中，这个量用来保证输入端经过tpd的时间后，输出端不会再有任何的变化。">FPGA技术(1):理解FPGA的时序（建立/保持时间，最大时钟频率）</a></li>
</ol>
<ul>
<li><mark>传输延时 (Propagation delay, tpd)</mark>--此物理量表明了输入端信号开始变化到输出端信号稳定所需要的时间。组合逻辑中，这个量用来保证输入端经过 tpd 的时间后，输出端不会再有任何的变化。</li>
<li><mark>污染延时 (Contamination delay, tcd)</mark>--此物理量表明输入端信号开始变化到输出端信号开始变化所需要的时间。也就是说，在 tcd 时间内，输出不会有任何变化。<mark>即输入变化后，输出还能坚持多久不变</mark></li>
</ul>
<ol start="3" type="1">
<li><a href="https://zhuanlan.zhihu.com/p/93664819#:~:text=奇数分频器跟偶数分频器一样，当计数器的值等于分频系数（加1或者减1）的一半或等于分频系数时，时钟信号翻转。,奇数分频器分频原理如下图：%20上图的分频系数是3，用一个计数器在上升沿计数，每次计数到1翻转一次，每次计数到3再翻转一次，然后周期重复得到信号clkp1，它的周期就是clk的3倍，但是它的占空比不是50%（占空比就是clk为高的时间占整个时钟周期的百分比）。">时钟分频系列——偶数分频/奇数分频/分数分频 - 知乎 (zhihu.com)</a></li>
<li><a href="https://www.cnblogs.com/cosmo89929/archive/2013/02/05/2893056.html">简单分频原理与实现——计数器 - cosmo89929 - 博客园 (cnblogs.com)</a></li>
<li></li>
</ol>
</blockquote>
<ul>
<li><a href="https://hdlbits.01xz.net/wiki/Exams/m2014_q4h">Verilog学习网站</a></li>
<li><a href="https://ww2.mathworks.cn/help/matlab/ref/importtool.html">MATLAB文档</a></li>
<li><a href="https://www.processon.com/;jsessionid=C29B9EDCFE08DF1F472FB37C29140DB9.jvm1">ProcessOn - 免费在线作图，思维导图，流程图，实时协作</a></li>
<li><a href="https://www.cnblogs.com/BUAA-Wander/">BUAA-Wander - 博客园 (cnblogs.com)</a></li>
<li><a href="https://csacademy.com/app/graph_editor/">图论绘图)</a></li>
<li><a href="https://www.bilibili.com/read/cv10338711">HDLBits_Verilog学习笔记Ⅰ——Verilog Language_Basics - 哔哩哔哩 (bilibili.com)</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/356601327">数字IC/FPGA设计100问之——学习路径 - 知乎 (zhihu.com)</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/184031850">Verilog HDL刷题网站推荐——HDLBits - 知乎 (zhihu.com)</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/69637323">5分钟了解Verilog HDL语法结构 - 知乎 (zhihu.com)</a></li>
<li><a href="https://www.zhihu.com/people/xia-qing-er-39">北理- 夏晴儿 - 知乎 (zhihu.com)</a></li>
<li><a href="https://sie.bit.edu.cn/xyxw/zhxw/b186836.htm">北京理工大学信息电子学院 -预推免</a></li>
<li><a href="https://kaoyan.koolearn.com/20201013/1410195.html">北京理工大学2021考研专业目录：信息与电子学院_考研_新东方在线 (koolearn.com)</a></li>
<li><a href="https://blog.csdn.net/qq_41061258/article/details/102566990">夏令营,预推免经验分享（计科方向，天大+北理+上交+国防科大+北邮+清华深圳）_rl小透明-CSDN博客</a></li>
</ul>
<h2 id="微电子">1.11 微电子</h2>
<ol type="1">
<li><strong>为什么三极管能放大电流？</strong></li>
</ol>
<ul>
<li>答：三极管的放大其实并不是真正的放大，只是 <span class="math inline">\(I_{BN}\)</span> 和 <span class="math inline">\(I_{CN}\)</span> 把 <span class="math inline">\(I_{EN}\)</span> 做了分流，而 <span class="math inline">\(I_{BN}\)</span> 由于自身缺陷，只能分走极小的一部分，其余绝大部分被 <span class="math inline">\(I_{CN}\)</span> 分走，而且栅极的结构尺寸确定，那么电流比例就确定了，这就是放大倍数 <span class="math inline">\(\beta\)</span>，<span class="math inline">\(\beta\)</span> 固定只发生在三极管工作在放大区！！！</li>
<li>三极管中的薄的基极将发射结和集电结反紧密的联系在一起，可以把发射结的电流几乎全部地传输到反偏的集电结回路中去，这正是三极管实现放大作用的关键所在。</li>
<li>三极管的结构。器件并不是<strong>对称的！！！</strong>三个区域的参杂浓度明显不同，其中，发射极的参杂浓度高于集电极，基极的参杂浓度最低。此外，在几何尺寸上，基极很薄，集电极的面积比发射极大，正式这种结构特点，构成了三极管具有电流放的作用的物质基础。</li>
<li>其实我认为放大这个词是导致大多数人无法理解的真实原因。 放大镜可以放大钱吗?我拿一块钱，你拿放大5倍的放大镜看就是5块钱? 所谓<mark>放大其实是用小的基极电流去控制了大的集电极电流! 注意是控制!</mark>永远都不要用放大这个概念了，不然这辈子都无法理解模拟电路!</li>
</ul>
<ol start="2" type="1">
<li><strong>什么是冲击响应</strong></li>
</ol>
<ul>
<li>冲激响应就是某个线性时不变系统的输入输出关系的基本特征，任何形式的输入信号，都可以分解成无穷多个不同比例的冲激，而输出就是相应的不同比例的响应的累加。</li>
</ul>
<ol start="3" type="1">
<li><strong>如何理解费米能级？</strong></li>
</ol>
<ul>
<li><strong>费米能级</strong>反映了电子在不同能态上的填充水平，<strong>费米能级</strong>是绝对零度下电子所能够占据的最高能级。低于费米能级的能带全满，高于费米能级的能带全空。</li>
<li><mark>费米狄拉克分布函数含义</mark>：能量为 <span class="math inline">\(E\)</span> 的量子态被电子占据的概率</li>
</ul>
<ol start="4" type="1">
<li><strong>强电场下，为什么会速度饱和</strong></li>
</ol>
<ul>
<li>载流子速度饱和，是载流子在材料中传输的一个基本特性，实质上是在<mark>电场很强时载流子平均能量升高，使载流子通过散射损失能量与从电场获取能量差不多快时</mark>，载流子漂移速度不再随电场增强而增大，从而达到其漂移速度上限。这个速度被称作饱和速度，而此时的电场强度称为临界电场强度。散射的存在，导致速度会在某一个值趋于饱和</li>
</ul>
<h2 id="通信">1.12 通信</h2>
<ul>
<li><a href="https://zhuanlan.zhihu.com/p/399265357">一、通信系统模型（通信原理） - 知乎 (zhihu.com)</a></li>
<li><a href="https://blog.csdn.net/flypassion/article/details/103546657">通信原理及系统系列8—— 如何消除码间串扰_flypassion的博客-CSDN博客</a></li>
<li>麦克斯韦方程组 <img src="https://cdn.staticaly.com/gh/peirsist/blog_img@master/麦克斯韦.43ivarjmvgi0.png" alt="麦克斯韦"></li>
</ul>
<h2 id="半导体物理">1.13 半导体物理</h2>
<ul>
<li><a href="https://www.bilibili.com/video/BV1fp4y1z7oF?from=search&amp;seid=3011327188028506472">【物理】半导体物理 西安电子科技大学 柴常春等主讲_哔哩哔哩_bilibili</a></li>
<li></li>
</ul>
<h1 id="软能力">2 <strong>软能力</strong></h1>
<h2 id="羽毛球">2.1 <strong>羽毛球</strong></h2>
<ol type="1">
<li><p><strong><a href="https://www.bilibili.com/video/BV12t4y1e7L4/?spm_id_from=333.788.recommend_more_video.11&amp;vd_source=83831fc0970a6c8704479f7cfc679937">羽毛球改怎么练力量，为什么和健身不一样呢？爆发力和耐力怎么练？_哔哩哔哩_bilibili</a></strong></p></li>
<li><p><strong><a href="https://www.bilibili.com/video/BV1n94y127z9/?spm_id_from=333.999.0.0&amp;vd_source=83831fc0970a6c8704479f7cfc679937">【李宇轩】单打最佳套路，国际球员常用的（转身球套路），学上这套路，不只是限制对方进攻而且还是限制对方回球位置_哔哩哔哩_bilibili</a></strong></p></li>
<li><p><a href="https://www.bilibili.com/video/BV1yT411T78Y/?spm_id_from=333.880.my_history.page.click&amp;vd_source=83831fc0970a6c8704479f7cfc679937">【李宇轩】我发了短球对方总推我底线就特别难受！怎么解决？_哔哩哔哩_bilibili</a></p></li>
<li><p><a href="https://www.bilibili.com/video/BV1pN4y1F72H/?spm_id_from=333.999.0.0&amp;vd_source=83831fc0970a6c8704479f7cfc679937">羽毛球反手训练，让你获得更大的反手击球力量，轻松将球打到后场_哔哩哔哩_bilibili</a></p></li>
<li><p><strong><a href="https://www.bilibili.com/video/BV1PG41187Vq/?spm_id_from=333.999.0.0&amp;vd_source=83831fc0970a6c8704479f7cfc679937">羽毛球初学者常见错误_哔哩哔哩_bilibili</a></strong></p></li>
<li><p><a href="https://www.bilibili.com/video/BV1vU4y1r7Vf/?spm_id_from=333.999.0.0&amp;vd_source=83831fc0970a6c8704479f7cfc679937">羽毛球高级动作，提升你的羽毛球技能_哔哩哔哩_bilibili</a></p></li>
<li><p><a href="https://www.bilibili.com/video/BV19d4y1o75Z/?spm_id_from=333.999.0.0&amp;vd_source=83831fc0970a6c8704479f7cfc679937">羽毛球步法，轻松应对网前及后场球_哔哩哔哩_bilibili</a></p></li>
<li><p><a href="https://www.bilibili.com/video/BV1hT411w7fL/?spm_id_from=333.999.0.0&amp;vd_source=83831fc0970a6c8704479f7cfc679937">羽毛球挑球常出现的错误_哔哩哔哩_bilibili</a></p></li>
<li><p><strong><a href="https://www.bilibili.com/video/BV1LP4y1a7HH/?spm_id_from=333.880.my_history.page.click&amp;vd_source=83831fc0970a6c8704479f7cfc679937">【高清低视角】林丹vs薛松 剪辑版 享受丹神的球速吧_哔哩哔哩_bilibili</a></strong></p>
<p>看完这个视频，感觉林丹很轻松的原因。 一是，回球到位，所以让对手很难受，因为回球到位，对手难受，自己才很轻松。无论是接杀，还是什么，回球都让对方很难受</p></li>
</ol>
<p><strong><mark>控制自己的情绪，积极向上生活</mark></strong></p>
<ol type="1">
<li><a href="https://www.bilibili.com/video/BV1U5411K7KP/?spm_id_from=333.880.my_history.page.click&amp;vd_source=83831fc0970a6c8704479f7cfc679937">陈铭 内卷到底是什么_哔哩哔哩_bilibili</a></li>
<li><a href="https://www.bilibili.com/video/BV1j14y1Y7dB/?spm_id_from=333.880.my_history.page.click&amp;vd_source=83831fc0970a6c8704479f7cfc679937">【陈铭】“我们有这个习惯，越是有负面情绪，越是伤害至亲的人”_哔哩哔哩_bilibili</a></li>
<li><a href="https://www.bilibili.com/video/BV1ug4y167Cq/?spm_id_from=333.880.my_history.page.click&amp;vd_source=83831fc0970a6c8704479f7cfc679937">【非正式会谈】致 还不想恋爱的自己和屏幕前的你们_哔哩哔哩_bilibili</a></li>
<li><a href="https://www.bilibili.com/video/BV11o4y1Q7bJ/?spm_id_from=333.880.my_history.page.click&amp;vd_source=83831fc0970a6c8704479f7cfc679937">陈铭：为什么我不建议年轻人摸鱼？_哔哩哔哩_bilibili</a></li>
<li><a href="https://www.bilibili.com/video/BV1ft411779h/?spm_id_from=333.880.my_history.page.click&amp;vd_source=83831fc0970a6c8704479f7cfc679937">【非正式会谈5】陈铭传授当代青年人如何应对和抵抗焦虑_哔哩哔哩_bilibili</a></li>
<li><a href="https://www.bilibili.com/video/BV1TA411A7M4/?spm_id_from=333.880.my_history.page.click&amp;vd_source=83831fc0970a6c8704479f7cfc679937">拒绝焦虑！拒绝内卷！非正式会谈这个片段真的好喜欢，宝藏综艺！_哔哩哔哩_bilibili</a></li>
</ol>
<p><strong><mark>宗教、中国人信仰的到底是什么</mark></strong></p>
<ol type="1">
<li><a href="https://www.bilibili.com/video/BV1te4y1v79b/?spm_id_from=333.880.my_history.page.click&amp;vd_source=83831fc0970a6c8704479f7cfc679937">武汉大学陈铭：论恐惧与鬼_哔哩哔哩_bilibili</a></li>
</ol>
<h1 id="英语">3 <strong>英语</strong></h1>
<ol type="1">
<li><a href="https://www.bilibili.com/video/BV13B4y1E78c/?spm_id_from=333.999.0.0&amp;vd_source=83831fc0970a6c8704479f7cfc679937">中英文逻辑_哔哩哔哩_bilibili</a></li>
<li><a href="https://www.bilibili.com/video/BV16T41137jP/?spm_id_from=333.999.0.0&amp;vd_source=83831fc0970a6c8704479f7cfc679937">雅思写作小作文进阶篇——用数学模型拿捏考官_哔哩哔哩_bilibili</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/83528343">雅思写作Task 1（小作文、图表作文）各题型攻略全解析 - 知乎 (zhihu.com)</a></li>
<li></li>
</ol>
]]></content>
      <categories>
        <category>学习链接</category>
      </categories>
  </entry>
  <entry>
    <title>Weekly Meeting</title>
    <url>/2022/10/27/weeklymeeting/</url>
    <content><![CDATA[<h1 id="section">1 2022-12-13</h1>
<h2 id="comments">1.1 comments</h2>
<h2 id="近期工作">1.2 近期工作</h2>
<ol type="1">
<li><strong><em>2022-12-07，周三</em></strong></li>
</ol>
<h2 id="下一步计划">1.3 下一步计划</h2>
<h1 id="section-1">1 2022-12-6</h1>
<h2 id="comments-1">1.1 comments</h2>
<h2 id="近期工作-1">1.2 近期工作</h2>
<ol type="1">
<li><strong><em>2022-12-01，周四</em></strong>，9: 00- 10:00 放松，然后到 11:00 看雅思课程，开带本科生毕设的会，下午又找了找哪些实验需要做，晚上数字图像的课程。</li>
<li><strong><em>2022-12-02，周五</em></strong>，上午 9: 00- 10:00 跑步，然后打羽毛球到 13:00 ，睡觉到 3: 00，然后看雅思《剑桥 15-Test1》两篇精读和题目讲解。到 8: 30，效率太低。</li>
<li><strong><em>2022-12-03，周六</em></strong>，上午 CCF 会议，下午做《剑桥 15-Test2》真题到 3: 00，然后回宿舍，看精讲一篇。晚上回来效率好低，回来看羽毛球视频了，没学习。最近防疫新政策，突然得知要回家。</li>
<li><strong><em>2022-12-04，周日</em></strong>，早上一篇精读，然后排队做核酸，下午赶紧做海洋的作业，准备回家。</li>
<li><strong><em>2022-12-05，周一</em></strong>，早上做党员年终总结 PPT，下午去跑步，吃饭。做《剑桥 15-Test3》，收拾东西。</li>
<li><strong><em>2022-12-06，周二</em></strong>，上午看精讲视频，下午高铁回家。回到家就是 7: 00 了。</li>
</ol>
<hr>
<h1 id="section-2">1 2022-11-29</h1>
<h2 id="comments-2">1.1 comments</h2>
<ol type="1">
<li>功能上有新的功能，or 新的技术。没新技术那就得工作量得到位，实验全不全，有没有跟新方案比</li>
<li>找一个现有分割方案，用机器学习、DRL去优化，实现。适配各种规则集</li>
<li>寻找机器学习的工具RL、DL</li>
</ol>
<h2 id="近期工作-2">1.2 近期工作</h2>
<ol type="1">
<li><strong><em>2022-11-23，周三</em></strong>，上午英语project，然后《剑桥16-Test3》精读视频，下午看ByteCuts这篇论文，然后运动拿快递。最近（几个月）买了
<ol type="1">
<li>羽毛球短袖短裤×1（川崎，短袖 L 码合适）154，<del>短裤×1（熏风）53</del>（退货了）</li>
<li>羽毛球包×1（川崎）108</li>
<li>羽毛球鞋×1（李宁突袭4）450</li>
<li>牛仔裤×1（罗蒙），运动裤×3（鸿星尔克和其他牌子，裤子M码合适）380</li>
<li>鞋×1，210</li>
</ol></li>
<li><strong><em>2022-11-24，周四</em></strong>，9: 00- 11:00 , 2: 00-4: 00 雅思阅读，把之前欠下的补回来了，晚上看一些论文，找灵感。做《剑桥 16-Test2》</li>
</ol>
<blockquote>
<p><strong><font color="red">加强锻炼身体</font></strong></p>
</blockquote>
<ol start="3" type="1">
<li><strong><em>2022-11-25，周五</em></strong>，上午打球，下午从 3: 00 开始看《剑桥 16-Test2》却一直看到晚上 11:00 !!!，真的效率太低</li>
</ol>
<blockquote>
<p><strong><font color="red">做任何事，尤其是学习，一定不要看手机，做任何事之前想想提高效率</font></strong></p>
</blockquote>
<ol start="4" type="1">
<li><strong><em>2022-11-26，周六</em></strong>，上午做《剑桥 16-Test3》，花费一个小时，下午看 3 篇文章精讲，并看论文《一种基于单元空间划分的快速防火墙包分类算法_程玉柱》，突然发现用 ipad 看论文也不错。</li>
<li><strong><em>2022-11-27，周日</em></strong>，上午打羽毛球，吃完饭 12:00 ，玩手机到 2: 00???，睡觉党课考试 4: 00，题目精讲到 5: 30，吃饭 6: 00，消化 7:00.</li>
<li><strong><em>2022-11-28，周一</em></strong>，上午做《剑桥 16-Test4》到 10:00 ，然后对应的精讲到 11:00 ，吃饭做核酸拿快递就到 12:00 ，回来又看会手机 1: 30，反正吃饭完这段时间效率特别低。3: 00 开始做 Bitcuts 的 ppt，做到 4: 00，每次改字体让我难以忍受，果断换成 LaTex 了，7: 30-9: 00 和师兄讨论 Bitcuts，回来从 10:00 做 beamer 到 12:00 。看论文记笔记的顺序：</li>
</ol>
<blockquote>
<p><strong>直接看英文→ ipad 不同颜色标注→ LaTex 文献笔记，顺带着 beamer，做 beamer 前，先在纸上把大纲写出来。</strong> 1. 电脑看论文整句翻译，翻译一篇文章的记法，复习抓不住重点 ❌ 2. 背景需要翻译，单独记，不同颜色Highlight 3. 文章所提出的技术，LaTex整理记</p>
</blockquote>
<ol start="7" type="1">
<li><strong><em>2022-11-29，周二</em></strong>，起床就 9: 00，墨迹一会，《剑桥 16-Test4》看 2、3 篇精读就到中午了，下午完善 beamer，3: 30-4: 10 党支部的组织生活，回来 4:50。和师兄讨论bitcut。</li>
<li><strong><em>2022-11-30，周三</em></strong>，上午《剑桥15-Test1》，被《剑桥16》单词，还要继续背。下午睡到3:00，核酸，跳绳，回来单词准备组会，开会到9:00</li>
</ol>
<h2 id="下一步计划-1">1.3 下一步计划</h2>
<ol type="1">
<li>读一下其他（非决策树哈希表的）论文，继续拓展下思路</li>
<li>怎么划分的问题
<ol type="1">
<li>考虑多少个字段去划分，怎么划分思考范围划分和前缀长度划分的区别，</li>
<li>为什么有的地方用前缀长度划分，有的地方用范围划分</li>
</ol></li>
</ol>
<hr>
<h1 id="section-3">2 2022-11-22</h1>
<h2 id="comments-3">2.1 comments</h2>
<h2 id="近期工作-3">2.2 近期工作</h2>
<ol type="1">
<li><strong><em>2022-11-16，周三</em></strong>，早上 tm 又在整材料，找到了一个好用的 <em>文献笔记模板（LaTex）</em> ，下午还要党会，下午又 tm 改材料，不到最后提交最后一刻，别想消停，每次发过去必有问题，每次要求还总是一个个说，令人🤮。跳绳 1500 个。</li>
</ol>
<blockquote>
<p>在这个组需要 大毅力者…大自学家…大抗压家…</p>
</blockquote>
<ol start="2" type="1">
<li><strong><em>2022-11-17，周四</em></strong>，上午到实验室看 BitCuts 这篇论文，下午超导的课程，做英语 PPT，然后还有数字图像编码的课程，然后帮博哥解决 matlab 的一个问题，然后又改 LaTex 做的笔记。</li>
<li><strong><em>2022-11-18，周五</em></strong>，上午睡到 9: 30，然后洗漱去打球 10:00 -1: 30, 然后拉伸一下，去拿个快递就 2: 00 了，不知不觉就 3: 00 了（写这条就是 3:00），晚上还要区块链的课。</li>
</ol>
<blockquote>
<p>证明自己的研究很有价值，所以要找大牛，去国外一定要找大牛，研究生就是教训。能写出综述的一定是大牛。学术是有游戏规则的，职称高不一定牛，掌握规则诀窍就可以胜利，本质还是一种游戏</p>
</blockquote>
<ol start="4" type="1">
<li><strong><em>2022-11-19，周六</em></strong>，上午在实验室看雅思阅读，做了一套雅思 17 阅读题，5.5 分，对我而言，我是无法长久时间盯着电脑屏幕的，更别说盯着电脑屏幕思考了。 12:00 -2: 30 羽毛球，下课看强化学习</li>
</ol>
<blockquote>
<p>以后学习什么东西，看完视频，一定要总结一下，然后说出来，讲给别人听。</p>
</blockquote>
<ol start="5" type="1">
<li><strong><em>2022-11-20，周日</em></strong>，上午 9: 00- 10:00 打球， 12:00 -2: 30 打球，虽然打球时间可能不多，但是去打球，打球完拉伸，打完球休息，这些时间加起来就很多了。回来 3: 00，点了一个外卖：芝士牛肉卷 23 块，然后去取了一个号理发，回来吃东西，看英语阅读（明天考试），然后 4: 45 去理发店，刚好轮到。回来又看羽毛球包看到 6: 00 吃饭，回来看衣服又看到 7: 00，然后做英语阅读。</li>
</ol>
<blockquote>
<p>周五打羽毛球 10:00 - 13:30 ，打完小腿还没有酸痛；周六 12:00 - 14:30 ，打完只是很胀，没有拉伸，又走了很多步，突然很疼。周日 9: 00- 10:00 + 12:00 - 14:30 。<strong><font color="red">运动之前和之后一定要充分拉伸！ ！ ！</font></strong></p>
</blockquote>
<ol start="6" type="1">
<li><strong><em>2022-11-21，周一</em></strong>，上午工程英语机考，下午背英语project，晚上看雅思阅读《剑桥16-Test1》。其实也一直在看羽毛球包，犹豫要不要买
<ul>
<li>双肩包没有必要，因为拍子并不能分开，而且双肩包日用的也完全可以</li>
<li>双肩的大的背包，太大了，也没那么东西装，太显眼了，也太贵</li>
<li>提包，不考虑，你的目的是解放双手</li>
<li>小号的挎包</li>
</ul></li>
<li><strong><em>2022-11-22，周二</em></strong>，上午整理bit cutting的优点，下午讨论，洗衣服，晚上开会，《剑桥16-Test2》</li>
</ol>
<h2 id="下一步计划-2">2.3 下一步计划</h2>
<hr>
<h1 id="section-4">3 2022-11-15</h1>
<h2 id="comments-4">3.1 comments</h2>
<h2 id="近期工作-4">3.2 近期工作</h2>
<ol type="1">
<li><strong><em>2022-11-09，周三</em></strong>，早上看区块链，下午区块链到 5 点，然后准备组会，开会到 10 点，准备区块链。记录在 🔗<a href="/2022/11/09/%E8%AE%BA%E6%96%87/%E5%8C%BA%E5%9D%97%E9%93%BE/" title="区块链">区块链</a>。</li>
</ol>
<p>💥 内心活动</p>
<blockquote>
<p><strong>今天开完组会失眠了，失眠的原因在于</strong>：</p>
<ol type="1">
<li><strong>科研上的无助</strong>。一想到自己一个人做，看不懂又没人会，没人商量，全程自己在搞</li>
<li>关键自己搞完，还要....... hehe</li>
<li><strong>生活的不适应</strong>。来到这里饮食、作息（睡眠时间），真的很不适应，饭那么多油，真的吐🤮；然后每天睡这么晚，一超过 12 点就长痘，全是饮食、作息不规律、压力大导致的。脸上这么多痘痘，就足以反应出我的状态不好</li>
<li>make frequent or unpredictable changes in policy</li>
</ol>
</blockquote>
<blockquote>
<p><strong><font color="red">其实你挺容易抑郁的，至少你不是很乐观，但是不能这么悲观，凡事往好的方面想，何必难为自己，多和人交流</font></strong></p>
</blockquote>
<blockquote>
<p><strong><font color="red">人一定要乐观，无论面对什么样的场景，都可以释然，微笑面对，很重要！不要抱怨，发牢骚，这点得改，不然太容易消极悲观了。</font></strong></p>
</blockquote>
<blockquote>
<p><strong>尽快做的事</strong>：</p>
<ol type="1">
<li>雅思考过</li>
<li>C++尽可能精通</li>
<li>机器学习和 python</li>
</ol>
</blockquote>
<ol start="2" type="1">
<li><strong><em>2022-11-10，周四</em></strong>，上午 10:00 去实验室问师兄师姐的方案，到 12:00 ，然后下午超导课，晚上数字图像编码以及大数据时代下的讲座</li>
<li><strong><em>2022-11-11，周五</em></strong>，上午 9: 00- 10:00 准备区块链，然后打球到 13:00 ，吃饭 14:00 党会，然后一下午准备区块链，晚上区块链的课。</li>
</ol>
<p>🔴 <strong>注：如何汇报</strong></p>
<blockquote>
<p><strong><font color="red">自信要刻意练习，无论给谁来，同学老师老板做汇报，一定要自信，显的你很会，有板书，显得别人不会我会。</font></strong></p>
</blockquote>
<ol start="4" type="1">
<li><strong><em>2022-11-12，周六</em></strong>，好像又在玩吧，不知道忘了</li>
<li><strong><em>2022-11-13，周日</em></strong>，整体又在改材料，不知道为什么，改这总是很费时间。</li>
<li><strong><em>2022-11-14，周一</em></strong>，上午和下午又 tm 的改材料，每次 tm 的发过去，总有不同的要求，这本来就是一个谁看谁有问题的活，没有标准答案的活，非 tm 一级一级往下传。下午跳绳 1600，晚上看论文 <em>An Observation of Packet Classification: Most Rules are at the Top</em></li>
<li><strong><em>2022-11-14，周二</em></strong>，上午睡到 10 点，然后又 tm 整材料。下午睡觉，跳绳 2000 个，然后和师兄谈论数据包分类论文，晚上组会</li>
</ol>
<blockquote>
<p>这几天每天又到 12 点睡觉了🤮，以后白天效率高一点，晚上 8 点后不要看电脑。9 点锻炼 1 小时，然后睡觉。</p>
</blockquote>
<h2 id="下一步计划-3">3.3 下一步计划</h2>
<hr>
<h1 id="section-5">4 2022-11-08</h1>
<h2 id="comments-5">4.1 comments</h2>
<ol type="1">
<li>为什么位切割比较快，优点相对于其他的方案在哪？</li>
<li>解决哪个问题，用什么技术解决</li>
<li>从代码上实现机器学习，复现一个机器学习的方法，复现的过程中考虑优缺点</li>
<li>瞄准一篇最新最好的论文，体会论文哪里有问题可以改进，设计自己的改进方案，怎么改进得认知领域</li>
<li>11 月底之前找到一个问题，</li>
</ol>
<h2 id="近期工作-5">4.2 近期工作</h2>
<ol type="1">
<li><p><strong><em>2022-11-02，周三</em></strong>，上午英语 pre 之后，回来取快递 <em>AC108EX</em> 手胶，然后贴手胶，确实好用，然后就在看羽毛球视频，下午睡觉之后，数字图像处理水印现状到 3:30，看论文<em>bitcut</em>。 ✅ ❌ ✘ ✔ ✓ ✗</p></li>
<li><p><strong><em>2022-11-03，周四</em></strong>，上午看论文<em>2017-BitCuts A Fast Packet Classification algorithm using bit-level cutting-Tsinghua University</em>，但是还没有举出来例子，<strong>注意力集中果然坚持不了长时间，但是看论文又需要集中注意力，所以一篇论文得分段来看。</strong> 下午超导课程，为了发论文，跨学科交流，5:00 跑步，6:30 <em>数字图像编码</em> ，讲到 7:40，安装<em>Obsidian.1.0.3</em></p></li>
<li><p><strong><em>2022-11-04，周五</em></strong>，看了一天 <em>2018-ByteCuts Fast Packet Classification by Interior Bit Extraction</em>，（🤬真的要吐槽一句，写论文的人把论文写的这么难懂干什么，总要定义个什么东西）没看懂。下午总结数据包分类 <em>decision tree</em> 部分，晚上区块链课。</p></li>
<li><p><strong><em>2022-11-05，周六</em></strong>，上午看玩羽毛球视频，中午买了羊肉去吃火锅，下午 2:00-3:30 开党会，4:00-5:00 打羽毛球，5:00-5:50 跑步，5:50-6:30 学四吃饭，7:00-9:00 电影《暗战 1》，刘德华真的太帅了:)</p></li>
</ol>
<blockquote>
<p><strong><font color="red"> <font size="5"> 切忌暴饮暴食，不要晚上 8:00 后吃东西（最近经常吃瓜子☹，不要再胡吃了），更不要吃垃圾食品（高糖高油食品：油炸类食品，碳酸饮料，薯片/薯条，烤肠，膨化类食品）</font> </font></strong></p>
</blockquote>
<blockquote>
<p><a href="https://www.bilibili.com/read/cv9503271">长期高油、高糖、高盐会对人体造成哪些危害？怎样吃才算是真正的健康呢？ - 哔哩哔哩 (bilibili.com)</a></p>
</blockquote>
<ol start="5" type="1">
<li><strong><em>2022-11-06，周日</em></strong>，上午去实验室看硕士论文，了解现状，下午看到 3 点不想看了，去跑步了，晚上回来 7 点好像又在看羽毛球😅。得专注一点.......</li>
<li><strong><em>2022-11-07，周一</em></strong>，上午继续看论文，下午看到 4 点，去打羽毛球，吃完饭 8 点，然后看羽毛球装备到 10 点</li>
<li><strong><em>2022-11-07，周二</em></strong>，上午总结数据包现状，1:30-3:00 讨论，回来练习怎么讲，到 5:30 去吃饭，回来不开组会了，然后又看羽毛球视频了😅，准备英语 project 几个问题。</li>
</ol>
<blockquote>
<p><strong><font color="red">组会一定要提前一天准备好，前一天一定要张嘴说，一说出来就会发现，好多东西还不会，张嘴说与心里想有很大区别，同样写出来与心里想也有很大区别。</font></strong></p>
</blockquote>
<h2 id="下一步计划-4">4.3 下一步计划</h2>
<ol type="1">
<li>继续阅读论文 50-60 篇</li>
<li>瞄准 1、2 篇论文，想解决的问题</li>
<li>争取复现机器学习的实验（11 月）(hehe......</li>
<li>11 底哪篇文章，什么问题</li>
<li>和师兄师姐交流一下</li>
</ol>
<hr>
<h1 id="section-6">5 2022-11-01</h1>
<h2 id="comments-6">5.1 comments</h2>
<ol type="1">
<li>实验在什么平台，怎么做的，跟谁对比，哪些参数对比</li>
<li>每一组实验，实验结果，哪里的创新导致这样的实验结果</li>
<li>11 月底，达到论文突破 20 篇，用什么思路解决了什么问题</li>
</ol>
<p>🟢 <strong>师姐的笔记</strong></p>
<p>在就是用他所说的例子讲方案的时候可以配上对应的流程图，他比较喜欢这样，觉得清楚。再就是加上结论（工作之后的成果经过加工后的你自己的想法），还有下周工作。汇报内容序号后面加上（comments1,2,3....），他觉得这样清楚，再就是因为他自己都不记得自己提了啥 comments,你得提醒他一下。</p>
<h2 id="近期工作-6">5.2 近期工作</h2>
<ol type="1">
<li><strong><em>2022-10-26，周三</em></strong>，上午英语，下午海洋</li>
<li><strong><em>2022-10-27，周四</em></strong>，上午工程伦理考试，下午数字图像处理，晚上考试。</li>
</ol>
<p>🔴 <strong>注：今日感想</strong></p>
<blockquote>
<p><font size="5">发现一深入学什么，学不会就不想学就不敢兴趣了😅，数字图像就是这样，不会之前听着可好，一深入，就发现不太喜欢。现在就想模拟器件挺好，但是你好像忘记了当初搞不懂 BJT，什么载流子的原理时的痛苦了。<strong>一深入了解就发现有些东西不是你想的那么回事</strong>，尽快了解，找到自己的方向。目前考虑编程、硬件</font></p>
</blockquote>
<ol start="3" type="1">
<li><strong><em>2022-10-28，周五</em></strong>，上午 9:00 点醒，看羽毛球视频，下午睡觉洗衣服，跑步，看《五亿探长雷洛 1》。</li>
<li><strong><em>2022-10-29，周六</em></strong>，上午睡觉，下午在看电影吃瓜子，一句话，啥都没干~</li>
<li><strong><em>2022-10-30，周日</em></strong>，上午从 8:30-12:00 打羽毛球，吃完饭 1:00，下午准备英语 presentation 的演讲稿和图标作文。</li>
<li><strong><em>2022-10-31，周一</em></strong>，上午英语课，下午 2:30 讨论明天汇报的内容，看论文 <strong><em><big> <font face="Times new roman"> MBitTree A fast and scalable packet classification for software switches </font></big></em></strong> 到 5 点，吃饭回来把这篇论文看懂了。
<ul>
<li>做事要关闭手机，看看自己做这件事花了多长时间</li>
<li><strong>《决策树报文分类算法_吕高锋》</strong> 这篇论文很重要</li>
<li>450￥ 买了羽毛球鞋</li>
<li>今天看英文的速度还可以，还要加强。</li>
<li>待办：<del>英语演讲练习及 ppt 修改</del>，英语 test，<del>准备论文</del>，了解雅思</li>
</ul></li>
</ol>
<p>🔴 <strong>存在的问题：</strong></p>
<blockquote>
<p><strong><font color="red"> <font size="5">切忌长时间看电脑，尤其是晚上超过 9 点看电脑！！！一到 12 点就长痘</font> </font></strong></p>
</blockquote>
<ol start="7" type="1">
<li><strong><em>2022-11-01，周二</em></strong>，上午在实验室准备讲例子，下午睡觉，然后更新印象笔记，晚上听组会。</li>
</ol>
<p>🔴 <strong>思考：</strong></p>
<blockquote>
<ol type="1">
<li>每次去更新那个印象笔记太浪费时间了，因为巨难用😅，每次浪费一些没必要的时间。</li>
<li>每次准备讲论文的时候，反复去查期刊，单位，也浪费不必要的时间，每次看论文，<strong>打开 ppt，md 文件</strong>，作者信息、单位等两个文件都放。另外说一句，看论文的时候，<strong>所有论文的 Introduction 和 Related work 可以翻译完和原文放在一个 md 文件中</strong>，方便你自己去写论文。然后其他部分没有必要全文翻译然后复制粘贴，其他部分<strong>提炼成一张图</strong>的形式。</li>
<li><strong>周一（提前一天）要把组会所有东西准备好，包括演练。</strong></li>
</ol>
</blockquote>
<h2 id="下一步计划-5">5.3 下一步计划</h2>
<hr>
<h1 id="section-7">6 2022-10-25</h1>
<h2 id="comments-7">6.1 comments</h2>
<h2 id="近期工作-7">6.2 近期工作</h2>
<ol type="1">
<li><strong><em>2022-10-19，周三</em></strong>，早上英语课，到实验打印论文 <em>An approach to enhance packet classification performance of software-defined network using deep learning</em>，下午中西方海洋史 ，看完了论文，但需要补充神经网络和反向传播算法，才能进一步理解。晚上，输出 <code>packet</code> 和 <code>packet</code> 对应哈希表的序号</li>
</ol>
<ul>
<li><p><strong><mark>如何输出变量到 CSV 文件</mark></strong></p>
<ol type="1">
<li><a href="https://blog.csdn.net/weixin_43918046/article/details/106367507?spm=1001.2101.3001.6661.1&amp;utm_medium=distribute.pc_relevant_t0.none-task-blog-2~default~CTRLIST~Rate-1-106367507-blog-120163625.pc_relevant_aa_2&amp;depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2~default~CTRLIST~Rate-1-106367507-blog-120163625.pc_relevant_aa_2&amp;utm_relevant_index=1">C++文件操作，读取，写入，追加写入_Guapifang 的博客-CSDN 博客_c++ 追加写文件</a></li>
<li><a href="https://blog.csdn.net/weixin_43237242/article/details/100905961">C++将数据输出格式为.csv 文本文件（也可用 excel 打开）_浦柳人的博客-CSDN 博客_c++输出 csv 文件</a></li>
</ol></li>
</ul>
<ol start="2" type="1">
<li><strong><em>2022-10-20，周四</em></strong>，上午工程伦理，下午睡觉醒来，洗洗衣服就 5 点，然后就跑去运动了。晚上做了 hexo 博客。</li>
<li><strong><em>2022-10-21，周五</em></strong>，上午打球，下午看反向传播算法</li>
<li><strong><em>2022-10-22，周六</em></strong>，上午打球，下午看论文，但是 <strong>效率很低</strong></li>
<li><strong><em>2022-10-23，周日</em></strong>，上午打球，下午复习反向传播</li>
<li><strong><em>2022-10-24，周一</em></strong>，上午英语课，下午睡到 3 点
<ul>
<li>外卖困在系统里。</li>
<li>整 blog，又 5 点了，跑步吃饭。</li>
</ul></li>
<li><strong><em>2022-10-25，周二</em></strong>，上午数字图像处理，下午党支部会议，晚上组会。</li>
</ol>
<p>🔴 <strong>存在的问题：</strong></p>
<blockquote>
<p><strong><font color="red"> <font size="5">做事效率不够专注，效率太低。</font> </font></strong></p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">TupleMergeOnline::ClassifyAPacket</span><span class="params">(<span class="type">const</span> Packet&amp; p)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//printf(&quot;----------------------------------------------\\n&quot;);</span></span><br><span class="line"><span class="comment">//printf(&quot;TupleMergeOnline::ClassifyAPacket\\n&quot;);</span></span><br><span class="line">fstream csv;</span><br><span class="line">csv.<span class="built_in">open</span>(<span class="string">&quot;output.csv&quot;</span>,ios::out|ios::app); <span class="comment">//打开文件路径 ios::out输出，ios::app追加方式，不会覆盖原来的数据</span></span><br><span class="line"><span class="comment">//csv&lt;&lt;&quot;SIP&quot;&lt;&lt;&quot;,&quot;&lt;&lt;&quot;DIP&quot;&lt;&lt;&quot;,&quot;&lt;&lt;&quot;SP&quot;&lt;&lt;&quot;,&quot;&lt;&lt;&quot;DP&quot; &lt;&lt;&quot;,&quot;&lt;&lt;&quot;Pro&quot;&lt;&lt;endl;    //输入内容，注意要用逗号，隔开</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//for (int i = 0;i &lt; 5; i++)&#123;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//printf(&quot;p[%d]==%d &quot;,i,p[i]);    </span></span><br><span class="line"><span class="comment">//cout &lt;&lt;&quot;p==&quot; &lt;&lt;p[i] &lt;&lt; &#x27; &#x27; ;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="comment">//cout &lt;&lt; endl;</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> prior = <span class="number">-1</span>;</span><br><span class="line"><span class="type">int</span> q = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> b = <span class="number">0</span>; </span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> &amp; t : tables) &#123;  <span class="comment">//遍历每一个哈希表</span></span><br><span class="line">a++;</span><br><span class="line"><span class="keyword">if</span> (t-&gt;<span class="built_in">MaxPriority</span>() &gt; prior) &#123; <span class="comment">//判断是否要进入哈希表</span></span><br><span class="line"><span class="keyword">if</span>(t-&gt;<span class="built_in">ClassifyAPacket</span>(p) &gt; prior)&#123; </span><br><span class="line"><span class="comment">//一旦进入哈希表查找，当哈希表的规则优先级高时，当前哈希表就有可能匹配的哈希表，就要用b来记录</span></span><br><span class="line">prior = t-&gt;<span class="built_in">ClassifyAPacket</span>(p);</span><br><span class="line">b = a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//prior = max(prior, t-&gt;ClassifyAPacket(p));</span></span><br><span class="line">q++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//printf(&quot;b==%d\\n&quot;,b);</span></span><br><span class="line">csv &lt;&lt; p[<span class="number">0</span>]&lt;&lt;<span class="string">&quot;,&quot;</span>&lt;&lt;p[<span class="number">1</span>]&lt;&lt;<span class="string">&quot;,&quot;</span>&lt;&lt;p[<span class="number">2</span>]&lt;&lt;<span class="string">&quot;,&quot;</span>&lt;&lt;p[<span class="number">3</span>]&lt;&lt;<span class="string">&quot;,&quot;</span>&lt;&lt;p[<span class="number">4</span>] &lt;&lt;<span class="string">&quot;,&quot;</span>&lt;&lt; b &lt;&lt;endl;</span><br><span class="line">csv.<span class="built_in">close</span>();</span><br><span class="line"><span class="built_in">QueryUpdate</span>(q);</span><br><span class="line"><span class="keyword">return</span> prior;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="section-8">7 2022-10-18</h1>
<h2 id="comments-8">7.1 comments</h2>
<h2 id="近期工作-8">7.2 近期工作</h2>
<ol type="1">
<li><p>周三，在实验室电脑上安装虚拟机，安装 gcc、g++，运行 PartitionSort 的代码，从中提取 TSS 的指标（看图）。问师姐的当前的方案，目前需求是需要找到查找数据包在哪个哈希表的那段代码，</p></li>
<li><p>周四，与老师讨论，规范 weekly meeting 的内容。跟作者发邮件</p>
<ul>
<li><p><strong><mark>如何发邮件</mark></strong></p>
<ol type="1">
<li>** <a href="https://www.zhihu.com/question/27145261">如何礼貌地向文献作者索要源代码？ - 知乎 (zhihu.com)</a> **</li>
<li>** <a href="https://www.zhihu.com/question/29748091">给论文作者发邮件问问题？ - 知乎 (zhihu.com)</a> **</li>
<li>** <a href="https://blog.csdn.net/wuyanne/article/details/116047368">发邮件向论文作者卑微求代码模板_一只小小小飞鸟的博客-CSDN 博客_给论文作者发邮件请教问题模板</a> **</li>
</ol></li>
<li><p><strong><mark>邮件内容</mark></strong></p></li>
</ul></li>
<li><p>周五，和张楠讨论<em>Fast Online Packet Classification With Convolutional Neural Network</em></p></li>
<li><p>周六，看 TM 中 TSS 部分的代码</p>
<ul>
<li><strong><mark>cuckoo hash</mark></strong>
<ol type="1">
<li>** <a href="https://zhuanlan.zhihu.com/p/462815302">布隆过滤器与布谷鸟过滤器 - 知乎 (zhihu.com)</a> **</li>
<li>** <a href="https://zhuanlan.zhihu.com/p/442498412">布谷鸟哈希和布谷鸟过滤器 - 知乎 (zhihu.com)</a> **</li>
<li>** <a href="https://blog.csdn.net/nannanxiami/article/details/109568254">Cuckoo Hash 布谷鸟哈希_nannanxiami 的博客-CSDN 博客</a> **</li>
<li>** <a href="https://blog.csdn.net/suwei19870312/article/details/7442786?spm=1001.2101.3001.6661.1&amp;utm_medium=distribute.pc_relevant_t0.none-task-blog-2~default~CTRLIST~Rate-1-7442786-blog-109568254.pc_relevant_3mothn_strategy_recovery&amp;depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2~default~CTRLIST~Rate-1-7442786-blog-109568254.pc_relevant_3mothn_strategy_recovery&amp;utm_relevant_index=1">Cuckoo Hash 基本思想和代码实现_码农 SW 的博客-CSDN 博客_cuckoo hash</a> **</li>
<li>** <a href="https://blog.csdn.net/wc13197389627/article/details/112433980?spm=1001.2101.3001.6650.5&amp;utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~Rate-5-112433980-blog-109568254.pc_relevant_3mothn_strategy_recovery&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~Rate-5-112433980-blog-109568254.pc_relevant_3mothn_strategy_recovery&amp;utm_relevant_index=6">Cuckoo Hash 及其性质_Rauchy 的博客-CSDN 博客_cuckoo hash</a> **</li>
</ol></li>
</ul></li>
<li><p>周一，<em>A Learned Bloom Filter-assisted Scheme for Packet Classification in Software-Defined Networking</em></p>
<ul>
<li><strong><mark>Bloom Filter</mark></strong>
<ol type="1">
<li><a href="https://blog.csdn.net/qq_40124555/article/details/122810154">什么是布隆过滤器？如何使用？_Java 技术债务的博客-CSDN 博客_布隆过滤器</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/148716788">通俗易懂讲布隆过滤器 - 知乎 (zhihu.com)</a></li>
<li><a href="https://developer.aliyun.com/article/1046992">图解布隆过滤器，十分钟带你理解什么是布隆过滤器？-阿里云开发者社区 (aliyun.com)</a></li>
</ol></li>
<li><strong><mark>cross production 交叉熵</mark></strong>
<ol type="1">
<li><a href="https://blog.csdn.net/xiao_xian_/article/details/116011455">机器学习--- 交叉熵损失(CrossEntropy Loss)--(附代码)_Jankin_Tian 的博客-CSDN 博客_交叉熵损失函数代码</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/35709485">损失函数｜交叉熵损失函数 - 知乎 (zhihu.com)</a></li>
<li></li>
</ol></li>
</ul></li>
</ol>
<h2 id="下一步计划-6">7.3 下一步计划</h2>
]]></content>
      <categories>
        <category>研究生</category>
      </categories>
      <tags>
        <tag>汇报</tag>
      </tags>
  </entry>
  <entry>
    <title>VS2019新建C自动添加作者版权等信息</title>
    <url>/2022/05/16/02%E5%AE%89%E8%A3%85%E8%BD%AF%E4%BB%B6/VS%E6%96%B0%E5%BB%BAcpp%E8%87%AA%E5%8A%A8%E6%B7%BB%E5%8A%A0%E4%BD%9C%E8%80%85%E7%89%88%E6%9D%83%E7%AD%89%E4%BF%A1%E6%81%AF/</url>
    <content><![CDATA[<h1 id="visualstudio2019新建c自动添加作者版权等信息">VisualStudio2019新建C自动添加作者版权等信息</h1>
<h4 id="参考">参考</h4>
<ul>
<li><p><a href="https://blog.csdn.net/weixin_43949535/article/details/100050210">给VS2019添加上自己的个人信息_vs2019添加作者</a></p></li>
<li><p><a href="http://c.biancheng.net/cpp/html/761.html">华为C语言编程规范（3）—注释_C语言中文网</a></p></li>
<li><p><a href="https://www.cnblogs.com/minuy/p/14058721.html">【C#】VS2019新建C#类自动添加作者版权等信息</a></p></li>
<li><p><a href="https://blog.csdn.net/weixin_40962970/article/details/115005630">c语言注释规范_c语言注解</a></p></li>
</ul>
<h3 id="注释规范">注释规范</h3>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">/*****************************************************************</span><br><span class="line">Copyright: 1988-1999, Huawei Tech. Co., Ltd.</span><br><span class="line">File name: 文件名</span><br><span class="line">Description: 用于详细说明此程序文件完成的主要功能，与其他模块或函数的接口，输出值、取值范围、含义及参数间的控制、顺序、独立或依赖等关系</span><br><span class="line">Author: 作者</span><br><span class="line">Version: 版本</span><br><span class="line">Date: 完成日期</span><br><span class="line">History: 修改历史记录列表， 每条修改记录应包括修改日期、修改者及修改内容简述。</span><br><span class="line">*****************************************************************/</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">/**══════════════════════════════════╗</span><br><span class="line">*作    者：songbaobao                                                ║</span><br><span class="line">*职    业：我以我血荐轩辕                                              ║                                              </span><br><span class="line">*CSND地址：https://blog.csdn.net/weixin_43949535                       ║</span><br><span class="line">**GitHub ：https://github.com/TsinghuaLucky912/My_own_C-_study_and_blog║</span><br><span class="line">*═══════════════════════════════════╣</span><br><span class="line">*创建时间：                                                           </span><br><span class="line">*功能描述：                                                            </span><br><span class="line">*                                                                      </span><br><span class="line">*                                                                      </span><br><span class="line">*═══════════════════════════════════╣</span><br><span class="line">*结束时间:                                                           </span><br><span class="line">*═══════════════════════════════════╝</span><br><span class="line">//                .-~~~~~~~~~-._       _.-~~~~~~~~~-.</span><br><span class="line">//            __.&#x27;              ~.   .~              `.__</span><br><span class="line">//          .&#x27;//              西南\./联大               \\`.</span><br><span class="line">//        .&#x27;//                     |                     \\`.</span><br><span class="line">//      .&#x27;// .-~&quot;&quot;&quot;&quot;&quot;&quot;&quot;~~~~-._     |     _,-~~~~&quot;&quot;&quot;&quot;&quot;&quot;&quot;~-. \\`.</span><br><span class="line">//    .&#x27;//.-&quot;                 `-.  |  .-&#x27;                 &quot;-.\\`.</span><br><span class="line">//  .&#x27;//______.============-..   \ | /   ..-============.______\\`.</span><br><span class="line">//.&#x27;______________________________\|/______________________________`.</span><br><span class="line">*/</span><br><span class="line">————————————————</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>安装软件</tag>
      </tags>
  </entry>
  <entry>
    <title>虚拟机安装Ubuntu18.04</title>
    <url>/2021/10/21/02%E5%AE%89%E8%A3%85%E8%BD%AF%E4%BB%B6/%E5%AE%89%E8%A3%85Ubuntu/</url>
    <content><![CDATA[<h1 id="安装ubuntu和ndnsim遇到的问题">安装Ubuntu和ndnSIM遇到的问题</h1>
<h2 id="安装好ubuntu后无法复制粘贴"><mark>安装好Ubuntu后，无法复制粘贴</mark></h2>
<ul>
<li>先去装<code>Vmstation tools</code>，安装过程中会遇到的问题。需要在虚拟机中设置一下</li>
<li>但仍然无法复制粘贴 参考<a href="https://www.zhihu.com/question/41586989">虚拟机安装好了VMtools了,但是还是不能实现文件拖拽和复制功能？(zhihu.com)</a></li>
<li><strong>埋坑</strong>_办法是 先<code>vmware-uninstall-tools.pl</code>把你安装的不能运行的<code>vmtools</code>卸载了.然后 <code>apt-get install open-vm-tools-desktop</code>。 <code>reboot</code>。then ok</li>
</ul>
<h2 id="ubuntu字体大小更改"><mark>Ubuntu字体大小更改</mark></h2>
<ul>
<li><p><strong><a href="https://blog.csdn.net/dghcs18/article/details/104420127">如何调整Ubuntu的字体大小？</a></strong></p></li>
<li><p><code>Ubuntu</code>更改源</p></li>
</ul>
<h2 id="安装ndnsim后无法可视化"><mark>安装ndnSIM后，无法可视化。</mark></h2>
<ul>
<li><p><strong><a href="https://blog.csdn.net/GregoryHanson/article/details/83036964">ndnSIM安装教程</a></strong></p></li>
<li><p>在尝试了网上所有办法后，仍是不行。以下是尝试仍然不行的：</p></li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20200316154116957.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzk3NDQxMw==,size_16,color_FFFFFF,t_70" alt="可以看到ndnSIM是enabled的" style="zoom: 50%;"></p>
<p><strong>可以看到图中的Python Binding 和PyViz visualizer都是 not enabled</strong></p>
<ul>
<li><strong><a href="https://blog.csdn.net/xiaoxin990214/article/details/70157263">ndnSIM中可视化的解决办法-CSDN博客</a></strong></li>
<li><strong><a href="https://blog.csdn.net/neuwyt/article/details/52242853">ndnSIM 2.0 因缺少pythonbind无法使用visual组件问题 —pybindgen (found '') ".. ns3::VisualSimulatorImpl not found"</a></strong></li>
<li><strong><a href="https://blog.csdn.net/sinat_36418396/article/details/106569512">执行 sudo ./waf --run second --vis 出现错误：VisualSimulatorImpl not found-CSDN博客</a></strong></li>
</ul>
<p>原因在于python依赖的安装包没有安装。</p>
<h3 id="python-binding解决">python Binding解决</h3>
<ol type="1">
<li>安装python3</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get install python3-pip</span><br><span class="line">pip3 install pybindgen</span><br></pre></td></tr></table></figure>
<ul>
<li><a href="https://www.lipsuper.com/index.php/2020/10/13/python-pit/">Python报错解决Command 'pip' not found, but there are 18 similar ones.</a></li>
<li><a href="https://blog.csdn.net/qq_31648921/article/details/112404288">ns-3学习手记10_ns3.29中PyViz visualizer没有enabled，进行安装.</a></li>
<li><a href="https://blog.csdn.net/weixin_43974413/article/details/104899594">ubuntu18下 ndnSIM安装过程详解。</a></li>
</ul>
<h3 id="pyviz-visualizer解决">PyViz visualizer解决</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt-get install python-dev python-pygraphviz python-kiwi python-pygoocanvas python-gnome2 gir1.2-goocanvas-2.0 python-rsvg</span><br></pre></td></tr></table></figure>
<ul>
<li><p><strong><a href="https://blog.csdn.net/qq_31676673/article/details/88107454">在NS-3中安装可视化工具pyviz的一些问题的解决</a></strong></p></li>
<li><p><strong><a href="https://www.dazhuanlan.com/chenalonso/topics/1556322">ndnSIM仿真平台使用之安装</a></strong></p></li>
<li><p>可以再把与python有关的再装一遍</p></li>
<li><figure>
<img src="https://img-blog.csdnimg.cn/20200316154116957.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzk3NDQxMw==,size_16,color_FFFFFF,t_70" alt="可以看到ndnSIM是enabled的"><figcaption aria-hidden="true">可以看到ndnSIM是enabled的</figcaption>
</figure></li>
<li><p>出现以下图片后</p></li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./waf</span><br></pre></td></tr></table></figure>
<ul>
<li>进行编译，但会出现卡了，这时需要增大虚拟机内存</li>
<li>重新编译，终于安装好了</li>
</ul>
<h2 id="其他参考网站">其他参考网站</h2>
<ul>
<li><p><a href="https://blog.csdn.net/weixin_43314519/article/details/106531060">NS3快速入门（使用VScode查看、编译代码）</a></p></li>
<li><p><a href="https://blog.csdn.net/weixin_43314519/article/details/106504008">NS3 入门环境搭建（VM虚拟机+Ubuntu，常见错误解析）</a></p></li>
<li><p><a href="https://blog.csdn.net/fwhdzh/article/details/106292166">使用vscode开发ns3项目（代码高亮、自动补全支持）</a></p></li>
<li><p><a href="https://cn.bing.com/search?q=vscode运行ns-3&amp;form=ANNTH1&amp;refig=062a1e9b111042da825ae882e17b4c22">vscode运行ns-3 - 国内版 Bing</a></p></li>
</ul>
]]></content>
      <tags>
        <tag>安装软件</tag>
      </tags>
  </entry>
  <entry>
    <title>安装Ubuntu18.04双系统</title>
    <url>/2022/10/18/02%E5%AE%89%E8%A3%85%E8%BD%AF%E4%BB%B6/%E5%AE%89%E8%A3%85Ubuntu%E5%8F%8C%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<h2 id="安装ubuntu双系统">安装Ubuntu双系统</h2>
<ol type="1">
<li><a href="https://blog.csdn.net/qq_43106321/article/details/105361644">Windows 10 安装ubuntu 18.04 双系统（超详细教程）_Ycitus的博客-CSDN博客_windows10安装双系统ubuntu</a></li>
<li><a href="https://blog.csdn.net/weixin_44623637/article/details/106723462">Ubuntu18.04安装教程——超详细的图文教程_Krasjet_Yu.的博客-CSDN博客_ubuntu18.04</a></li>
<li><a href="https://blog.csdn.net/wangshiming88/article/details/85333046?utm_medium=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase&amp;depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase">安装Ubuntu Linux系统时硬盘分区最合理的方法ubuntu18.04分区设置_wangshiming的博客-CSDN博客_ubuntu18.04安装分区</a></li>
<li><a href="https://blog.csdn.net/baidu_36602427/article/details/86548203">Ubuntu18.04安装教程_寥廓长空的博客-CSDN博客_ubuntu安装教程</a></li>
</ol>
<h2 id="注意"><mark>注意</mark></h2>
<ol type="1">
<li>进入Bios界面，一直按<code>F2</code></li>
<li>如何启动进入选择系统界面还没解决，linux系统用的不多，总体来说还是虚拟机方便，但是虚拟机占用内存。</li>
</ol>
]]></content>
      <tags>
        <tag>安装软件</tag>
      </tags>
  </entry>
  <entry>
    <title>MOS电容总结</title>
    <url>/2022/03/23/%E6%99%B6%E4%BD%93%E7%AE%A1/MOS%E7%AE%A1%E7%94%B5%E5%AE%B9/</url>
    <content><![CDATA[<h2 id="mos电容"><span class="math inline">\(MOS\)</span>电容</h2>
<h3 id="栅沟电容c_gc与mos管工作状态有关">1. 栅沟电容<span class="math inline">\(C_{GC}\)</span>(与<span class="math inline">\(MOS\)</span>管工作状态有关)</h3>
<table>
<thead>
<tr class="header">
<th style="text-align: center;"><span class="math inline">\(MOS\)</span>工作状态</th>
<th style="text-align: left;">电容分布</th>
<th>大小</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">截止区</td>
<td style="text-align: left;"><strong>栅—衬底</strong><span class="math inline">\(C_{GCB}\)</span> 电容</td>
<td><span class="math inline">\(C_{ox}WL\)</span></td>
</tr>
<tr class="even">
<td style="text-align: center;">线性区</td>
<td style="text-align: left;"><strong>栅—源</strong>+<strong>栅—漏 </strong><span class="math inline">\(C_{GCD}\)</span> 电容</td>
<td><span class="math inline">\(C_{ox}WL\)</span></td>
</tr>
<tr class="odd">
<td style="text-align: center;">饱和区</td>
<td style="text-align: left;"><strong>栅—源 </strong><span class="math inline">\(C_{GCS}\)</span>电容</td>
<td><span class="math inline">\(\frac{2}{3}C_{ox}WL\)</span></td>
</tr>
</tbody>
</table>
<p><span class="math display">\[
C_{GC}=C_{GCD}+C_{GCB}+C_{GCS}
\]</span></p>
<p><img src="https://cdn.staticaly.com/gh/peirsist/blog_img@master/image-20210421184251631.3uvmhlhrmbq0.webp" style="zoom:150%;"></p>
<h3 id="覆盖电容栅源栅漏">2. 覆盖电容(栅—源、栅—漏)</h3>
<table>
<thead>
<tr class="header">
<th>分布</th>
<th>符号</th>
<th>大小</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>栅—源</td>
<td><span class="math inline">\(C_{GSO}\)</span></td>
<td><span class="math inline">\(C_{ox}x_dW=C_oW\)</span></td>
</tr>
<tr class="even">
<td>栅—漏</td>
<td><span class="math inline">\(C_{GDO}\)</span></td>
<td><span class="math inline">\(C_{ox}x_dW=C_oW\)</span></td>
</tr>
</tbody>
</table>
<h3 id="结电容扩散电容">3. 结电容(扩散电容)</h3>
<table>
<thead>
<tr class="header">
<th></th>
<th>电容分布</th>
<th>大小</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>底板电容</td>
<td>源—衬底、漏—衬底</td>
<td><span class="math inline">\(C_jWL_s\)</span></td>
</tr>
<tr class="even">
<td>侧壁电容</td>
<td>源—衬底、漏—衬底</td>
<td><span class="math inline">\(C&#39;_{sw}x_j(2L_s+W)\)</span> <br> <span class="math inline">\(=C_{jsw}(2L_s+W)\)</span></td>
</tr>
</tbody>
</table>
<p><span class="math display">\[
C_{diff}= C_{bottom}+C_{sidewall}=C_j×面积+C_{jsw}×周长\\
\quad=C_jWL_s+C_{jsw}(2L_s+W)
\]</span></p>
<p><strong>注：</strong></p>
<table>
<thead>
<tr class="header">
<th>符号</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><span class="math inline">\(C_j\)</span></td>
<td>每单位面积的结电容</td>
</tr>
<tr class="even">
<td><span class="math inline">\(C_{jsw}\)</span></td>
<td><span class="math inline">\(sidewall\)</span>每单位周长的结电容</td>
</tr>
<tr class="odd">
<td></td>
<td></td>
</tr>
<tr class="even">
<td></td>
<td></td>
</tr>
</tbody>
</table>
]]></content>
      <categories>
        <category>硬件</category>
      </categories>
      <tags>
        <tag>MOS</tag>
      </tags>
  </entry>
  <entry>
    <title>数电</title>
    <url>/2021/05/21/%E6%99%B6%E4%BD%93%E7%AE%A1/%E6%95%B0%E7%94%B5/</url>
    <content><![CDATA[<h1 id="数电">数电</h1>
<p>请观看pdf</p>


	<div class="row">
    <embed src="数电.pdf" width="100%" height="550" type="application/pdf">
	</div>



<p>==注：此笔记结合课本、配套PPT看==</p>
<h2 id="第一章"><strong>第一章</strong></h2>
<h3 id="二进制数的补码"><strong>1. 二进制数的补码：</strong></h3>
<ol type="1">
<li>最高位为符号位（0为正，1为负）</li>
<li>正数的补码和它的原码相同</li>
<li>负数的补码=数值位迟位求反+1</li>
</ol>
<h3 id="为什么有这种原则"><strong>2. 为什么有这种原则？</strong></h3>
<ul>
<li>还是为了<span class="math inline">\(5+(-5)=0\)</span>可以实现</li>
</ul>
<p>编码的目的：区分信息和事物，为数字电路处理信息打基础</p>
<ul>
<li>0、1编码是为了信息处理，最后还要解码</li>
<li>在进入数字电路世界之前，要进行编码，编码的目的是把一个现实世界转换成二进制</li>
<li><img src="/.io//Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20210424095505689.png" title="fig:" alt="image-20210424095505689"></li>
</ul>
<h2 id="第二章-逻辑代数基础"><strong>第二章 逻辑代数基础</strong></h2>
<h3 id="学习重点"><strong>学习重点</strong></h3>
<ul>
<li>基本逻辑运算</li>
<li>公式表示方法</li>
<li>逻辑函数的化简</li>
</ul>
<h3 id="知识点"><strong>知识点</strong></h3>
<ul>
<li>香农提出了电子电路和0 1的关联</li>
</ul>
<p><img src="/.io//Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20210424100327691.png" alt="image-20210424100327691" style="zoom: 67%;"></p>
<ul>
<li><strong>基本公式和常见公式</strong></li>
<li>代入定理</li>
<li>反演定理(在逻辑代数中有一定意义，但在数字电路实现中，意义不大)</li>
</ul>
<p><img src="/.io//Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20210424205701745.png" alt="image-20210424205701745" style="zoom:50%;"></p>
<h3 id="逻辑代数描述方法"><strong>逻辑代数描述方法</strong></h3>
<ul>
<li><p>真值表——抽象度不高，但描述是确定的</p></li>
<li><p>逻辑式——表达最简洁</p></li>
<li><p>逻辑图——跟电路对应关系最好</p></li>
<li><p>波形图——实验室最容易得到</p></li>
<li><p>卡诺图</p></li>
<li><p>硬件描述语言</p>
<p><strong>同一中逻辑关系在不同形式下的编码方式</strong></p></li>
</ul>
<p>表示方法可以不同，但是对同一个逻辑关系来讲，是可以相互转化的</p>
<p><img src="/.io//Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20210424110606155.png" alt="image-20210424110606155" style="zoom:67%;"></p>
<p>根据搭建电路所需要的器件类型，对逻辑函数进行一定化简（德摩根+常用公式）</p>
<ul>
<li>真值表<span class="math inline">\(\Leftrightarrow\)</span>逻辑式 $ $</li>
<li>逻辑式<span class="math inline">\(\Leftrightarrow\)</span>逻辑图 <span class="math inline">\(\checkmark\)</span>
<ul>
<li>逻辑式<span class="math inline">\(\rightarrow\)</span>逻辑图，需要根据所有的门类型，对逻辑式进行转化</li>
<li>逻辑图<span class="math inline">\(\rightarrow\)</span>逻辑式，在分析中常用，拿到别人设计的电路图，想知道功能时
<ul>
<li>实验室</li>
<li>写出逻辑式</li>
</ul></li>
</ul></li>
<li>波形图<span class="math inline">\(\rightarrow\)</span>真值表 <span class="math inline">\(\checkmark\)</span>
<ul>
<li>要看波形图是否完整，要遍历所有值，波形图一列对应真值表一行</li>
</ul></li>
<li>波形图<span class="math inline">\(\rightarrow\)</span>逻辑式 <span class="math inline">\(\checkmark\)</span></li>
</ul>
<h3 id="逻辑函数两种标准形式">逻辑函数两种标准形式</h3>
<ul>
<li><p>最小项<span class="math inline">\(m\)</span>之和</p>
<ul>
<li>最小项是乘积项，值为<span class="math inline">\(1\)</span>，来源于真值表。<strong>与</strong>得<span class="math inline">\(0\)</span>容易，得<span class="math inline">\(1\)</span>难，得<span class="math inline">\(1\)</span>只对应一种情况，写<span class="math inline">\(1\)</span>的式子</li>
<li>有<span class="math inline">\(n\)</span>个变量，均以原变量与反变量的形式出现一次</li>
<li>最小项一定取了真值表的某一行</li>
<li>最小项编号的时候，以令最小项为<span class="math inline">\(1\)</span>的取值为编号，因为只有唯一一种情况，使最小项为<span class="math inline">\(1\)</span></li>
</ul>
<p><strong>最小项性质：</strong></p>
<ul>
<li>在任意输入变量取值下，有且仅有一个最小项为<span class="math inline">\(1\)</span></li>
<li>全体最小项之和为<span class="math inline">\(1\)</span></li>
<li>==<strong>任意两个最小项之积为<span class="math inline">\(0\)</span>。因为任何取值，无法使两个最小项同时为<span class="math inline">\(1\)</span></strong>==</li>
<li>==<strong>两个相邻的最小项之和可以合并</strong>==。<strong>相邻：仅有一个变量不同的最小项</strong></li>
</ul>
<p><img src="/.io//Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20210424205551903.png" alt="image-20210424205551903" style="zoom: 50%;"></p></li>
<li><p>最大项<span class="math inline">\(M\)</span>之积</p>
<ul>
<li>最大项是<strong>或</strong>项、相加项。<strong>或</strong>得<span class="math inline">\(1\)</span>容易，得<span class="math inline">\(0\)</span>难，得<span class="math inline">\(0\)</span>只对应一种情况，写<span class="math inline">\(0\)</span>的式子</li>
<li>一个最大项也对应真值表某一行</li>
<li>最大项编号的时候，以令最大项为<span class="math inline">\(0\)</span>的取值为编号，因为只有唯一一种情况，使最小项为<span class="math inline">\(0\)</span></li>
</ul>
<p><img src="/.io//Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20210424205111833.png" alt="image-20210424205111833" style="zoom: 50%;"></p></li>
</ul>
<p><img src="/.io//Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20210424205146673.png" alt="image-20210424205146673" style="zoom:50%;"></p>
<h3 id="卡诺图化简用对称展开的方式理解对称的方块都是相邻的">卡诺图化简（用对称展开的方式理解，<strong>对称的方块都是相邻的</strong>）</h3>
<ul>
<li><p>实质：将逻辑函数的最小项之和以图形方式表示</p></li>
<li><p>最小项用方块表示，逻辑相邻用几何相邻表示，<strong>运用了相邻最小项可以合并的原理</strong></p></li>
<li><p><img src="/.io//Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20210424205219633.png" alt="image-20210424205219633" style="zoom: 50%;"></p></li>
<li><p><img src="/.io//Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20210424205248745.png" alt="image-20210424205248745" style="zoom: 50%;"></p></li>
<li><p>卡诺图和真值表一样，逻辑式不写成最小项的形式，一样可以填卡诺图</p></li>
<li><p>画卡诺图不必把逻辑式化成最小项的形式，可以直接画</p>
<ul>
<li><p><span class="math inline">\(example:Y(A,B,C,D)=A&#39;B&#39;C&#39;D+A&#39;BD&#39;+AB&#39;\)</span></p>
<ul>
<li><span class="math inline">\(AB&#39;\)</span>对应<span class="math inline">\(4\)</span>个最小项：</li>
</ul>
<p><span class="math display">\[
\begin{align}
AB&#39;&amp; =  AB&#39;(C+C&#39;)=AB&#39;C+AB&#39;C&#39;\\
   &amp; =AB&#39;C(D+D&#39;)+AB&#39;C&#39;(D+D&#39;)\\
   &amp; =AB&#39;CD+AB&#39;CD&#39;+AB&#39;C&#39;D+AB&#39;C&#39;D&#39;\\
   &amp; = \sum(m_{11},m_{10},m_9,m_8)
\end{align}
\]</span></p>
<ul>
<li><span class="math inline">\(A&#39;BD&#39;\)</span>对应<span class="math inline">\(2\)</span>个最小项</li>
<li><span class="math inline">\(A&#39;B&#39;C&#39;D\)</span>对应<span class="math inline">\(1\)</span>个最小项</li>
</ul></li>
</ul></li>
</ul>
<p><img src="/.io//Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20210424152406666.png" alt="image-20210424152406666" style="zoom:50%;"></p>
<ul>
<li>合并最小项的原则：
<ul>
<li>两个相邻最小项可合并为一项，消去一对因子</li>
<li>四个排成矩形的相邻最小项可合并为一项，消去两对因子</li>
<li>八个相邻最小项可合并为一项，消去三对因子</li>
</ul></li>
<li>化简原则
<ul>
<li>圈尽可能地大('或'少)</li>
<li>一个圈包围的方块尽可能的多(‘与’少)</li>
</ul></li>
<li>两变量卡诺图最多可以含有<span class="math inline">\(2\)</span>个最小项，且不能化简</li>
<li>三变量卡诺图最多可以含有<span class="math inline">\(4\)</span>个最小项，且不能化简</li>
<li>四变量卡诺图最多可以含有<span class="math inline">\(8\)</span>个最小项，且不能化简(<strong>对折展开原理</strong>)</li>
<li>==一个逻辑函数如果可以表示成最小项之和，也一定能表达成最大项之积，而最小项和最大项的标号是<strong>互补</strong>的==</li>
</ul>
<h3 id="具有无关项的逻辑函数及其化简">具有无关项的逻辑函数及其化简</h3>
<ul>
<li><p><strong>约束项</strong>：逻辑函数中对输入变量的取值有限制，与这些被限制的取值对应的最小项称为约束项</p></li>
<li><p><strong>任意项</strong>：在输入变量某些取值下，函数值为1或0不影响逻辑电路的功能，与这些取值对应的最小项称为任意项</p></li>
<li><p><strong>无关项</strong>：约束项和任意项统称为无关项，它们可以写入逻辑式，也可以不写入逻辑式。</p></li>
<li><p>无关项是设计人员基于一定物理背景下的应用</p></li>
</ul>
<h2 id="第三章-门电路"><strong>第三章 门电路</strong></h2>
<h3 id="简单介绍"><strong>1. 简单介绍</strong></h3>
<ul>
<li><p>选择离散的电压信号（离散的电压序列）表示信息</p>
<ul>
<li><p>电压容易产生、测量</p></li>
<li><p>低功耗，有电压可以没电流</p></li>
<li><p>易受环境的影响</p></li>
<li><p>需要直流</p></li>
<li><p>电压遇到<span class="math inline">\(RC\)</span>网络慢</p></li>
</ul></li>
<li><p><strong>Voltage pros:</strong></p>
<ul>
<li>easy generation, detection</li>
<li>lots of engineering knowledge</li>
<li>potentially low power in steady state zero</li>
</ul></li>
<li><p><strong>Voltage cons:</strong></p></li>
<li><p>easily affected by environment</p></li>
<li><p>DC connectivity required?</p></li>
<li><p>R &amp; C effects slow things down</p></li>
</ul>
<p><img src="/.io//Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20210424195054922.png" alt="image-20210424195054922" style="zoom: 50%;"></p>
<ul>
<li><p><strong>Noise and inaccuracy are inevitable</strong>: we can't reliably reproduce infinite information--we must design our system to tolerate some amount of error if it is to process information reliably.</p></li>
<li><p>在模拟系统中，<span class="math inline">\(0.37和0.369\)</span>是不一样的，最后造成误差</p></li>
<li><p><strong>Why digital?</strong></p>
<ul>
<li>because it keeps the contracts simple. 可靠，具有<strong>tolerate some amount of error</strong>的能力</li>
<li><strong>But the price we pay for this robustness</strong>: All the information that we transfer between modules is only 1 crummy bit!</li>
</ul></li>
<li><p><span class="math inline">\(example:\)</span>要传<span class="math inline">\(0.37\mathrm{volt}\)</span>的信号，模拟系统中一根线就可以，而在数字系统中，要<span class="math inline">\(0.37\rightarrow\)</span>二进制(<span class="math inline">\(010100....\)</span>)</p>
<ul>
<li>要么多根线传输，牺牲空间</li>
<li>要么一根线，<span class="math inline">\(1bit、1bit\)</span>的传输，牺牲时间</li>
</ul></li>
<li><p>表面上<span class="math inline">\(0、1\)</span>，实际上传的还是电压信号，那为什么还能有tolerate some amount of error的能力？</p>
<ul>
<li>所有的数字器件必须签合同。</li>
<li><span class="math inline">\(Contract\)</span> : I will only output $1's $ and <span class="math inline">\(0&#39;s\)</span>. and they will be <span class="math inline">\(GOOD\)</span> <span class="math inline">\(1&#39;s\)</span> and <span class="math inline">\(0&#39;s\)</span>, Yet. I will tolerate inputs that are not quite up to my high standards.​</li>
</ul></li>
<li><p>Using Voltages "Digitally"</p>
<ul>
<li>Key idea: don't allow <span class="math inline">\(“0”\)</span> to be mistaken for a <span class="math inline">\(“1”\)</span> or vice versa</li>
<li><strong>Use the same "uniform representation convention" for every component</strong> <strong>and wire</strong> in our digital system to implement devices with high reliability, we outlaw "close calls" via a representation convention which forbids a range of voltages between "0" and "1"</li>
<li><img src="/.io//Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20210424203813475.png" alt="image-20210424203813475" style="zoom:67%;"></li>
</ul>
<h3 id="数字电路中也丢失了一些东西"><strong>数字电路中，也丢失了一些东西</strong></h3>
<ul>
<li>当逻辑函数的真值表从一行变到另一行的时候，每一行都是确定的值，但变化的时候每一个值都在经过<span class="math inline">\(Forbidden \ Zone\)</span>这个区。即只知道真值表（稳定时候的值），并不是每时每刻输出都有意义，逻辑代数没有描述非静态下的表达</li>
</ul></li>
<li><p><img src="/.io//Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20210424204945891.png" alt="image-20210424204945891" style="zoom:80%;"></p></li>
<li><p><span class="math inline">\(CMOS\)</span>制造工艺中，<span class="math inline">\(sio_2\)</span>层很薄，薄到要去数原子个数，所以很容易被击穿，因此要加保护电路</p></li>
<li><p>==<strong>输出低电平时，希望<span class="math inline">\(MOS\)</span>管工作在哪个区？</strong>==</p></li>
<li><figure>
<img src="/.io//Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20210426212511021.png" alt="image-20210426212511021"><figcaption aria-hidden="true">image-20210426212511021</figcaption>
</figure>
<ul>
<li>输出电平，导通的<span class="math inline">\(MOS\)</span>管起开关作用，目的是把<strong>"地"</strong>拉出来，起下拉的作用，希望在这个器件上的压降小，<strong>即<span class="math inline">\(v_{ds}\)</span>小，故<span class="math inline">\(MOS\)</span>管工作在线性区</strong></li>
</ul></li>
<li><p>所有的信号，只有流经电路，就一定会在时间上留下痕迹——==<strong>延迟</strong>==</p></li>
<li><p><span class="math inline">\(CMOS\)</span>反相器由于上下两个管子的互补特性，在给出了理想的高低电平的同时，也带来了一个问题：==<strong>在过渡区时，两个管子同时导通</strong>==，不是工作在我们所期望的截止区和线性电阻区，而是工作在恒流区，有一个==<strong>尖峰电流(是动态功耗的来源)，导致动态功耗一定不为0</strong>==。<span class="math inline">\(CMOS\)</span>反相器静态功耗近乎为0，动态功耗一定不为0。动态，即在<span class="math inline">\(0 \rightarrow1 \ and\ 1\rightarrow0\)</span>之间跳变的时候，尖峰电流是动态功耗的来源。</p></li>
<li><p>数字电路的电源电压<span class="math inline">\(V_{DD}\)</span>一直在下降，动态功耗会降低很多，因为动态功耗是数字电路主要的功耗。<strong>但降低电源电压，数字化的'0'和'1'会很接近</strong></p></li>
<li><p><span class="math inline">\(CMOS\)</span>电路原则</p>
<ul>
<li>由上拉(<span class="math inline">\(PMOS\)</span>)和下拉(<span class="math inline">\(NMOS\)</span>)两部分组成，上拉负责输出1，下拉负责输出0，上拉和下拉要覆盖真值表的所有行。</li>
<li>上拉和下拉不能同时导通</li>
<li>上拉由<span class="math inline">\(PMOS\)</span>构成，下拉由<span class="math inline">\(NMOS\)</span>构成，就注定了，上拉全由反变量控制(<span class="math inline">\(PMOS\)</span>由反变量控制)，下拉全由原变量控制</li>
</ul></li>
<li><p><span class="math inline">\(CMOS\)</span>器件在构成逻辑运算的时候，都是...非，不能直接得到与门，或门。因为<span class="math inline">\(NMOS\)</span>通过控制原变量，下拉出地，输出反变量。而与、或运算是逻辑原变量的运算，输出还是原变量。</p></li>
<li><p>串联拓扑结构天生代表逻辑'与'运算，并联拓扑结构天生代表逻辑'或'运算</p></li>
<li><p>==<strong>反相器是<span class="math inline">\(CMOS\)</span>电路中最小的逻辑单元</strong>==</p></li>
<li></li>
</ul>
<h2 id="第四章组合逻辑电路"><strong>第四章、组合逻辑电路</strong></h2>
<h3 id="看书和笔记"><strong>1. 看书和笔记</strong></h3>
<ul>
<li>编码器
<ul>
<li>普通编码器</li>
<li>优先编码器</li>
</ul></li>
<li>译码器</li>
<li>数据选择器</li>
<li>加法器</li>
<li>竞争—冒险</li>
</ul>
<figure>
<img src="/.io//Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20210515165122396.png" alt="image-20210515165122396"><figcaption aria-hidden="true">image-20210515165122396</figcaption>
</figure>
<figure>
<img src="/.io//Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20210515165529756.png" alt="image-20210515165529756"><figcaption aria-hidden="true">image-20210515165529756</figcaption>
</figure>
<ul>
<li>第一个图，当A，B=1时，出现了固定的竞争冒险，不是同时向相反变化偶然出现的。</li>
<li>当卡诺图中出现相切时，就会出现固定的竞争冒险现象。与Y=A+A'的方法一样。因为当出现相切的时候，就是一个变量在变的时候，就会有A和A接反相器的电路，出现时间差</li>
</ul>
<h3 id="eda工具"><strong>2. EDA工具</strong></h3>
<ul>
<li><img src="/.io//Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20210515170338966.png" title="fig:" alt="image-20210515170338966"></li>
</ul>
<figure>
<img src="/.io//Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20210515170702622.png" alt="image-20210515170702622"><figcaption aria-hidden="true">image-20210515170702622</figcaption>
</figure>
<ul>
<li><p>希望把所有的硬件连线等都放在芯片中，需要EDA工作来做</p></li>
<li><p>用EDA工具来设计，跟EDA配合使用的是可编程逻辑器件</p></li>
<li><p>器件</p>
<ul>
<li>门电路，通用性好</li>
<li>中规模器件，译码器、编码器等。都有自己的编号，功能表，不能改</li>
</ul></li>
<li><figure>
<img src="/.io//Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20210515171858606.png" alt="image-20210515171858606"><figcaption aria-hidden="true">image-20210515171858606</figcaption>
</figure></li>
<li><p>用一种语言来描述我们所要设计和实现的电路</p></li>
<li><figure>
<img src="/.io//Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20210515172544196.png" alt="image-20210515172544196"><figcaption aria-hidden="true">image-20210515172544196</figcaption>
</figure></li>
<li><p>将通用型和专用型结合起来</p>
<ul>
<li>厂家在生产的时候是通用的，成本低，时间短</li>
<li>芯片内部是自己定制的。在芯片内部放大量的门、运算器，如何连线，由用户定义</li>
</ul>
<figure>
<img src="/.io//Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20210515172847467.png" alt="image-20210515172847467"><figcaption aria-hidden="true">image-20210515172847467</figcaption>
</figure></li>
<li><p>在用通用型器件时，最烦的就是器件之间的连线</p></li>
<li><p>可编程逻辑器件就像一个电子面包板，在器件的内部，准备好了大量的数字电路的基本模块，而基本模块的连接由EDA工具连接--------逻辑综合，把一个电路的描述和电路的实现挂钩</p></li>
<li><figure>
<img src="/.io//Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20210515173602836.png" alt="image-20210515173602836"><figcaption aria-hidden="true">image-20210515173602836</figcaption>
</figure></li>
<li><p>逻辑综合类似于：高级语言到机器码，由编译器完成。硬件描述语言描述的电路到电路连接实现，由EDA工具完成。我的描述告诉电路------&gt;电路进行综合-------&gt;电路告诉芯片</p></li>
<li><figure>
<img src="/.io//Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20210515174309350.png" alt="image-20210515174309350"><figcaption aria-hidden="true">image-20210515174309350</figcaption>
</figure></li>
</ul>
<figure>
<img src="/.io//Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20210515174707872.png" alt="image-20210515174707872"><figcaption aria-hidden="true">image-20210515174707872</figcaption>
</figure>
<figure>
<img src="/.io//Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20210515175202228.png" alt="image-20210515175202228"><figcaption aria-hidden="true">image-20210515175202228</figcaption>
</figure>
<ul>
<li>硬件描述语言，写的程序看似有前有后，一逻辑综合完，就没有顺序，所有输入都被拉到前面，并行</li>
<li><img src="/.io//Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20210515175708834.png" title="fig:" alt="image-20210515175708834"></li>
</ul>
<figure>
<img src="/.io//Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20210515175905095.png" alt="image-20210515175905095"><figcaption aria-hidden="true">image-20210515175905095</figcaption>
</figure>
<figure>
<img src="/.io//Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20210515180025891.png" alt="image-20210515180025891"><figcaption aria-hidden="true">image-20210515180025891</figcaption>
</figure>
<figure>
<img src="/.io//Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20210515180226919.png" alt="image-20210515180226919"><figcaption aria-hidden="true">image-20210515180226919</figcaption>
</figure>
<ul>
<li>微电子行业的人喜欢用verilog</li>
<li>可编程逻辑器件的人喜欢用VHDL，因为侧重从上往下，并不关心电路是如何实现的</li>
<li>Verilog偏底层，VHDL系统级</li>
<li><img src="/.io//Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20210515181027954.png" title="fig:" alt="image-20210515181027954"></li>
</ul>
<h2 id="第五章-时序逻辑电路"><strong>第五章 时序逻辑电路</strong></h2>
<figure>
<img src="/.io//Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20210515181120392.png" alt="image-20210515181120392"><figcaption aria-hidden="true">image-20210515181120392</figcaption>
</figure>
<figure>
<img src="/.io//Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20210515203541206.png" alt="image-20210515203541206"><figcaption aria-hidden="true">image-20210515203541206</figcaption>
</figure>
<figure>
<img src="/.io//Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20210515204224905.png" alt="image-20210515204224905"><figcaption aria-hidden="true">image-20210515204224905</figcaption>
</figure>
<ul>
<li><p>时序逻辑电路中，不是所有信号都是有效信号，当认为是有效信号时，才开启load存入记忆系统</p></li>
<li><figure>
<img src="/.io//Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20210515210523093.png" alt="image-20210515210523093"><figcaption aria-hidden="true">image-20210515210523093</figcaption>
</figure></li>
<li><p>上图这个电路没有输入，不能把0、1放进去。要把输入引出来，但反相器没发引</p></li>
</ul>
<figure>
<img src="/.io//Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20210517095836570.png" alt="image-20210517095836570"><figcaption aria-hidden="true">image-20210517095836570</figcaption>
</figure>
<figure>
<img src="/.io//Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20210517095911924.png" alt="image-20210517095911924"><figcaption aria-hidden="true">image-20210517095911924</figcaption>
</figure>
<figure>
<img src="/.io//Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20210517101045077.png" alt="image-20210517101045077"><figcaption aria-hidden="true">image-20210517101045077</figcaption>
</figure>
<ul>
<li>通过两条反馈线，与S=1, R=1的情况相与，变成S=0, R=1或S=1,R=0的信号，避免了SR同时为1</li>
<li>==<span class="math inline">\(Q:\)</span>但这两条反馈线对<span class="math inline">\(SR\  flip-flop\)</span>的<strong>置1、置0、保持</strong>功能有影响吗？==</li>
</ul>
<p>​</p>
]]></content>
      <categories>
        <category>硬件</category>
      </categories>
      <tags>
        <tag>数电</tag>
      </tags>
  </entry>
  <entry>
    <title>什么是机器学习</title>
    <url>/2022/10/21/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/00.%E4%BB%80%E4%B9%88%E6%98%AF%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h2 id="机器学习相关的链接">机器学习相关的链接</h2>
<ul>
<li><a href="https://blog.csdn.net/gongxifacai_believe/category_6834186.html">Machine Learning_魏晓蕾的博客-CSDN博客</a><mark>前辈们做的机器学习笔记</mark></li>
<li><a href="https://nndl.github.io/">神经网络与深度学习-邱锡鹏</a></li>
<li><a href="https://github.com/songyingxin/NLPer-Interview">数学基础、机器学习</a></li>
<li><a href="https://zh-v2.d2l.ai/index.html">《动手学深度学习》 — 动手学深度学习 2.0.0-beta0 documentation (d2l.ai)</a></li>
<li><a href="https://blog.csdn.net/a1015553840/article/details/51085129#reply">機器學習基石(Machine Learning Foundations) 机器学习基石 课后习题链接汇总_Mac Jiang的博客-CSDN博客</a></li>
</ul>
<h2 id="如何学习">如何学习</h2>
<p>好了废话不多说，我们进入入门阶段的正题。入门阶段主要有三个任务：</p>
<ul>
<li>快速看完周志华的《西瓜书》；</li>
<li>看吴恩达 Coursera 上的《机器学习》；</li>
<li>调包跑算法。</li>
</ul>
<div class="tip">
<ul>
<li><a href="https://zhuanlan.zhihu.com/p/112484706">如何快速入门机器学习</a></li>
</ul>
</div>
<h2 id="什么是机器学习">什么是机器学习</h2>
<p>机器学习算法主要的两种类型被称之为监督学习和无监督学习。</p>
<h3 id="监督学习"><strong>监督学习</strong></h3>
<ul>
<li><strong>监督学习</strong> 就是我们给学习算法的一个数据集。<strong>这个数据集由“正确答案”组成</strong> 。在这个例子中，我们给出了一系列房子的数据，从给定的数据集中每个样本的真实售价，<strong>然后运用学习算法，算出更多的正确答案</strong> 。这就叫做 <strong>回归问题</strong>。
<ul>
<li><strong>回归问题</strong> 就是通过离散的数据来推测出一个连续的输出。</li>
<li><strong>分类问题</strong> 的目标是推测出一组离散的结果。</li>
</ul></li>
</ul>
<h3 id="无监督学习"><strong>无监督学习</strong></h3>
<ul>
<li><strong>无监督学习</strong> 中没有任何标签或者所有数据的标签都是一样的。这样就不知道如何处理数据，也不知道每个数据点是什么。只知道，这是一个数据集。针对数据集，无监督学习，能够判断出数据有两个不同的聚集簇。二者不同，无监督学习算法可能会把这些数据分成两个不同的簇，所以这叫做聚类算法。可以应用的地方很多。</li>
<li>我们只有一堆数据，不知道数据中有什么东西，不知道什么人是什么类型，甚至不知道有哪几种类型，类型是什么。我们要自动的把个体会聚集到某个类。</li>
</ul>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
  </entry>
  <entry>
    <title>思想政治</title>
    <url>/2022/11/04/%E5%85%9A%E5%8F%B2%E5%AD%A6%E4%B9%A0/%E6%80%9D%E6%83%B3%E6%94%BF%E6%B2%BB%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<p><a href="https://epaper.gmw.cn/wzb/html/2020-07/14/nw.D110000wzb_20200714_6-06.htm">“历史周期率”的破解之道-文摘报-光明网 (gmw.cn)</a></p>
<p><a href="http://dangshi.people.com.cn/n1/2019/1015/c85037-31401607.html">中国共产党对破解历史周期律的探索与实践--党史频道-人民网 (people.com.cn)</a></p>
<p>“历史周期率”是指一个国家的政权往往会经历兴衰治乱，往复循环呈现出的周期性现象。中国共产党的历史周期率问题，是1945年7月黄炎培先生到延安考察向毛泽东提出的问题。</p>
<p>在回顾封建王朝的兴衰更替史的基础上，习近平总书记指出，有些封建王朝开始时顺乎潮流、民心归附，尚能励精图治、以图中兴，遂致功业大成、天下太平，但都未能摆脱盛极而衰的历史悲剧。导致悲剧的原因很多，其中一个共同的也是极其重要的原因就是统治集团贪图享乐、穷奢极欲，昏庸无道、荒淫无耻，吏治腐败、权以贿成，又自己解决不了自己的问题，搞得民不聊生、祸乱并生，终致改朝换代。</p>
<p>以史为鉴可以知兴替。我们党对历史兴亡、王朝兴替一直有着深刻的认识和警醒。之所以反复强调“历史周期率”问题，就是为了告诫全党，任何一个政权，建立不容易，保持兴旺发达、长治久安，也不容易。如果不自省、不警惕、不努力，再强大的政权都可能走到人亡政息的穷途末路。这个道理就是著名的“四个不容易”：</p>
<ol type="1">
<li>功成名就时做到居安思危、保持创业初期那种励精图治的精神状态不容易</li>
<li>执掌政权后做到节俭内敛、敬终如始不容易</li>
<li>承平时期严以治吏、防腐戒奢不容易</li>
<li>重大变革关头顺乎潮流、顺应民心不容易</li>
</ol>
<p>这“四个不容易”是新时代中国共产党人深沉的历史忧患，又体现了新时代中国共产党人一贯的政治清醒，更是彰显了新时代中国共产党人强烈的责任担当，言简意赅、语重心长。</p>
]]></content>
      <tags>
        <tag>党史学习</tag>
      </tags>
  </entry>
  <entry>
    <title>机器学习资料链接</title>
    <url>/2022/10/23/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/00%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%80%BB/</url>
    <content><![CDATA[<h2 id="1-数学基础"><a href="#1-数学基础" class="headerlink" title="1. 数学基础"></a><strong>1. 数学基础</strong></h2><ol>
<li>老齐课程，<a href="http://www.itdiffer.com/">首页 · 老齐教室 (itdiffer.com)</a><ul>
<li><strong><a href="http://math.itdiffer.com/">本书说明 · 机器学习数学基础 (itdiffer.com)</a></strong></li>
<li><strong><a href="https://www.bilibili.com/video/BV1QG411t72j/?spm_id_from=333.788&vd_source=83831fc0970a6c8704479f7cfc679937">如何度量距离_哔哩哔哩_bilibili</a></strong></li>
</ul>
</li>
<li><a href="https://www.bilibili.com/video/BV1pb411u7t1?spm_id_from=333.999.0.0">线性代数基础课程【小元老师】【超级0基础入门】</a></li>
<li><a href="https://www.bilibili.com/video/BV1ib411t7YR?spm_id_from=333.999.0.0">线性代数的本质</a></li>
<li><a href="https://www.bilibili.com/video/BV14b411M7Jn?spm_id_from=333.999.0.0">概率论与数理统计知识详解【小元老师】【考研数学】</a></li>
<li><a href="https://www.bilibili.com/video/BV1ys411472E?spm_id_from=333.999.0.0">【官方双语&#x2F;合集】线性代数的本质 - 系列合集</a></li>
<li><a href="https://cloud.tencent.com/developer/article/1729545">非常适合初学者的机器学习的数学基础专辑（pdf下载）</a></li>
<li><a href="https://cloud.tencent.com/developer/article/1843235?from=article.detail.1729545">建议初学者收藏的机器学习初学者手抄本：数学基础、机器学习经典算法、统计学习方法等</a></li>
<li>机器学习数学基础pdf<ul>
<li><a href="https://zhuanlan.zhihu.com/p/104986706">《机器学习数学基础》已开源，附完整下载！ - 知乎 (zhihu.com)</a></li>
<li><a href="https://mml-book.github.io/">Mathematics for Machine Learning | Companion webpage to the book “Mathematics for Machine Learning”.</a></li>
</ul>
</li>
</ol>
<h2 id="2-机器学习"><a href="#2-机器学习" class="headerlink" title="2. 机器学习"></a><strong>2. 机器学习</strong></h2><ol>
<li>🔗<a href="/2022/07/21/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/00Tra_ML/02.%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92/" title="线性回归">线性回归</a></li>
</ol>
<ul>
<li><a href="https://blog.csdn.net/gongxifacai_believe/category_6834186.html">Machine Learning_魏晓蕾的博客-CSDN博客</a><mark>前辈们做的机器学习笔记</mark></li>
<li><a href="https://www.bilibili.com/video/BV1jS4y1j74C?spm_id_from=333.999.0.0">机器学习之路【b站UP主】</a></li>
</ul>
<ol>
<li><a href="https://www.bilibili.com/video/BV1Cx411i7op?spm_id_from=333.999.0.0">林轩田机器学习基石(国语)</a></li>
<li><strong><a href="https://www.bilibili.com/video/BV1aE411o7qd?spm_id_from=333.337.search-card.all.click">【白板推导系列】【合集 1～33】</a></strong></li>
<li><a href="https://www.bilibili.com/video/BV1eT4y1E73x?spm_id_from=333.999.0.0">【手推机器学习】矩阵求导7–最小二乘法举例</a></li>
<li><a href="https://www.bilibili.com/video/BV1ZM4y1w75P?spm_id_from=333.999.0.0">【神经网络】BP误差逆传播算法数学推导</a></li>
<li><a href="https://www.bilibili.com/video/BV13J41157Wq?spm_id_from=333.999.0.0">5字诀搞定BP反向传播算法推导</a></li>
<li><a href="https://github.com/dragen1860/Deep-Learning-with-TensorFlow-book">dragen1860&#x2F;Deep-Learning-with-TensorFlow-book: 深度学习入门开源书，基于TensorFlow 2.0案例实战。</a></li>
<li><a href="https://christophm.github.io/interpretable-ml-book/preface-by-the-author.html">【英文】机器学习可解释性| Interpretable Machine Learning (christophm.github.io)</a></li>
<li></li>
</ol>
<h2 id="3-深度学习"><a href="#3-深度学习" class="headerlink" title="3. 深度学习"></a><strong>3. 深度学习</strong></h2><ol>
<li><strong><a href="https://www.bilibili.com/video/BV1if4y147hS?spm_id_from=333.999.0.0">动手学深度学习【李沐大神】</a></strong></li>
<li><a href="/2022/10/16/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/05DL/CNN/" title="CNN">🔗CNN</a></li>
</ol>
<h2 id="4-强化学习"><a href="#4-强化学习" class="headerlink" title="4. 强化学习"></a><strong>4. 强化学习</strong></h2><ol>
<li><strong>🔗<a href="%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/03RL/02RL%E4%BB%8B%E7%BB%8D.md">第1节什么是强化学习?-北邮-鲁鹏老师</a></strong></li>
<li><a href="https://blog.csdn.net/SMALL_RL/article/details/123380320">强化学习 (Reinforcement Learning) 基础及论文资料汇总</a></li>
<li><a href="https://www.bilibili.com/video/BV13W411Y75P?spm_id_from=333.999.0.0">【莫烦Python】强化学习 Reinforcement Learning</a></li>
<li><a href="https://www.bilibili.com/video/BV16Y4y1M7DX?spm_id_from=333.999.0.0">强化学习基础 （本科生课程） 北京邮电大学 鲁鹏</a></li>
<li><a href="https://www.bilibili.com/video/BV1XP4y1d7Bk?spm_id_from=333.999.0.0">李宏毅</a></li>
<li><a href="https://www.bilibili.com/video/BV1rv41167yx/?spm_id_from=333.1007.top_right_bar_window_history.content.click&vd_source=83831fc0970a6c8704479f7cfc679937">深度强化学习（全）_哔哩哔哩_bilibili</a></li>
<li><a href="https://www.bilibili.com/video/BV1CB4y1G777/?spm_id_from=333.1007.top_right_bar_window_history.content.click&vd_source=83831fc0970a6c8704479f7cfc679937">【RLChina 2022】前沿进展五：应用多智能体强化学习解决现实问题——机遇和挑战 方飞_哔哩哔哩_bilibili</a></li>
<li><a href="https://www.bilibili.com/video/BV1vG4y1n7Rp/?spm_id_from=333.880.my_history.page.click&vd_source=83831fc0970a6c8704479f7cfc679937">强化学习论文分享2022-10-13_哔哩哔哩_bilibili</a></li>
<li></li>
</ol>
<h2 id="CV"><a href="#CV" class="headerlink" title="CV"></a><strong>CV</strong></h2><p><a href="https://www.bilibili.com/video/BV1Xb411U79J?spm_id_from=333.999.0.0">数字图像处理</a></p>
<p>20220927</p>
<ul>
<li><a href="https://blog.csdn.net/weixin_43614795/article/details/84350463">理解 假阳性（false positive）和假阴性(false negative）概念_人间清欢的博客-CSDN博客_false positive</a></li>
<li><a href="https://www.jianshu.com/p/f8e5ee346ec9">假阳性错误和假阴性错误——笔记 - 简书 (jianshu.com)</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/443547881">机器学习VS深度学习：有什么区别？ - 知乎 (zhihu.com)</a></li>
<li></li>
</ul>
<p>机器学习手册分为三个部分，<strong>数学基础</strong>、<strong>机器学习经典算法</strong>、<strong>统计学习方法</strong>。建议有时间的同学可以这三个部分<strong>按照顺序学习</strong>，时间少的同学，我建议直接看机器学习经典算法，遇到问题查一下数学基础，也可以一边看机器学习经典算法，一边看统计学习方法，查漏补缺。</p>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>链接</tag>
      </tags>
  </entry>
  <entry>
    <title>机器学习数学基础</title>
    <url>/2022/10/23/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h2 id="内积空间">内积空间</h2>
<p><strong>点积</strong>是<strong>内积</strong>的具体表现形式之一。</p>
<p><span class="math display">\[&lt;\vec{u},\vec{v}&gt; = \vec{u} \cdot \vec{v} = u_1v_1+...+u_nv_n\]</span></p>
<p>只有把内积定义成点积的时候，<strong>内积空间</strong>才叫做<strong>欧几里得空间</strong>或<strong>欧式空间</strong>。</p>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
  </entry>
  <entry>
    <title>侯捷C++面向对象(上)</title>
    <url>/2022/05/21/%E7%BC%96%E7%A8%8B/1.%E4%BE%AF%E6%8D%B7C++%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</url>
    <content><![CDATA[<h2 id="侯捷c面向对象"><strong>侯捷C++面向对象</strong></h2>
<p>很喜欢这种娓娓道来的讲课，而不是填鸭式的灌输知识点，对零碎的知识点特此记录。</p>
<blockquote>
<p><strong><font color="red">培养正规的、大气的编程习惯</font></strong></p>
</blockquote>
<p><code>class</code>是C++中最重要的，侯捷老师：“<strong>一个人写了一个<code>class</code>，看他是否受过良好的、正规的训练，看以下几点</strong>：”</p>
<!-- - 数据成员用`private`，成员函数大部分`public`
- 构造函数使用初始化列表的方式初始化。`initialization list`，并且要写默认值。
- 参数传递是`by value`还是`by reference`，同时考虑是否加`const`。尽可能的用`by reference`
- 函数返回值是`return by value`还是`return by reference`，同时考虑是否加`const`。尽可能的用`return by reference` -->
<ul>
<li>数据成员用<code>private</code>，成员函数大部分<code>public</code></li>
<li>构造函数使用初始化列表的方式初始化。<code>initialization list</code>，并且要写默认值。</li>
<li>参数传递是<code>by value</code>还是<code>by reference</code>，同时考虑是否加<code>const</code>。尽可能的用<code>by reference</code></li>
<li>函数返回值是<code>return by value</code>还是<code>return by reference</code>，同时考虑是否加<code>const</code>。尽可能的用<code>return by reference</code></li>
<li>对于一个函数本身，考虑是否加<code>const</code></li>
</ul>
<hr>
<p>知识点总结：</p>
<!-- > 1. `inline`函数，若函数在`class body`内定义，便自动能为`inline`函数**候选人**，函数外要加`inline`关键字，但究竟能不能成为`inline`函数，由编译器决定。`inline`函数像宏一样，有它的特性，但是没有它的缺点，`inline`函数执行速度很快。
> 2. 构造函数初始化要使用**初始化列表**的方式，不要用`assign`赋值的方式。数值的设定有两个阶段：先是初始化，再是赋值。构造函数可以`overloading`，**函数重载**，但是在编译器看来是不重名的。
> 3. `class`有带指针的，有不带指针的，不带指针的`class`多半不用写析构函数。
> 4. `class`中的函数有两种：改变成员数据的和不改变成员数据的，不改变成员数据的函数要加`const`
> 5. 参数传递尽可能的使用**引用**（`pass by reference`），**不要传值**（`pass by value`），因为`pass by value`是**整包**传过去，速度慢，而C语言中有指针，可以传首地址过去，加快了速度，C++中多了**引用**（`pass by reference`），拥有指针一样的特性（底层就是指针），但是更漂亮。指针和引用传到另一个函数里，改变值，本体也变了，但是如果传引用只是为了速度更快，不想改变值，加上`const`关键字。
> 6. 同样，函数返回值类型同样用引用（return by reference）。**传递者无需知道接受者试试以什么样的形式接收。**返回`value`可以用`value`接收，也可以用`reference`接收。而指针一定要有指针类型去接收。
> 7. `reference`作函数返回值类型，作参数传递，这些是很小的细节，但是影响效率。
>
>  -->
<ol type="1">
<li>inline函数，若函数在<code>class body</code>内定义，便自动能为<code>inline</code>函数<strong>候选人</strong>，函数外要加<code>inline</code>关键字，但究竟能不能成为<code>inline</code>函数，由编译器决定。<code>inline</code>函数像宏一样，有它的特性，但是没有它的缺点，<code>inline</code>函数执行速度很快。</li>
<li>构造函数初始化要使用<strong>初始化列表</strong>的方式，不要用<code>assign</code>赋值的方式。数值的设定有两个阶段：先是初始化，再是赋值。构造函数可以<code>overloading</code>，<strong>函数重载</strong>，但是在编译器看来是不重名的。</li>
<li><code>class</code>有带指针的，有不带指针的，不带指针的<code>class</code>多半不用写析构函数。</li>
<li><code>class</code>中的函数有两种：改变成员数据的和不改变成员数据的，不改变成员数据的函数要加<code>const</code></li>
<li>参数传递尽可能的使用<strong>引用</strong>（<code>pass by reference</code>），<strong>不要传值</strong>（<code>pass by value</code>），因为<code>pass by value</code>是<strong>整包</strong>传过去，速度慢，而C语言中有指针，可以传首地址过去，加快了速度，C++中多了<strong>引用</strong>（<code>pass by reference</code>），拥有指针一样的特性（底层就是指针），但是更漂亮。指针和引用传到另一个函数里，改变值，本体也变了，但是如果传引用只是为了速度更快，不想改变值，加上<code>const</code>关键字。</li>
<li>同样，函数返回值类型同样用引用（return by reference）。<strong>传递者无需知道接受者试试以什么样的形式接收。</strong>返回<code>value</code>可以用<code>value</code>接收，也可以用<code>reference</code>接收。而指针一定要有指针类型去接收。</li>
<li><code>reference</code>作函数返回值类型，作参数传递，这些是很小的细节，但是影响效率。</li>
<li></li>
</ol>
]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++-毕设</title>
    <url>/2022/04/21/%E7%BC%96%E7%A8%8B/C++/</url>
    <content><![CDATA[<h2 id="cc">C/C++</h2>
<h3 id="c基础知识">C++基础知识</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pdf/C++语法.pdf</span><br></pre></td></tr></table></figure>
<h3 id="基本语法">基本语法</h3>
<ol type="1">
<li><a href="http://c.biancheng.net/cpp/html/295.html"><font face="Monaco">sprintf()</font>函数：将格式化的数据写入字符串_C语言中文网</a>
<ul>
<li><font face="Monaco"><code>sprintf()</code></font>的作用是将一个格式化的字符串输出到一个<strong>目的字符串</strong>中，而<font face="Monaco"><code>printf()</code></font>是将一个格式化的字符串<strong>输出到屏幕</strong>。</li>
<li><font face="Monaco"><code>int sprintf(char *str, char * format [, argument, ...])</code></font>。<font face="Monaco">str</font>为要写入的字符串；<font face="Monaco">format</font>为格式化字符串，与<font face="Monaco"><code>printf()</code></font>函数相同；<font face="Monaco">argument</font>为变量。</li>
</ul></li>
<li><a href="http://c.biancheng.net/cpp/html/2522.html"><font face="Monaco">fscanf()</font>函数：将文件流中的数据格式化输入_C语言中文网</a></li>
<li><a href="https://blog.csdn.net/qq_19784349/article/details/82927169">C++基础之<strong>uint8_t</strong>_时光机 °的博客-CSDN博客</a></li>
<li><a href="https://blog.csdn.net/Mary19920410/article/details/71518130">浅析C语言之uint8_t / uint16_t / uint32_t /uint64_t_海阔天空sky的博客-CSDN博客</a></li>
<li><a href="https://blog.csdn.net/weixin_41106545/article/details/83213354?spm=1001.2101.3001.6650.6&amp;utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~Rate-6.pc_relevant_default&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~Rate-6.pc_relevant_default&amp;utm_relevant_index=8">求一个数组中出现次数超过n/3的数(C++实现)_zhanyue666的博客-CSDN博客</a></li>
<li><a href="https://blog.csdn.net/xiangguang_fight/article/details/114839642?spm=1001.2101.3001.6650.8&amp;utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~Rate-8.pc_relevant_default&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~Rate-8.pc_relevant_default&amp;utm_relevant_index=10">开学回归力扣：第十二题—— 229. 求众数 II（摩尔投票法）_xiangguang_fight的博客-CSDN博客</a></li>
<li></li>
</ol>
<hr>
<h3 id="毕设遇到的编程问题">毕设遇到的编程问题：</h3>
<p>2021年3月24日</p>
<ul>
<li><p><a href="https://blog.csdn.net/weixin_30684945/article/details/117078693?spm=1001.2101.3001.6661.1&amp;utm_medium=distribute.pc_relevant_t0.none-task-blog-2~default~CTRLIST~Rate-1.pc_relevant_antiscanv2&amp;depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2~default~CTRLIST~Rate-1.pc_relevant_antiscanv2&amp;utm_relevant_index=1">C语言全局变量多个cpp,c++多个文件中共用一个全局变量 变量跨文件使用_李勖晟的博客-CSDN博客</a></p></li>
<li><p><a href="https://blog.csdn.net/qq_27942333/article/details/84719737">C++将一个cpp文件中的变量应用到另一个cpp文件中_公子恒的博客-CSDN博客</a></p></li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> i; <span class="comment">//声明并定义 </span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> i; <span class="comment">//声明 </span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> i=<span class="number">10</span>; <span class="comment">//定义 </span></span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">f</span><span class="params">()</span>; <span class="comment">//声明 </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">f</span><span class="params">()</span> &#123;&#125;; <span class="comment">//定义</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p><a href="http://c.biancheng.net/view/1345.html">C++ getline函数用法详解 (biancheng.net)</a></p></li>
<li><p><a href="https://www.runoob.com/cprogramming/c-function-strcpy.html">C 库函数 – strcpy() | 菜鸟教程 (runoob.com)</a></p></li>
<li><p><a href="https://blog.csdn.net/qq_41282102/article/details/82695562">string中c_str()的用法_Lemonbr的博客-CSDN博客_string.c_str</a></p></li>
<li><p><a href="https://www.cnblogs.com/QG-whz/p/4509710.html">C++强制类型转换操作符 static_cast - melonstreet - 博客园 (cnblogs.com)</a></p></li>
<li><p><a href="https://zhuanlan.zhihu.com/p/33040213">C++类型转换之reinterpret_cast - 知乎 (zhihu.com)</a></p></li>
<li><p><a href="https://blog.csdn.net/qq_39779233/article/details/107585014">C++ 报错 error: ‘xxx’ was not declared in this scope_wongHome的博客-CSDN博客</a></p></li>
<li><p><a href="https://blog.csdn.net/silentob/article/details/76994618">const char * 、char const <em>、 char </em> const 三者的区别_SilentOB的博客</a></p></li>
<li><p><a href="https://blog.csdn.net/zhang_alongzd/article/details/52790905">C++中const char<em>, string 与char</em>的转化_风居住de街道的博客-CSDN博客</a></p></li>
<li><p><a href="https://www.cnblogs.com/tsingke/p/12075078.html">C++ 中 string和char* 的区别 - Tsingke - 博客园 (cnblogs.com)</a></p></li>
<li><p><a href="https://blog.csdn.net/qq_37368095/article/details/88525204?spm=1001.2101.3001.6650.1&amp;utm_medium=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-1.pc_relevant_default&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-1.pc_relevant_default&amp;utm_relevant_index=2">C++ 内存溢出&amp;内存泄漏_AiChiMomo.的博客-CSDN博客_c++ 内存溢出</a></p></li>
<li><p><a href="https://blog.csdn.net/Retrovich/article/details/84623641?spm=1035.2023.3001.6557&amp;utm_medium=distribute.pc_relevant_bbs_down_v2.none-task-blog-2~default~OPENSEARCH~Rate-8.pc_relevant_bbs_down_v2_default&amp;depth_1-utm_source=distribute.pc_relevant_bbs_down_v2.none-task-blog-2~default~OPENSEARCH~Rate-8.pc_relevant_bbs_down_v2_default">从缓冲系统文件到常见栈溢出函数_Retrovich的博客-CSDN博客_函数栈溢出</a></p></li>
<li><p><a href="https://bbs.csdn.net/topics/390681492">文件读写完后fclose（）就内存溢出-CSDN社区</a></p></li>
<li><p><strong><a href="https://blog.csdn.net/renyuxiaomei/article/details/78439864">C语言自定义函数如何返回数组_renyuxiaomei的博客-CSDN博客_返回数组的函数怎么写</a></strong></p></li>
<li><p><a href="https://blog.csdn.net/gavechan/article/details/45542913">用数组作为函数返回值_Gavechan的博客-CSDN博客_数组作为返回值</a></p></li>
<li><p><a href="https://blog.csdn.net/ac1085589289/article/details/85077580">错误信息was not declared in this scope</a></p></li>
</ul>
<p>-<a href="https://blog.csdn.net/sergery/article/details/8144731">C++, 想要使用string ,必须要用命名空间 std</a></p>
<hr>
<h3 id="c生成随机数">C++生成随机数？</h3>
<ul>
<li><a href="https://blog.csdn.net/on_june_7th/article/details/120392619">C++产生随机数_on_june_7th的博客-CSDN博客_c++随机数</a></li>
<li><a href="https://blog.csdn.net/cmm0401/article/details/54599083">C++中rand()函数的用法_风暴计划的博客-CSDN博客_c++ rand()</a></li>
<li><a href="https://blog.csdn.net/weixin_40539125/article/details/82721340">C++寻找数组最大值和最小值_Jeff_的博客-CSDN博客_c++求数组中的最大值和最小值</a></li>
</ul>
<p><strong><code>rand()</code></strong> 不需要参数，它会返回一个从 <strong><code>0</code></strong> 到最大随机数的任意整数，最大随机数的大小通常是固定的一个大整数。<strong><code>int num = rand() % 100</code></strong> ; 所以，num的值就是一个 <strong><code>0~99</code></strong> 中的一个随机数了。</p>
<p>如果要产生 <strong><code>1~100</code></strong> ，则是这样：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> num = <span class="built_in">rand</span>() % <span class="number">100</span> + <span class="number">1</span>; </span><br></pre></td></tr></table></figure>
<p><strong>总结来说</strong>，可以表示为： <strong><code>int num = rand() % n +a</code></strong>; 其中的 <strong><code>a</code></strong> 是起始值， <strong><code>n-1+a</code></strong> 是终止值， <strong><code>n</code></strong> 是整数的范围。</p>
<p><strong>一般性</strong> ：<code>rand() % (b-a+1)+ a</code>; 就表示 <strong><code>a~b</code></strong> 之间的一个随机整数。</p>
<p>若要产生 <strong><code>0-1</code></strong> 之间的小数，则可以先取得 <code>0-10</code>的整数，然后均除以 <strong><code>10</code></strong> 即可得到“随机到十分位”的 <strong><code>10</code></strong> 个随机小数。</p>
<p>通常 <strong><code>rand()</code></strong> 产生的随机数在每次运行的时候都是与上一次相同的，这样是为了便于程序的调试。</p>
<p>若要产生每次不同的随机数，则可以使用 <strong><code>srand( seed )</code></strong> 函数进行产生随机化种子，随着seed的不同，就能够产生 不同的随机数。</p>
]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C-C3程序猿</title>
    <url>/2021/09/21/%E7%BC%96%E7%A8%8B/C%E8%AF%AD%E8%A8%80/</url>
    <content><![CDATA[<h2 id="看c3程序员c视频的一些笔记">看c3程序员C++视频的一些笔记</h2>
<ul>
<li><a href="https://www.cnblogs.com/edisonchou/p/4669098.html">你必须知道的指针基础-8.栈空间与堆空间 - EdisonZhou - 博客园 (cnblogs.com)</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/165992745">C++中::和:， .和-&gt;的作用和区别? - 知乎 (zhihu.com)</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/141437664">static与const - 知乎 (zhihu.com)</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/141113043">一文带你了解static 和const - 知乎 (zhihu.com)</a></li>
<li><a href="https://blog.csdn.net/qq_15345177/article/details/88066050">(2条消息) c++中 new的使用方法_计量小菜鸡的博客-CSDN博客_c++中new的用法</a></li>
<li><a href="https://www.jianshu.com/p/14ac114b9558">C语言中a++与++a的区别 - 简书 (jianshu.com)</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/137383328">c++入门学习篇（1）之：：作用域符解析 - 知乎 (zhihu.com)</a></li>
<li></li>
</ul>
<p>在 C语言 的 switch（开关语句）中，break 语句还可用来在执行完一个 case（分支）后立即跳出当前 switch 结构。</p>
<h3 id="输入输出流">输入输出流</h3>
<p>cout是个对象，既不是关键字，也不是函数。</p>
<ol type="1">
<li>可以连续输出</li>
<li>自动识别类型</li>
</ol>
<p>cin同理</p>
<p>C中不能定义2个相同的变量和函数，会出现重定义</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//cin cout</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">12</span>;</span><br><span class="line">    <span class="type">char</span> b = <span class="string">&#x27;v&#x27;</span>;</span><br><span class="line">    <span class="type">float</span> c = <span class="number">34.56</span>;</span><br><span class="line">    cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;</span><br><span class="line">    cout &lt;&lt; a &lt;&lt;<span class="string">&#x27; &#x27;</span> &lt;&lt; b &lt;&lt;<span class="string">&#x27; &#x27;</span> &lt;&lt; c &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="命名空间">命名空间</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std; <span class="comment">//使用命名空间</span></span><br><span class="line"><span class="comment">//命名空间，解决C语言中重定义</span></span><br><span class="line"><span class="keyword">namespace</span> stu <span class="comment">//声明命名空间</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">sort</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="number">23</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> stu1</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">sort</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="number">56</span> &lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> stu;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> stu1;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    stu::<span class="built_in">sort</span>();<span class="comment">//::作用域运算符</span></span><br><span class="line">    stu1::<span class="built_in">sort</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure>
<img src="/.io//Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20211001101337224.png" alt="image-20211001101337224"><figcaption aria-hidden="true">image-20211001101337224</figcaption>
</figure>
<h3 id="结构体">结构体</h3>
<p>C语言中结构体看<a href="https://www.bilibili.com/video/BV1rW411R7g4?p=10">【C++教程】_哔哩哔哩_bilibili</a></p>
<ol type="1">
<li>C++中结构体中可以放函数</li>
<li>声明结构体变量不用struct关键字</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std; <span class="comment">//使用命名空间</span></span><br><span class="line"><span class="comment">//命名空间</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">first</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">()</span> <span class="comment">//c++结构体中可以放函数</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Hello wolrd&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* data */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    first stu; <span class="comment">//声明结构体变量不用struct关键字</span></span><br><span class="line">    stu.a = <span class="number">23</span>;</span><br><span class="line">    cout &lt;&lt; stu.a &lt;&lt; endl;</span><br><span class="line">    stu.<span class="built_in">fun</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="new-delete">new &amp; delete</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//heap堆区空间的申请与释放，申请一定要释放</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> *p = <span class="keyword">new</span> <span class="type">int</span>;  <span class="comment">//new + 类型</span></span><br><span class="line">    <span class="type">float</span> *p1 = <span class="keyword">new</span> <span class="built_in">float</span>(<span class="number">134.56</span>); <span class="comment">//声明并初始化</span></span><br><span class="line"></span><br><span class="line">    *p = <span class="number">23</span>; <span class="comment">//write</span></span><br><span class="line">    cout &lt;&lt; *p &lt;&lt; endl &lt;&lt; *p1;  <span class="comment">//read</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> p;  <span class="comment">//释放: delete + 指针</span></span><br><span class="line">    <span class="keyword">delete</span> p1;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">------------------------------------------------------------------------</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> * <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//new的返回值类型是该数据类型的指针</span></span><br><span class="line">	<span class="type">int</span> *p = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">10</span>);<span class="comment">//开辟一个变量，用10来初始化</span></span><br><span class="line">	<span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//开辟一块数组</span></span><br><span class="line">	<span class="type">int</span> *arr = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">10</span>];<span class="comment">//arr为该数组的首地址</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		arr[i] = i + <span class="number">10</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; arr[i] &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">delete</span>[]arr;<span class="comment">//释放开辟的数组空间</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> *p1 = <span class="built_in">test01</span>();</span><br><span class="line">	cout &lt;&lt; *<span class="built_in">test01</span>() &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; *p1 &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">test02</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//heap堆区空间的申请与释放，申请一定要释放</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">//申请数组空间</span></span><br><span class="line"></span><br><span class="line">   <span class="type">int</span> *p  = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">5</span>];</span><br><span class="line">   <span class="comment">//int *p1 = malloc(5*sizeof(int));</span></span><br><span class="line">   <span class="built_in">memset</span>(p,<span class="number">0</span>,<span class="number">5</span>*<span class="built_in">sizeof</span>(<span class="type">int</span>));<span class="comment">//初始化</span></span><br><span class="line">   p[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">   p[<span class="number">2</span>] = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">   cout&lt;&lt; p[<span class="number">0</span>] &lt;&lt; endl &lt;&lt; p[<span class="number">2</span>] &lt;&lt; endl&lt;&lt; p[<span class="number">4</span>];</span><br><span class="line">   <span class="keyword">delete</span>[] p;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="引用">引用</h3>
<ul>
<li>引用声明时必须初始化</li>
<li>一个变量可以有多个引用</li>
</ul>
<p>引用给变量起别名，typedef给类型起别名</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="type">int</span> a = <span class="number">12</span>;</span><br><span class="line">   <span class="type">int</span> &amp;c = a; <span class="comment">//&amp;不是取地址，是引用。声明变量a的一个引用c，c是变量a的别名</span></span><br><span class="line"></span><br><span class="line">   c = <span class="number">14</span>;</span><br><span class="line">   cout &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure>
<img src="/.io//Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20211002165551868.png" alt="image-20211002165551868"><figcaption aria-hidden="true">image-20211002165551868</figcaption>
</figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="comment">//常量类型的引用</span></span><br><span class="line">   <span class="type">const</span> <span class="type">int</span> &amp;a = <span class="number">12</span>;</span><br><span class="line">   <span class="type">const</span> <span class="type">char</span> &amp;b = <span class="string">&#x27;v&#x27;</span>;</span><br><span class="line">   cout &lt;&lt; a &lt;&lt; endl &lt;&lt; b &lt;&lt; endl;</span><br><span class="line"><span class="comment">//数组的引用</span></span><br><span class="line">   <span class="type">int</span> arr[<span class="number">10</span>];</span><br><span class="line">   <span class="built_in">int</span> (&amp;p)[<span class="number">10</span>] = arr; <span class="comment">//p的用法和arr一样</span></span><br><span class="line">   p[<span class="number">0</span>] = <span class="number">100</span>;</span><br><span class="line">   cout &lt;&lt; arr[<span class="number">0</span>] &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">   <span class="type">int</span> arr2[<span class="number">2</span>][<span class="number">3</span>];</span><br><span class="line">   <span class="built_in">int</span> (&amp;p2)[<span class="number">2</span>][<span class="number">3</span>] = arr2;</span><br><span class="line">   p2[<span class="number">2</span>][<span class="number">3</span>] = <span class="number">67</span>;</span><br><span class="line">   cout &lt;&lt; arr2[<span class="number">2</span>][<span class="number">3</span>]&lt;&lt;endl;</span><br><span class="line">   <span class="comment">//指针的引用</span></span><br><span class="line"><span class="comment">// 类型 + 引用</span></span><br><span class="line">   <span class="type">int</span> c = <span class="number">78</span>;</span><br><span class="line">   <span class="type">int</span> *point = &amp;c;</span><br><span class="line">   cout &lt;&lt; *point&lt;&lt;endl;</span><br><span class="line">   <span class="type">int</span>* (&amp;p3) = point;</span><br><span class="line">   *p3 = <span class="number">97</span>;</span><br><span class="line">   cout &lt;&lt; c;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="引用做参数">引用做参数</h3>
<p>传递参数的过程也是初始化的过程</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//引用做参数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">(<span class="type">int</span> &amp;a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   a = <span class="number">19</span>;<span class="comment">//操作的是同一块空间</span></span><br><span class="line">   <span class="comment">//cout &lt;&lt; a&lt;&lt;endl;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//整型做参数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun1</span><span class="params">(<span class="type">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   cout &lt;&lt; a&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//指针做参数，修改函数外部的值</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun2</span><span class="params">(<span class="type">int</span> *a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   *a = <span class="number">46</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="type">int</span> b = <span class="number">14</span>;</span><br><span class="line">   <span class="built_in">fun</span>(b);</span><br><span class="line">   cout &lt;&lt; b&lt;&lt;endl;<span class="comment">// 通过外部一个函数修改b的值，修改函数外部的值。</span></span><br><span class="line"></span><br><span class="line">   <span class="built_in">fun2</span>(&amp;b);</span><br><span class="line">   cout&lt;&lt;b;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="for循环">for循环</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//增强型for循环</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		cout&lt;&lt;i &lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span></span><br></pre></td></tr></table></figure>
<h3 id="函数缺省值">函数缺省值</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//函数默认值</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun3</span><span class="params">(<span class="type">int</span> a = <span class="number">45</span>, <span class="type">float</span> g = <span class="number">67.98</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">(<span class="type">int</span> a = <span class="number">12</span>, <span class="type">char</span> b = <span class="string">&#x27;m&#x27;</span>)</span> <span class="comment">//全部指定</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; a &lt;&lt;<span class="string">&#x27; &#x27;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun2</span><span class="params">(<span class="type">int</span> a , <span class="type">char</span> b ,<span class="type">float</span> f = <span class="number">123.78</span>)</span><span class="comment">//部分指定，从右到左，连续指定</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; a &lt;&lt;<span class="string">&#x27; &#x27;</span> &lt;&lt; b &lt;&lt;<span class="string">&#x27; &#x27;</span> &lt;&lt; f &lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//函数有缺省值，函数调用不用实参</span></span><br><span class="line">	<span class="built_in">fun</span>();</span><br><span class="line">	<span class="comment">//部分指定，可以只写没有缺省值的参数</span></span><br><span class="line">	<span class="built_in">fun2</span>(<span class="number">54</span>,<span class="string">&#x27;y&#x27;</span>);</span><br><span class="line">	<span class="comment">// 有缺省值，传参数会覆盖掉缺省值</span></span><br><span class="line">	<span class="built_in">fun</span>(<span class="number">50</span>,<span class="string">&#x27;r&#x27;</span>);</span><br><span class="line">	<span class="comment">//有函数原型的，缺省值写在函数原型中</span></span><br><span class="line">	<span class="built_in">fun3</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun3</span><span class="params">(<span class="type">int</span> a , <span class="type">float</span> g )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; a &lt;&lt;<span class="string">&#x27; &#x27;</span> &lt;&lt; g &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="函数重载">函数重载</h3>
<p>同一作用域内，函数名字相同，参数列表不同（参数类型或参数个数不同）</p>
<p>c语言中，不允许函数名字相同</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//函数参数列表不同，就可以自动识别</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">(<span class="type">int</span> a )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">(<span class="type">float</span> f )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; f &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">(<span class="type">char</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; c &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//76.65默认是double类型的</span></span><br><span class="line">	<span class="built_in">show</span>(<span class="number">23</span>);</span><br><span class="line">	<span class="built_in">show</span>(<span class="number">43.56f</span>);</span><br><span class="line">	<span class="built_in">show</span>(<span class="string">&#x27;h&#x27;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>函数返回值不作为函数重载的条件</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">fun</span><span class="params">(<span class="type">int</span> a)</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">(<span class="type">int</span> a)</span></span></span><br><span class="line"><span class="function">    <span class="comment">//会报错</span></span></span><br></pre></td></tr></table></figure>
<h3 id="类">类</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cpeople</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> a;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//申请一个对象</span></span><br><span class="line">	Cpeople op;</span><br><span class="line">	op.a = <span class="number">15</span>;</span><br><span class="line">	op.<span class="built_in">fun</span>();</span><br><span class="line"></span><br><span class="line">	Cpeople *op1 = <span class="keyword">new</span> Cpeople;</span><br><span class="line">	op1-&gt;a  = <span class="number">56</span>;</span><br><span class="line">	op1-&gt;<span class="built_in">fun</span>();</span><br><span class="line">	<span class="keyword">delete</span> op1;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="友元">友元</h3>
<ul>
<li>友元函数，不相关的函数去使用类内私有成员</li>
<li>友元类，不同类使用另一个类私有成员</li>
</ul>
<figure>
<img src="/.io//Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20211004120911813.png" alt="image-20211004120911813"><figcaption aria-hidden="true">image-20211004120911813</figcaption>
</figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cpeople</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> a;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		a = <span class="number">54</span>;</span><br><span class="line">		cout &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">fun_pro</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		a = <span class="number">54</span>;</span><br><span class="line">		cout &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">fun2</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">friend</span> <span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">CP</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//子类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cchild</span> : <span class="keyword">public</span> Cpeople</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">fun6</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="built_in">fun_pro</span>();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Cpeople op2;</span><br><span class="line">	op2.<span class="built_in">fun</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CP</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	Cpeople op3;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">fun3</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		op3.<span class="built_in">fun</span>();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Cpeople op;</span><br><span class="line">	op.<span class="built_in">fun</span>();</span><br><span class="line"></span><br><span class="line">	CP op4;</span><br><span class="line">	op4.<span class="built_in">fun3</span>();</span><br><span class="line"></span><br><span class="line">	Cchild op_child;</span><br><span class="line">	op_child.<span class="built_in">fun6</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>类和int一样，都是一种数据类型。只有用类声明对象时，才会开辟出一块空间</p>
<h3 id="成员函数">成员函数</h3>
<h4 id="构造函数自动调用">构造函数：自动调用</h4>
<p>在对象创建时候，调用。作用，==初始化类内的变量，赋值==。不要在构造函数内部加不相干的代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CStu</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> a;</span><br><span class="line">	<span class="type">float</span> f;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//gou zao function</span></span><br><span class="line">	<span class="built_in">CStu</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		a = <span class="number">14</span>;</span><br><span class="line">		f = <span class="number">53.98f</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">	CStu student1;</span><br><span class="line">	</span><br><span class="line">	CStu *stu2 = <span class="keyword">new</span> CStu;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; stu2-&gt;f &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; student1.a &lt;&lt;<span class="string">&#x27; &#x27;</span>&lt;&lt; student1.f &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>==类中的函数，可以类内声明，类外定义==</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//学生类</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//设计一个学生类，属性有姓名和学号，可以给其赋值，可以显示</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cstudent</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//属性，成员变量</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    string stu_name;</span><br><span class="line">    <span class="type">int</span> stu_id;</span><br><span class="line">    <span class="comment">//行为，成员函数，成员方法</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;The name of the student：&quot;</span> &lt;&lt; stu_name &lt;&lt;endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;The id of the student：&quot;</span> &lt;&lt; stu_id &lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">set_name</span><span class="params">(string name)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        stu_name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">set_id</span><span class="params">(<span class="type">int</span> id)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        stu_id = id;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    Cstudent stu;</span><br><span class="line"><span class="comment">//    stu.stu_name = &quot;pp&quot;;</span></span><br><span class="line"><span class="comment">//    stu.stu_id = 13;</span></span><br><span class="line">    stu.<span class="built_in">set_id</span>(<span class="number">15</span>);</span><br><span class="line">    stu.<span class="built_in">set_name</span>(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line"></span><br><span class="line">    stu.<span class="built_in">show</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="成员属性私有化">成员属性私有化</h4>
<p>用公共的函数接口来访问</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cperson</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">set_name</span><span class="params">(string name)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        C_name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">string <span class="title">get_name</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> C_name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">get_age</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        C_age = <span class="number">18</span>;</span><br><span class="line">        <span class="keyword">return</span> C_age;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">//property</span></span><br><span class="line">    string C_name;<span class="comment">//可读可写</span></span><br><span class="line">    <span class="type">int</span> C_age;<span class="comment">//read only</span></span><br><span class="line">    string C_sex;<span class="comment">//read only</span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Cperson person1;</span><br><span class="line">    person1.<span class="built_in">set_name</span>(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;The name is &quot;</span> &lt;&lt; person1.<span class="built_in">get_name</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;The age is &quot;</span> &lt;&lt; person1.<span class="built_in">get_age</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="this指针">this指针</h3>
<p>==对象存在，this指针才存在==</p>
<p><strong>==this指针的作用域在类内，系统默认传递给函数的隐含参数,只能在类内成员函数内部使用==</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cstu</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">//construct function</span></span><br><span class="line">  <span class="comment">//C语言中，相同的变量，会把前一个屏蔽掉</span></span><br><span class="line">    <span class="built_in">Cstu</span>(<span class="type">int</span> a)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;a = a; <span class="comment">//相当于a给自己赋值</span></span><br><span class="line">        <span class="keyword">this</span>-&gt;<span class="built_in">show</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//this指针是Cstu*类型的，指向这个对象，用this指针访问类内成员</span></span><br><span class="line"></span><br><span class="line">    <span class="function">Cstu* <span class="title">getaddr</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Cstu <span class="title">stu1</span><span class="params">(<span class="number">12</span>)</span></span>;</span><br><span class="line">    stu1.<span class="built_in">show</span>();</span><br><span class="line">    Cstu*p =  stu1.<span class="built_in">getaddr</span>();</span><br><span class="line">    cout &lt;&lt; p &lt;&lt;endl; <span class="comment">//也可以使用p去调用类内的函数</span></span><br><span class="line">    p-&gt;<span class="built_in">show</span>();</span><br><span class="line">    <span class="comment">//this-&gt;show();//错误写法</span></span><br><span class="line"></span><br><span class="line">    <span class="function">Cstu <span class="title">stu2</span><span class="params">(<span class="number">17</span>)</span></span>;</span><br><span class="line">    Cstu*p2 = stu2.<span class="built_in">getaddr</span>();</span><br><span class="line">    cout &lt;&lt; p2 &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="staticconst">static&amp;const</h3>
<p>==static可以使用类名作用域调用，说明是存在于类中的，和对象没有关系，没有声明对象时，也存在静态成员，在创建类的时候就给静态成员分配了空间。是类本身的属性，和对象没有关系==</p>
<p>只有静态常量整型数据成员才能在类中初始化</p>
<p>静态函数 常函数</p>
<p>静态变量 常变量</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cstu</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">static</span> <span class="type">int</span> a;  <span class="comment">//initialize in class out</span></span><br><span class="line">	<span class="comment">//int b = 15; 错误写法</span></span><br><span class="line">	<span class="type">static</span> <span class="type">const</span> <span class="type">int</span> b = <span class="number">17</span>; <span class="comment">//只有静态整型常量数据类型可以在类内初始化</span></span><br><span class="line">	<span class="built_in">Cstu</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		a = <span class="number">12</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> Cstu::a = <span class="number">19</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//static 调用</span></span><br><span class="line">	<span class="comment">//类名作用域</span></span><br><span class="line">	cout &lt;&lt; Cstu::a &lt;&lt; endl;</span><br><span class="line">	Cstu stu1;</span><br><span class="line">	cout &lt;&lt; stu1.a &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; stu1.b ;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">------------------------------------------------------------------</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cstu</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">static</span> <span class="type">int</span> a;  <span class="comment">//initialize in class out</span></span><br><span class="line">	<span class="comment">//int b = 15; 错误写法</span></span><br><span class="line">	<span class="comment">//static const int b = 17; //只有静态整型常量数据类型可以在类内初始化</span></span><br><span class="line">	<span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">fun</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;I am static function.&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">fun2</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;I am  function.&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">Cstu</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		a = <span class="number">12</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> Cstu::a = <span class="number">19</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//static 调用</span></span><br><span class="line">	<span class="comment">//类名作用域</span></span><br><span class="line">	cout &lt;&lt; Cstu::a &lt;&lt; endl;</span><br><span class="line">	Cstu::<span class="built_in">fun</span>();</span><br><span class="line">	Cstu::<span class="built_in">fun2</span>();<span class="comment">//错误</span></span><br><span class="line">	Cstu stu1;</span><br><span class="line">	cout &lt;&lt; stu1.a &lt;&lt; endl;</span><br><span class="line">	stu1.<span class="built_in">fun</span>();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// cout &lt;&lt; stu1.b ;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cperson</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">/*Cperson()</span></span><br><span class="line"><span class="comment">	&#123;</span></span><br><span class="line"><span class="comment">		cout &lt;&lt; &quot;Cperson的默认构造函数&quot; &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">	&#125;*/</span></span><br><span class="line">	~<span class="built_in">Cperson</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Cperson的默认析构函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">Cperson</span>(<span class="type">int</span> age)</span><br><span class="line">	&#123;</span><br><span class="line">		c_age = age;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Cperson的有参构造函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/*Cperson(const Cperson&amp; a)</span></span><br><span class="line"><span class="comment">	&#123;</span></span><br><span class="line"><span class="comment">		c_age = a.c_age;</span></span><br><span class="line"><span class="comment">		cout &lt;&lt; &quot;cperson的拷贝构造函数&quot; &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">	&#125;*/</span></span><br><span class="line">	<span class="type">int</span> c_age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">Cperson <span class="title">per1</span><span class="params">(<span class="number">13</span>)</span></span>;</span><br><span class="line">	<span class="comment">//per1.c_age = 19;</span></span><br><span class="line"></span><br><span class="line">	<span class="function">Cperson <span class="title">per2</span><span class="params">(per1)</span></span>;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;age of per2 is &quot;</span> &lt;&lt; per2.c_age &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">Cperson <span class="title">per3</span><span class="params">(<span class="number">98</span>)</span></span>;  <span class="comment">//调用有参构造函数</span></span><br><span class="line"></span><br><span class="line">	<span class="function">Cperson <span class="title">per4</span><span class="params">(per3)</span></span>; <span class="comment">//会调用拷贝构造函数</span></span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;age of per4 is &quot;</span> &lt;&lt; per4.c_age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line">	<span class="built_in">test02</span>();</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="浅拷贝深拷贝">浅拷贝&amp;深拷贝</h3>
<p><strong>==如果属性由在堆区开辟的，一定要自己提供拷贝构造函数，放置浅拷贝带来的问题==</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cperson</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Cperson</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Cperson的默认构造函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	~<span class="built_in">Cperson</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//堆区释放</span></span><br><span class="line">		<span class="keyword">if</span> (c_height != <span class="literal">NULL</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">delete</span> c_height;</span><br><span class="line">			<span class="comment">//c_heignt = NULL;</span></span><br><span class="line">		&#125;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Cperson的默认析构函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">Cperson</span>(<span class="type">int</span> age, <span class="type">int</span> height)</span><br><span class="line">	&#123;</span><br><span class="line">		c_height = <span class="keyword">new</span> <span class="built_in">int</span>(height);</span><br><span class="line"></span><br><span class="line">		c_age = age;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Cperson的有参构造函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//浅拷贝带来异常</span></span><br><span class="line">	<span class="comment">//以下为深拷贝</span></span><br><span class="line">	<span class="built_in">Cperson</span>(<span class="type">const</span> Cperson&amp; a)</span><br><span class="line">	&#123;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/*默认构造函数的操作</span></span><br><span class="line"><span class="comment">		c_age = a.c_age;</span></span><br><span class="line"><span class="comment">		c_height = a.c_height;*/</span></span><br><span class="line">		<span class="comment">//自己写一个构造函数,在堆区重新开辟一块空间</span></span><br><span class="line">		c_age = a.c_age;</span><br><span class="line">		c_height = <span class="keyword">new</span> <span class="built_in">int</span>(*a.c_height);</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;cperson的拷贝构造函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> c_age;</span><br><span class="line">	<span class="type">int</span> *c_height;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">Cperson <span class="title">per1</span><span class="params">(<span class="number">19</span>,<span class="number">179</span>)</span></span>;</span><br><span class="line">	<span class="comment">//per1.c_age = 19;</span></span><br><span class="line"></span><br><span class="line">	<span class="function">Cperson <span class="title">per2</span><span class="params">(per1)</span></span>;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;age of per1 is &quot;</span> &lt;&lt; per1.c_age &lt;&lt; </span><br><span class="line">		    <span class="string">&quot;height of per1 is &quot;</span> &lt;&lt; *per1.c_height &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;age of per2 is &quot;</span> &lt;&lt; per2.c_age &lt;&lt; </span><br><span class="line">		    <span class="string">&quot;height of per2 is &quot;</span> &lt;&lt;  *per2.c_height &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="构造函数初始化列表">构造函数初始化列表</h4>
<ul>
<li>Cperson()：C_a(a),C_b(b),C_c(c)</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cperson</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//构造函数</span></span><br><span class="line">	<span class="comment">//传统初始化方法</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">/*Cperson(int a,int b,int c)</span></span><br><span class="line"><span class="comment">	&#123;</span></span><br><span class="line"><span class="comment">		C_a = a;</span></span><br><span class="line"><span class="comment">		C_b = b;</span></span><br><span class="line"><span class="comment">		C_c = c;</span></span><br><span class="line"><span class="comment">	&#125;*/</span></span><br><span class="line">	<span class="built_in">Cperson</span>(<span class="type">int</span> a,<span class="type">int</span> b,<span class="type">int</span> c) : <span class="built_in">C_a</span>(a),<span class="built_in">C_b</span>(b),<span class="built_in">C_c</span>(c)</span><br><span class="line">	&#123;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> C_a;</span><br><span class="line">	<span class="type">int</span> C_b;</span><br><span class="line">	<span class="type">int</span> C_c;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//void test01()</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//	Cperson per1(23,13,25);</span></span><br><span class="line"><span class="comment">//	cout &lt;&lt; &quot;C_a: &quot; &lt;&lt; per1.C_a &lt;&lt;endl;</span></span><br><span class="line"><span class="comment">//	cout &lt;&lt; &quot;C_b: &quot; &lt;&lt; per1.C_b &lt;&lt;endl;</span></span><br><span class="line"><span class="comment">//	cout &lt;&lt; &quot;C_c: &quot; &lt;&lt; per1.C_c &lt;&lt;endl;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">Cperson <span class="title">per2</span><span class="params">(<span class="number">45</span>,<span class="number">76</span>,<span class="number">43</span>)</span></span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;C_a: &quot;</span> &lt;&lt; per2.C_a &lt;&lt;endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;C_b: &quot;</span> &lt;&lt; per2.C_b &lt;&lt;endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;C_c: &quot;</span> &lt;&lt; per2.C_c &lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//test01();</span></span><br><span class="line">	<span class="built_in">test02</span>();</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="类作对象">类作对象</h3>
<p>==构造函数的顺序是：先构造内层的，在构造外层的，析构函数的执行顺序服从“先进后出”的规则，与构造函数顺序相反。==</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//手机类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cphone</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//构造函数</span></span><br><span class="line">	<span class="built_in">Cphone</span>(string name)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;phone&quot;</span> &lt;&lt; endl;</span><br><span class="line">		C_PhoneNmae = name;</span><br><span class="line">	&#125;</span><br><span class="line">	~<span class="built_in">Cphone</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;phone destructor&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//手机品牌</span></span><br><span class="line">	string C_PhoneNmae;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//人类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cperson</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//属性</span></span><br><span class="line">	string c_name;</span><br><span class="line">	Cphone c_phone;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Cperson</span>(string name,string phone):<span class="built_in">c_name</span>(name),<span class="built_in">c_phone</span>(phone)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;person &quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	~<span class="built_in">Cperson</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;person destructor&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">Cperson <span class="title">per1</span><span class="params">(<span class="string">&quot;zhangsan&quot;</span>,<span class="string">&quot;xiaomi&quot;</span>)</span></span>;</span><br><span class="line">	cout &lt;&lt; per1.c_name &lt;&lt; <span class="string">&quot; have &quot;</span> &lt;&lt; per1.c_phone.C_PhoneNmae &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure>
<img src="/.io//Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20211018233256498.png" alt="image-20211018233256498"><figcaption aria-hidden="true">image-20211018233256498</figcaption>
</figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cperson</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> c_age; <span class="comment">//非静态成员变量，属于类的对象</span></span><br><span class="line">	<span class="type">static</span> <span class="type">int</span> c_name; <span class="comment">//静态成员函数变量，不属于类的对象</span></span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">()</span> <span class="comment">//非静态成员函数，不属于类的对象</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">fun1</span><span class="params">()</span> </span>&#123;&#125; <span class="comment">//静态成员函数，属于类的对象</span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Cperson per1;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;size of per1 is &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(per1) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="空指针访问成员函数">空指针访问成员函数</h3>
<p>类中的成员属性默认在前面有<kbd>this-&gt;</kbd>.而<kbd>person*p = NULL</kbd>语句并没有创建对象，所以是无法访问对象的，所以this指针是不存在的，</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cperson</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> c_age;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">showName</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;this is the class name&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//由于没有创建对象，使用this指针产生异常</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">showAge</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span> == <span class="literal">NULL</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		cout &lt;&lt; <span class="keyword">this</span>-&gt;c_age &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Cperson *p = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="comment">//p-&gt;showAge();</span></span><br><span class="line">	p-&gt;<span class="built_in">showName</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//class CBuilding; //goodgay中使用了building类，因此要先声明一下，让编译器认识，类似于函数声明</span></span><br><span class="line"><span class="comment">/*-----------------Building class------------------------*/</span></span><br><span class="line"><span class="comment">//建筑类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CBuilding</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">CBuilding</span>();</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	string c_livingroom;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	string c_bedroom;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">CGoodgay</span>;<span class="comment">//友元类</span></span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">goodgay::visit</span><span class="params">()</span></span>;<span class="comment">//友元成员函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//构造函数，类内声明，类外定义，要声明是哪个类的构造函数</span></span><br><span class="line">CBuilding::<span class="built_in">CBuilding</span>()</span><br><span class="line">&#123;</span><br><span class="line">	c_livingroom = <span class="string">&quot;living room&quot;</span>;</span><br><span class="line">	c_bedroom = <span class="string">&quot;bed room&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*----------------Googgay class-----------------------------*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CGoodgay</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	CBuilding * building1;</span><br><span class="line">	<span class="built_in">CGoodgay</span>();</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">visit</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//构造函数，初始化成员变量</span></span><br><span class="line">CGoodgay::<span class="built_in">CGoodgay</span>()</span><br><span class="line">&#123;</span><br><span class="line">	building1 = <span class="keyword">new</span> CBuilding;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CGoodgay::visit</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;Good gay is looking at &quot;</span> &lt;&lt; building1-&gt;c_livingroom &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;Good gay is looking at &quot;</span> &lt;&lt; building1-&gt;c_bedroom &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*-------------------test-------------------------------*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	CGoodgay gay1;</span><br><span class="line">	gay1.<span class="built_in">visit</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*-----------------main function-----------------------*/</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure>
<img src="/.io//Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20211019172544775.png" alt="image-20211019172544775"><figcaption aria-hidden="true">image-20211019172544775</figcaption>
</figure>
<figure>
<img src="/.io//Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20211019172649352.png" alt="image-20211019172649352"><figcaption aria-hidden="true">image-20211019172649352</figcaption>
</figure>
<h3 id="运算符重载">运算符重载</h3>
<figure>
<img src="/.io//Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20211019233541178.png" alt="image-20211019233541178"><figcaption aria-hidden="true">image-20211019233541178</figcaption>
</figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CPerson</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span>:<span class="comment">//成员函数重载+</span></span><br><span class="line">		CPerson <span class="keyword">operator</span>+(CPerson &amp;p)</span><br><span class="line">		&#123;</span><br><span class="line">			CPerson temp;</span><br><span class="line">			temp.c_a = <span class="keyword">this</span>-&gt;c_a + p.c_a;</span><br><span class="line">			temp.c_b = <span class="keyword">this</span>-&gt;c_b + p.c_b;</span><br><span class="line">			<span class="keyword">return</span> temp;</span><br><span class="line">		&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> c_a;</span><br><span class="line">	<span class="type">int</span> c_b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	CPerson per1;</span><br><span class="line">	per1.c_a = <span class="number">34</span>;</span><br><span class="line">	per1.c_b = <span class="number">54</span>;</span><br><span class="line">	CPerson per2;</span><br><span class="line">	per2.c_a = <span class="number">54</span>;</span><br><span class="line">	per2.c_b = <span class="number">74</span>;</span><br><span class="line">	CPerson per3;</span><br><span class="line"></span><br><span class="line">	per3 = per1 + per2;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;per3.c_a =&quot;</span> &lt;&lt; per3.c_a &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;per3.c_b =&quot;</span> &lt;&lt; per3.c_b &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">////全局函数重载+</span></span><br><span class="line"><span class="comment">//CPerson operator+ (CPerson &amp;p1, CPerson &amp;p2)</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//	CPerson temp;</span></span><br><span class="line"><span class="comment">//	temp.c_a = p1.c_a + p2.c_a;</span></span><br><span class="line"><span class="comment">//	temp.c_b = p1.c_b + p2.c_b;</span></span><br><span class="line"><span class="comment">//	return temp;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line">   <span class="comment">//成员函数重载本质调用</span></span><br><span class="line">	Cperson p3 = p1.<span class="keyword">operator</span>+(p2)</span><br><span class="line">	简写：p3 = p1+p2;</span><br><span class="line">	全局函数重载本质调用</span><br><span class="line">	Cperson p3 = <span class="keyword">operator</span>+(p1,p2)</span><br><span class="line">	简写: p3 = p1+p2</span><br><span class="line"><span class="type">int</span> <span class="built_in">main</span>()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cperson</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> c_a;</span><br><span class="line">	<span class="type">int</span> c_b;</span><br><span class="line">	<span class="built_in">Cperson</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		c_a = <span class="number">89</span>;</span><br><span class="line">		c_b = <span class="number">93</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">ostream &amp; <span class="keyword">operator</span>&lt;&lt;(ostream &amp;cout ,Cperson &amp;p)</span><br><span class="line">&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;c_a: &quot;</span> &lt;&lt; p.c_a  &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;c_b: &quot;</span> &lt;&lt; p.c_b &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> cout;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Cperson per1;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; per1 &lt;&lt; endl;</span><br><span class="line">	<span class="comment">//cout &lt;&lt; per1 &lt;&lt;endl;无限追加输入，是因为链式编程思想</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="递增运算符重载">递增运算符重载</h3>
<figure>
<img src="/.io//Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20211020135253168.png" alt="image-20211020135253168"><figcaption aria-hidden="true">image-20211020135253168</figcaption>
</figure>
<h3 id="继承">继承</h3>
<p>好处：减少重复的代码</p>
<p>语法：<kbd>class 子类:继承方式 父类</kbd></p>
<p>子类又叫派生类</p>
<ul>
<li>从父类继承过来的</li>
<li>自己新增的</li>
</ul>
<p>父类又叫基类</p>
<figure>
<img src="/.io//Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20211020164955371.png" alt="image-20211020164955371"><figcaption aria-hidden="true">image-20211020164955371</figcaption>
</figure>
<p>父类中的非静态成员变量都会被继承下去，无论是否私有还是公有</p>
<p>子类与父类中的同名函数，同名变量。默认会调用子类中的，子类中的会隐藏掉父类中所有的同名函数</p>
<figure>
<img src="/.io//Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20211020174208051.png" alt="image-20211020174208051"><figcaption aria-hidden="true">image-20211020174208051</figcaption>
</figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CFather</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">CFather</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		c_a = <span class="number">34</span>;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> c_a;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CSon</span> :<span class="keyword">public</span> CFather</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> c_a;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">CSon</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		c_a = <span class="number">56</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	CSon son1;</span><br><span class="line">	cout &lt;&lt; son1.c_a &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; son1.CFather::c_a &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure>
<img src="/.io//Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20211020214242953.png" alt="image-20211020214242953"><figcaption aria-hidden="true">image-20211020214242953</figcaption>
</figure>
<h3 id="多态">多态</h3>
<figure>
<img src="/.io//Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20211020220806664.png" alt="image-20211020220806664"><figcaption aria-hidden="true">image-20211020220806664</figcaption>
</figure>
<p>重载：函数名相同，参数不同</p>
<p>重写：函数返回值，函数名，形参列表都相同</p>
<figure>
<img src="/.io//Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20211020221534209.png" alt="image-20211020221534209"><figcaption aria-hidden="true">image-20211020221534209</figcaption>
</figure>
<figure>
<img src="/.io//Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20211020221707835.png" alt="image-20211020221707835"><figcaption aria-hidden="true">image-20211020221707835</figcaption>
</figure>
<figure>
<img src="/.io//Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20211020221741333.png" alt="image-20211020221741333"><figcaption aria-hidden="true">image-20211020221741333</figcaption>
</figure>
<p>==成员函数不属于对象==</p>
<p>==不管是什么类型的指针，都占4个字节==</p>
<figure>
<img src="/.io//Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20211021202239635.png" alt="image-20211021202239635"><figcaption aria-hidden="true">image-20211021202239635</figcaption>
</figure>
<figure>
<img src="/.io//Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20211021202658926.png" alt="image-20211021202658926"><figcaption aria-hidden="true">image-20211021202658926</figcaption>
</figure>
<figure>
<img src="/.io//Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20211021203623112.png" alt="image-20211021203623112"><figcaption aria-hidden="true">image-20211021203623112</figcaption>
</figure>
<figure>
<img src="/.io//Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20211021203952490.png" alt="image-20211021203952490"><figcaption aria-hidden="true">image-20211021203952490</figcaption>
</figure>
<figure>
<img src="/.io//Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20211021204111880.png" alt="image-20211021204111880"><figcaption aria-hidden="true">image-20211021204111880</figcaption>
</figure>
<p><strong>==通过父类的指针，可以调用不同的子类对象的函数或成员==</strong></p>
<figure>
<img src="/.io//Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20211021220439165.png" alt="image-20211021220439165"><figcaption aria-hidden="true">image-20211021220439165</figcaption>
</figure>
<figure>
<img src="/.io//Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20211021221722313.png" alt="image-20211021221722313"><figcaption aria-hidden="true">image-20211021221722313</figcaption>
</figure>
<figure>
<img src="/.io//Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20211021225354564.png" alt="image-20211021225354564"><figcaption aria-hidden="true">image-20211021225354564</figcaption>
</figure>
<figure>
<img src="/.io//Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20211021225639639.png" alt="image-20211021225639639"><figcaption aria-hidden="true">image-20211021225639639</figcaption>
</figure>
<figure>
<img src="/.io//Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20211021230353091.png" alt="image-20211021230353091"><figcaption aria-hidden="true">image-20211021230353091</figcaption>
</figure>
<figure>
<img src="/.io//Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20211021230635796.png" alt="image-20211021230635796"><figcaption aria-hidden="true">image-20211021230635796</figcaption>
</figure>
<figure>
<img src="/.io//Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20211021231644579.png" alt="image-20211021231644579"><figcaption aria-hidden="true">image-20211021231644579</figcaption>
</figure>
<figure>
<img src="/.io//Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20211022105401533.png" alt="image-20211022105401533"><figcaption aria-hidden="true">image-20211022105401533</figcaption>
</figure>
<figure>
<img src="/.io//Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20211022110526056.png" alt="image-20211022110526056"><figcaption aria-hidden="true">image-20211022110526056</figcaption>
</figure>
<figure>
<img src="/.io//Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20211022111543036.png" alt="image-20211022111543036"><figcaption aria-hidden="true">image-20211022111543036</figcaption>
</figure>
<figure>
<img src="/.io//Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20211022111709836.png" alt="image-20211022111709836"><figcaption aria-hidden="true">image-20211022111709836</figcaption>
</figure>
<figure>
<img src="/.io//Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20211022121233984.png" alt="image-20211022121233984"><figcaption aria-hidden="true">image-20211022121233984</figcaption>
</figure>
<figure>
<img src="/.io//Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20211024224340411.png" alt="image-20211024224340411"><figcaption aria-hidden="true">image-20211024224340411</figcaption>
</figure>
<figure>
<img src="/.io//Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20211024224522966.png" alt="image-20211024224522966"><figcaption aria-hidden="true">image-20211024224522966</figcaption>
</figure>
<figure>
<img src="/.io//Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20211024224613026.png" alt="image-20211024224613026"><figcaption aria-hidden="true">image-20211024224613026</figcaption>
</figure>
<figure>
<img src="/.io//Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20211024224747037.png" alt="image-20211024224747037"><figcaption aria-hidden="true">image-20211024224747037</figcaption>
</figure>
<figure>
<img src="/.io//Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20211024224808615.png" alt="image-20211024224808615"><figcaption aria-hidden="true">image-20211024224808615</figcaption>
</figure>
<figure>
<img src="/.io//Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20211024224924888.png" alt="image-20211024224924888"><figcaption aria-hidden="true">image-20211024224924888</figcaption>
</figure>
<p>==<strong>接口都是一样的，由于对象不同，就显示出多态的意义了</strong>==</p>
<p>一个接口，有多种形态</p>
<figure>
<img src="/.io//Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20211026102816318.png" alt="image-20211026102816318"><figcaption aria-hidden="true">image-20211026102816318</figcaption>
</figure>
<figure>
<img src="/.io//Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20211026103235801.png" alt="image-20211026103235801"><figcaption aria-hidden="true">image-20211026103235801</figcaption>
</figure>
<figure>
<img src="/.io//Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20211026103307827.png" alt="image-20211026103307827"><figcaption aria-hidden="true">image-20211026103307827</figcaption>
</figure>
<figure>
<img src="/.io//Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20211026170316284.png" alt="image-20211026170316284"><figcaption aria-hidden="true">image-20211026170316284</figcaption>
</figure>
<figure>
<img src="/.io//Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20211026170448680.png" alt="image-20211026170448680"><figcaption aria-hidden="true">image-20211026170448680</figcaption>
</figure>
<figure>
<img src="/.io//Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20211026170501131.png" alt="image-20211026170501131"><figcaption aria-hidden="true">image-20211026170501131</figcaption>
</figure>
<figure>
<img src="/.io//Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20211026172757953.png" alt="image-20211026172757953"><figcaption aria-hidden="true">image-20211026172757953</figcaption>
</figure>
<figure>
<img src="/.io//Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20211026173241390.png" alt="image-20211026173241390"><figcaption aria-hidden="true">image-20211026173241390</figcaption>
</figure>
<figure>
<img src="/.io//Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20211026174105364.png" alt="image-20211026174105364"><figcaption aria-hidden="true">image-20211026174105364</figcaption>
</figure>
<h3 id="如何判断数据是否为空">如何判断数据是否为空</h3>
<p><strong>EOF文件的结尾</strong></p>
<figure>
<img src="/.io//Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20211026174241876.png" alt="image-20211026174241876"><figcaption aria-hidden="true">image-20211026174241876</figcaption>
</figure>
<figure>
<img src="/.io//Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20211026174807707.png" alt="image-20211026174807707"><figcaption aria-hidden="true">image-20211026174807707</figcaption>
</figure>
<figure>
<img src="/.io//Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20211026224231250.png" alt="image-20211026224231250"><figcaption aria-hidden="true">image-20211026224231250</figcaption>
</figure>
<figure>
<img src="/.io//Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20211026224303886.png" alt="image-20211026224303886"><figcaption aria-hidden="true">image-20211026224303886</figcaption>
</figure>
<figure>
<img src="/.io//Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20211026224329145.png" alt="image-20211026224329145"><figcaption aria-hidden="true">image-20211026224329145</figcaption>
</figure>
<figure>
<img src="/.io//Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20211026230436353.png" alt="image-20211026230436353"><figcaption aria-hidden="true">image-20211026230436353</figcaption>
</figure>
<figure>
<img src="/.io//Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20211026230456972.png" alt="image-20211026230456972"><figcaption aria-hidden="true">image-20211026230456972</figcaption>
</figure>
<figure>
<img src="/.io//Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20211027092044192.png" alt="image-20211027092044192"><figcaption aria-hidden="true">image-20211027092044192</figcaption>
</figure>
<figure>
<img src="/.io//Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20211027092222524.png" alt="image-20211027092222524"><figcaption aria-hidden="true">image-20211027092222524</figcaption>
</figure>
<figure>
<img src="/.io//Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20211027092242701.png" alt="image-20211027092242701"><figcaption aria-hidden="true">image-20211027092242701</figcaption>
</figure>
<figure>
<img src="/.io//Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20211027105929960.png" alt="image-20211027105929960"><figcaption aria-hidden="true">image-20211027105929960</figcaption>
</figure>
<figure>
<img src="/.io//Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20211027105946262.png" alt="image-20211027105946262"><figcaption aria-hidden="true">image-20211027105946262</figcaption>
</figure>
<h2 id="模板">模板</h2>
<figure>
<img src="/.io//Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20211030172724604.png" alt="image-20211030172724604"><figcaption aria-hidden="true">image-20211030172724604</figcaption>
</figure>
<figure>
<img src="/.io//Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20211030173054674.png" alt="image-20211030173054674"><figcaption aria-hidden="true">image-20211030173054674</figcaption>
</figure>
<figure>
<img src="/.io//Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20211030173746509.png" alt="image-20211030173746509"><figcaption aria-hidden="true">image-20211030173746509</figcaption>
</figure>
<figure>
<img src="/.io//Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20211031101246245.png" alt="image-20211031101246245"><figcaption aria-hidden="true">image-20211031101246245</figcaption>
</figure>
<figure>
<img src="/.io//Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20211031101741998.png" alt="image-20211031101741998"><figcaption aria-hidden="true">image-20211031101741998</figcaption>
</figure>
<figure>
<img src="/.io//Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20211031104651606.png" alt="image-20211031104651606"><figcaption aria-hidden="true">image-20211031104651606</figcaption>
</figure>
<figure>
<img src="/.io//Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20211031104853068.png" alt="image-20211031104853068"><figcaption aria-hidden="true">image-20211031104853068</figcaption>
</figure>
<figure>
<img src="/.io//Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20211031110403838.png" alt="image-20211031110403838"><figcaption aria-hidden="true">image-20211031110403838</figcaption>
</figure>
<figure>
<img src="/.io//Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20211031110431568.png" alt="image-20211031110431568"><figcaption aria-hidden="true">image-20211031110431568</figcaption>
</figure>
<figure>
<img src="/.io//Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20211031110841773.png" alt="image-20211031110841773"><figcaption aria-hidden="true">image-20211031110841773</figcaption>
</figure>
<figure>
<img src="/.io//Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20211031111537579.png" alt="image-20211031111537579"><figcaption aria-hidden="true">image-20211031111537579</figcaption>
</figure>
<figure>
<img src="/.io//Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20211031112511357.png" alt="image-20211031112511357"><figcaption aria-hidden="true">image-20211031112511357</figcaption>
</figure>
<figure>
<img src="/.io//Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20211031112810468.png" alt="image-20211031112810468"><figcaption aria-hidden="true">image-20211031112810468</figcaption>
</figure>
<figure>
<img src="/.io//Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20211031112838946.png" alt="image-20211031112838946"><figcaption aria-hidden="true">image-20211031112838946</figcaption>
</figure>
<h1 id="算法">算法</h1>
<h3 id="冒泡排序">冒泡排序</h3>
<figure>
<img src="/.io//Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20211110222527770.png" alt="image-20211110222527770"><figcaption aria-hidden="true">image-20211110222527770</figcaption>
</figure>
<figure>
<img src="/.io//Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20211110224058824.png" alt="image-20211110224058824"><figcaption aria-hidden="true">image-20211110224058824</figcaption>
</figure>
]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title>Markdown使用记录</title>
    <url>/2022/10/21/%E7%BC%96%E7%A8%8B/Markdown/</url>
    <content><![CDATA[<h1 id="markdown的使用"><font face="Monaco">Markdown</font>的使用</h1>
<ul>
<li><a href="https://www.imooc.com/wiki/markdownlesson/markdowncolor.html"><font face="Monaco">Markdown</font> 前景色、背景色丨慕课网教程 (imooc.com)</a></li>
<li><a href="https://blog.csdn.net/weixin_41765578/article/details/120443879"><font face="Monaco">Markdown</font>笔记|自定义不同颜色的字体高亮|理Risen的博客-CSDN博客_</a></li>
<li></li>
</ul>
]]></content>
      <tags>
        <tag>markdown</tag>
      </tags>
  </entry>
  <entry>
    <title>Python</title>
    <url>/2022/10/21/%E7%BC%96%E7%A8%8B/Python/</url>
    <content><![CDATA[<h2 id="python">Python</h2>
<p>后续更新...</p>
]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Matlab</title>
    <url>/2022/10/21/%E7%BC%96%E7%A8%8B/Matlab/</url>
    <content><![CDATA[<h2 id="matlab">Matlab</h2>
<!-- <style>
blockquote {
  border-left: 2px dashed #333 !important;
  background:  #e4f2fe 0% !important;  
}
</style> -->
<h3 id="学习建议">学习建议</h3>
<h4 id="东北大学薛定宇教授"><u>东北大学薛定宇教授</u></h4>
<blockquote>
<p>[!TIP] <strong>带着问题学</strong>，活学活用，学用结合，<strong>急用先学</strong>，立竿见影，<strong>要在‘用’字上狠下工夫。</strong></p>
</blockquote>
<h4 id="网课某老师"><u>网课某老师</u></h4>
<blockquote>
<p>[!TIP] <strong>大家的目标不要想着成为什么 “<font face="Monaco">Matlab</font> 方面的大拿”，而是要用 <font face="Monaco">Matlab</font> 解决自己的学术或工程问题，从而变为自己领域内的“小能手”。</strong></p>
<p><strong>基础课的目的不在于精通，而是“知道有这么回事”</strong>，等你要用了，知道在哪能查到这个功能，然后再去试验。</p>
<p>学生的时间的确很宝贵，但是不能脑子里老是“拷问”自己，“这玩意该不该学啊，学了是不是浪费时间啊”，这么想太累了。</p>
</blockquote>
]]></content>
      <tags>
        <tag>Matlab</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux指令</title>
    <url>/2022/10/21/%E7%BC%96%E7%A8%8B/Ubuntu%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<figure>
<img src="https://cdn.staticaly.com/gh/peirsist/blog_img@master/linux参考命令.8ncy197uf9k.webp" alt="linux参考命令"><figcaption aria-hidden="true">linux参考命令</figcaption>
</figure>
<h2 id="linux常用命令">linux常用命令</h2>
<ul>
<li><p><a href="https://blog.csdn.net/weixin_41194129/article/details/107430369">完美解决ubuntu中文件夹加锁的情况_源代码杀手的博客-CSDN博客_ubuntu文件夹上锁</a></p></li>
<li><p>[<a href="https://blog.csdn.net/nan_xiaobai/article/details/99108689">Ubuntu]Linux下如何解决目录绿色高亮？_wqyolo的博客-CSDN博客_linux文件夹绿色高亮</a></p></li>
<li></li>
</ul>
<h3 id="解决文件夹带锁">解决文件夹带锁</h3>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo chmod 777 + 文件名</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>打羽毛球伤病预防</title>
    <url>/2022/10/29/%E7%BE%BD%E6%AF%9B%E7%90%83/00%E6%89%93%E7%BE%BD%E6%AF%9B%E7%90%83%E4%BC%A4%E7%97%85%E9%A2%84%E9%98%B2/</url>
    <content><![CDATA[<p><font size="5"><strong><font color="red">羽毛球鞋比球拍更重要！！！</font></strong></font></p>
<h2 id="脚后跟疼">脚后跟疼</h2>
<p>最近打完球不能快跑和单脚跳，一跳左脚就疼。</p>
<p>很多羽毛球爱好者由于没有受过正式的训练，在预防运动损伤及自我保护意识方面比较薄弱。比如打球过后，有的人会出现脚后跟疼的情况，下面就让我们一起了解一下原因及处理方法。</p>
<ol type="1">
<li><strong>着地姿势错误</strong></li>
</ol>
<p>在羽毛球场地上,处于运动状态时,正确的姿势应该是<strong>前脚掌着地</strong>的,这样做的目的是便于<strong>迅速在场上移动,提高速度</strong>,只有在大跨步上步时才会出现脚后跟先着地,然后前脚掌再缓冲中着地.。</p>
<p>因此，脚后跟疼很有可能是你姿势不对，脚后跟或满脚掌着地，这样对脚后跟的负面刺激较大。</p>
<ol type="1">
<li><strong>鞋子不合格</strong></li>
</ol>
<p>羽毛球场的地板多为木板或塑胶地面，为了获得更好的抓地力，羽毛球鞋大多使用<strong>牛筋底</strong>，这<strong>与常见跑鞋的防滑设计不一样</strong>，因为后者更多是针对水泥地面进行防滑设计，而且侧向的抓地力不如羽毛球鞋。<strong>鞋子和脚的舒适度有直接的关系</strong>，如果穿的鞋子不适合打羽毛球或是鞋子不够舒适的话，脚后跟自然容易疼，因此，在打球时尽量穿着柔软一点的羽毛球鞋。</p>
<h2 id="解决">解决</h2>
<ol type="1">
<li><strong>学习正规的羽毛球步法</strong></li>
</ol>
<p>打球的时候，起跳后落地时正确的姿势应该是<strong>前脚掌着地</strong>，<strong>切忌满脚掌着和脚后跟先着地</strong>,因为这样不仅容易脚后跟疼，还会让启动速度变慢,影响你的步伐效率。</p>
<ol start="2" type="1">
<li><strong>缩短运动时间，减少运动量</strong></li>
</ol>
<p>脚后跟疼时，首先<strong>停止打球一段时间</strong>，等脚部不适消除后，再次运动，每次运动时间缩短，并<strong>保证足够的休息间隔</strong>。<strong>羽毛球经常会快速起动，快速停步，所以脚跟受力还是很大的</strong>，有时候快速停位的时候，脚跟就受力更多。</p>
]]></content>
      <categories>
        <category>羽毛球</category>
      </categories>
      <tags>
        <tag>羽毛球</tag>
      </tags>
  </entry>
  <entry>
    <title>打好羽毛球总结-自己经验</title>
    <url>/2022/10/23/%E7%BE%BD%E6%AF%9B%E7%90%83/01-0%E6%89%93%E5%A5%BD%E7%BE%BD%E6%AF%9B%E7%90%83%E6%80%BB%E7%BB%93-%E8%87%AA%E5%B7%B1%E7%BB%8F%E9%AA%8C/</url>
    <content><![CDATA[<h1 id="前言">1 前言</h1>
<p>从2021年10月开始频繁的打羽毛球，想想在河大的时候，想打球的时候就去场上找人打，跟各种各样的人打，那时候水平真的提升的快，经常看羽毛球视频。到2022年9月上过几次羽毛球课。</p>
<p>经过一年，回想过去打球的经历，总结一下过去经验。</p>
<h1 id="总结自己的经验">2 总结（自己的经验）</h1>
<h2 id="基础">2.1 基础</h2>
<p>羽毛球最重要的是：（<strong>基础，基础最重要</strong>）</p>
<ol type="1">
<li><strong><font color="red">步伐</font></strong> 。七分步伐三分手法，非常重要。</li>
</ol>
<ul>
<li>交叉步和并步</li>
</ul>
<ol start="2" type="1">
<li><strong><font color="red">后场高远球、杀球的姿势</font></strong> 。首先侧身、架拍、挥拍。</li>
<li><strong><font color="red">体力</font></strong> 。</li>
</ol>
<p>难点在于如何在打球的时候 <strong>下意识</strong> 做出这些动作，只能靠日复一日的练习。</p>
<hr>
<h2 id="进阶">2.2 进阶</h2>
<ol type="1">
<li><strong>球路的变化</strong>，调动对手
<ul>
<li>球路要多样，以调动对手为主</li>
</ul></li>
<li><strong>接杀</strong>
<ul>
<li>正手接杀挡对角</li>
<li>正手接杀卸力挡网</li>
<li>反手接杀挡对角</li>
<li>反手接杀卸力挡网。后场起跳重杀，卸力挡网最好要刚刚贴网而过，破坏连贯。</li>
</ul></li>
<li><strong>一拍后场杀球</strong></li>
<li><strong>调动的意识</strong>，得经常训练，下意识</li>
<li><strong>发球推球</strong>
<ul>
<li>别人发球后，推球到后场</li>
</ul></li>
<li>如何做到不起球，贴网而过的球</li>
<li><strong>抢高点</strong></li>
<li><strong>低点回球</strong></li>
<li><strong>动作一致性</strong></li>
<li><strong>如何节省体力</strong> (依靠步伐和高质量回球)
<ul>
<li>高质量的回球让对手很难受，所以对手回球质量降低，你就不用快速的跑动</li>
<li>加上省力的步伐，就可以充分的节省体力。</li>
</ul></li>
<li><strong>反手</strong>
<ul>
<li>2022.10.30打球发现，球速慢反手可以，球速一快就不会了。说明反手关键在于跑到正确的位置</li>
</ul></li>
</ol>
<h2 id="技巧">2.3 技巧</h2>
<ol type="1">
<li>停顿放网</li>
<li>假放真推</li>
<li>假推真放</li>
<li>接杀挡对角</li>
<li>前后调动</li>
<li>重复落点</li>
<li>打转身</li>
<li>杀中路</li>
<li>抓推</li>
<li>变速</li>
<li>往前扑球</li>
</ol>
<hr>
<ol type="1">
<li>技术</li>
<li>战术</li>
<li>心理</li>
<li>能力</li>
</ol>
<p><strong>决定性作用：胜利的信念</strong></p>
<h1 id="每次打球记录总结">3 每次打球记录总结</h1>
<h2 id="section">3.1 <em>2022.10.30</em></h2>
<ol type="1">
<li>体力还是不行</li>
<li>鞋的重要性</li>
<li>反手</li>
<li>步伐还要再练</li>
</ol>
<hr>
<h2 id="section-1">3.2 <em>2022.11.05</em></h2>
<p><strong><font color="red">以下几点每次打球前都要复习一下，在场上刻意地用</font></strong></p>
<ol type="1">
<li><p><strong>侧身转体击球的意识还没有，还没有形成下意识</strong>。</p></li>
<li><p><strong>球不到位不要击球</strong>，最好的位置在肩膀上方，过了肩膀很难打好，就要依靠步伐及时到位击球。</p></li>
<li><p><strong>接杀挡对角，还没有形成下意识</strong>。接杀挡斜线是最好破坏连贯的方法，不要接杀又挑后场，因为对方会继续杀，要破坏他的连贯。</p></li>
<li><p>网前勾对角，没有形成下意识，其实是<strong>调动对手没有形成下意识</strong>。</p></li>
<li><p>不要老是挑球，挑球是示弱的表现。</p></li>
<li><p>缺少一拍后场的杀球。</p></li>
<li><p>打边线</p></li>
<li><p>弧度要低，不要只打高远球</p></li>
<li><p>低点击球，骗重心 参考下面这个视频：</p></li>
</ol>
<ul>
<li><a href="https://www.bilibili.com/video/BV1G14y1Y7dT/?spm_id_from=333.999.0.0&amp;vd_source=83831fc0970a6c8704479f7cfc679937">跟安徽省省运会单打冠军学习一下_哔哩哔哩_bilibili</a></li>
</ul>
<hr>
<h2 id="section-2">3.3 <em>2022.11.07</em></h2>
<ol type="1">
<li>今天不知道是鞋的原因还是什么原因，打的还可以</li>
<li>下一次继续注意:
<ol type="1">
<li><strong><font color="red">一致性，在击球前，不要让对手看出你要打什么球</font></strong></li>
<li><strong>不要起高球</strong></li>
<li><strong>高远球侧身转体发力</strong></li>
<li><strong>加上手法骗重心</strong></li>
<li><strong>低弧度打边线，逼对手回球不到位</strong></li>
<li><strong>连贯</strong></li>
<li>发力动作</li>
<li>接杀破坏连贯</li>
</ol></li>
</ol>
<hr>
<h2 id="section-3">3.4 <em>2022.11.18</em></h2>
<ol type="1">
<li>感觉球路还是少，停顿没有</li>
<li>打三个小时，体力就不行了</li>
</ol>
<h2 id="section-4">3.5 <em>2022.11.19</em></h2>
<ol type="1">
<li>反手</li>
<li>杀球</li>
<li>停顿</li>
</ol>
]]></content>
      <categories>
        <category>羽毛球</category>
      </categories>
      <tags>
        <tag>羽毛球</tag>
      </tags>
  </entry>
  <entry>
    <title>后场高远球</title>
    <url>/2022/10/25/%E7%BE%BD%E6%AF%9B%E7%90%83/01-1%E5%90%8E%E5%9C%BA%E9%AB%98%E8%BF%9C%E7%90%83/</url>
    <content><![CDATA[<ol type="1">
<li>侧身，架拍，展肩（下意识训练出来）</li>
<li>抬左手，抬左腿，重心放到右腿</li>
<li>左腿往下拉，再甩拍</li>
<li>上半身一定要往后拉，架拍为了展肩</li>
<li>腿越直，越没法发力，转不了身，用不上腰</li>
</ol>
<p>🔴 <strong>错误：</strong></p>
<blockquote>
<p>同步发力，右腿跳，甩右手</p>
</blockquote>
<p>🔵 <strong>链接：</strong></p>
<ol type="1">
<li><a href="https://www.bilibili.com/video/BV13C4y1t7Sn/?spm_id_from=333.999.0.0&amp;vd_source=83831fc0970a6c8704479f7cfc679937">羽毛球高远球教学之-五分钟教会你羽毛球高远球到底该怎么打！高远球打不到后场？看了视频后这个问题将不再存在！_哔哩哔哩_bilibili</a></li>
<li><a href="https://www.bilibili.com/video/BV1hZ4y1M7wB/?spm_id_from=333.999.0.0&amp;vd_source=83831fc0970a6c8704479f7cfc679937">羽毛球高远球教学之-教你如何转身挥拍！ 什么？！上一个视频你已经看完了？那来学学怎么转身打高远球吧！（没看上一个视频的一定要回去先看高远球教学视频噢）_哔哩哔哩_bilibili</a></li>
<li><a href="https://www.bilibili.com/video/BV1Z64y1F7Ys/?spm_id_from=333.999.0.0&amp;vd_source=83831fc0970a6c8704479f7cfc679937">高远球打不到位？转身挥拍老发不上力？来看看你是不是跟他们一样有同样的问题。_哔哩哔哩_bilibili</a></li>
<li></li>
</ol>
]]></content>
      <categories>
        <category>羽毛球</category>
      </categories>
      <tags>
        <tag>羽毛球</tag>
      </tags>
  </entry>
  <entry>
    <title>步伐</title>
    <url>/2022/10/25/%E7%BE%BD%E6%AF%9B%E7%90%83/01-2%E6%AD%A5%E4%BC%90/</url>
    <content><![CDATA[<h2 id="交叉步和并步">交叉步和并步</h2>
<p>并步，快速步伐，小步伐，球速比较快可以用</p>
<p>交叉步，大步步伐，适合球速慢的时候</p>
]]></content>
      <categories>
        <category>羽毛球</category>
      </categories>
      <tags>
        <tag>羽毛球</tag>
      </tags>
  </entry>
  <entry>
    <title>打高远球无力</title>
    <url>/2021/12/25/%E7%BE%BD%E6%AF%9B%E7%90%83/01-3%E6%89%93%E9%AB%98%E8%BF%9C%E7%90%83%E6%97%A0%E5%8A%9B/</url>
    <content><![CDATA[<p>2021年冬天和高个子球员打球，遇到以下问题： 被限制在后场，总是感觉没力气，经常被逼到球场的边缘，后场高远球又打的不到位，用力打但是总是打不远，只能打高是怎么回事，打到前场又被抓。🙁</p>
<p>以下答案来自<a href="https://www.zhihu.com/question/458575065">怎么样才能把羽毛球打得有力？ - 知乎 (zhihu.com)</a></p>
<hr>
<p>🔴 网友1</p>
<p><strong>无力感原因有三：</strong></p>
<ol type="1">
<li>没步伐，没被压在边缘的时候感觉击球有力吧！压在底线的时候，<strong>球在人后面，后仰去够球，拍面朝上，当然见高不见远。</strong></li>
</ol>
<blockquote>
<p>注：就在被吊那一天，和一个学长打双打，他告诉我最好的击球点在肩部正上方，球会往前走，球过头顶，再击球，球只会往上走。那天他还交了我如何后场吊到前场，但是后场吊到前场不要经常用。</p>
</blockquote>
<ol start="2" type="1">
<li>打不远那球的前一拍球打的太渣（后场不到位，网前球太高，过网速度慢），给自己挖了个坑，没有能力跳出坑。</li>
<li>对手实力比你强。打比自己强的对手有这种感觉非常正常。</li>
</ol>
<p><strong>解决方式：</strong></p>
<ol type="1">
<li>练习回位脚步，后退步伐，在<strong>合适位置</strong>击球当然能打得出力量，球速。</li>
<li>被压到底线要学会变通，没有能力回后场球，可以吊两个网前，如果过网质量尚可，下个球还能挣扎。</li>
<li><strong>练习力量</strong>，增强击球效率，平时要有在底线轻松将球打出界的能力。</li>
<li>感谢对手给你这种无力感，会激励你进步。</li>
</ol>
<p>想击球有力，和挥拍动作，步伐，发力方式，击球点息息相关，想要变得更强，单单网上问，看视频不行。<strong>一定要将纸面知识运用于实战，不断重复不断练习，没有捷径，只能少点弯路。</strong></p>
<hr>
<p>🟠 网友2</p>
<p>首先，你说这个是 <strong><u>单打虐菜的基本拉吊打法，拉高远逼你去后场，再吊网前逼你救球；最大幅度调动你满场跑，耗你体力。一般这么打，通常水平上是碾压你的。</u></strong></p>
<p>你的问题是对的，对于这种打法，只要你水平上去了，对方拉吊不过你，自然可以和他硬钢.</p>
<ol type="1">
<li>多练，练高远球（<strong>练到后场能回到对方后场</strong>），正反手挑球（中场挑到对方后场）</li>
<li><strong>全场步伐</strong></li>
<li>战术应对，打羽毛球节奏很重要，对方拉吊你，基本上都能预判到你的回球路线了，你不能再顺着对方打了。<strong>回球路线要灵活多变</strong>，他给你后场，你可以吊个网前，他吊你网前，你可以钩个对角；把对方也调动起来，你得分的机会可能更多一些。</li>
<li><strong>发力</strong>：全套的高远球发力是： 架拍瞄准&gt;转体侧身&gt;右脚蹬地&gt;扭腰转身&gt;轮大臂&gt;转小臂&gt;掰手腕&gt;搓手指&gt;击球</li>
</ol>
<p>激烈对抗是可能没有充足的时间做全套动作；随着你技术提升，可以逐渐依次省略前续步骤，请量力而行；但想铆足了劲儿全力一击，还请做全套动作。</p>
<figure>
<img src="https://pic1.zhimg.com/50/v2-ffa298d217a485fdf6afca4b8f2f59e2_720w.webp?source=1940ef5c" alt="击球姿势"><figcaption aria-hidden="true">击球姿势</figcaption>
</figure>
<hr>
<p>🟡 网友3</p>
<p>一个完整的击球流程可以分为四步：启动、移动、击球、回动，很多人只重视移动和击球这两步，却忽视启动和回动的重要性，这是非常错误的。事实上，启动步是步法中最重要的一环没有之一，只要能在合适的时间做合适的启动，移动的步法就是水到渠成的； <strong><font color="red">而回动和下一球启动间的衔接，是步法的精髓。</font></strong>相信有一定球龄和水平的球友都能理解我的话</p>
<p><img src="https://cdn.staticaly.com/gh/peirsist/blog_img@master/启动移动击球回动.4r0yxw3ky7m0.webp"></p>
<hr>
<p>🟢 网友4</p>
<p>打羽毛球不只是看哪一方面的</p>
<p>光有力气不行，光有技术没力量也不行</p>
<p>技术力量都有了，没有步伐也不行</p>
<p>你经常被逼到边缘说明技术不如对面</p>
<p>被近球搞定说明步伐没练</p>
<p>用力打但总打不远是因为发力不对</p>
<p>这些问题都不是一个窍门能解决的</p>
<p>要么找个教练学</p>
<p>要么自己网上找教程，<strong>从基础步伐开始练</strong></p>
<p>步伐练好了，你说的被近球搞定就基本解决了</p>
<p><a href="https://www.zhihu.com/search?q=发力技巧&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A2097489538%7D">发力技巧</a>那些等基本步伐练好在练也不晚，网上也有很多教程</p>
]]></content>
      <categories>
        <category>羽毛球</category>
      </categories>
      <tags>
        <tag>羽毛球</tag>
      </tags>
  </entry>
  <entry>
    <title>雅思题型了解及准备</title>
    <url>/2022/10/31/%E8%8B%B1%E8%AF%AD%E5%AD%A6%E4%B9%A0/%E4%BA%86%E8%A7%A3%E9%9B%85%E6%80%9D/</url>
    <content><![CDATA[<h1 id="1-为什么考"><a href="#1-为什么考" class="headerlink" title="1 为什么考"></a>1 为什么考</h1><p>很早就有考雅思的想法，这次别再犹豫了，以后自己的时间越来越少。<br>关于是否报辅导机构，根据我的报过大英赛以及大一报英语班被人骗过的经历，大英赛的直播的课其实没什么用，直播讲得其实就是方法，会不会还得靠自己去练。但是那段时间坚持学英语，确实让英语水平提升了。英语学习<strong>一要正确的方法，二要坚持</strong>。所以辅导机构不用报了，你的基础也还可以。如何备考，自己查就行。大一的时候，yu自己留学申请都是自己准备的，<strong>开始总比不开始好</strong>。</p>
<p><a href="https://www.zhihu.com/question/335517100">学习雅思报哪个机构好？ - 知乎 (zhihu.com)</a><br><a href="https://www.zhihu.com/question/551794049">洋葱雅思怎么样？ - 知乎 (zhihu.com)</a></p>
<p><a href="https://ielts.neea.edu.cn/">雅思网上报名 - 教育部教育考试院 (neea.edu.cn)</a><br><a href="https://ielts.neea.cn/">雅思网上报名 - 教育部教育考试院 (neea.cn)</a><br><a href="https://www.chinaielts.org/#">雅思考试(IELTS)中文官方网站 (chinaielts.org)</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/87447951">第一次考雅思？雅思首考小白必看！！！ - 知乎 (zhihu.com)</a></p>
<hr>
<h1 id="2-经验"><a href="#2-经验" class="headerlink" title="2 经验"></a>2 经验</h1><blockquote>
<ol>
<li><strong><a href="https://www.bilibili.com/video/BV1JK411m7Nq/?spm_id_from=333.880.my_history.page.click&vd_source=83831fc0970a6c8704479f7cfc679937">【雅思机考2个月拿下7.5】全新方法论讲解，低成本无纸化复习，内含所有资料_哔哩哔哩_bilibili</a></strong></li>
<li><strong><a href="https://www.bilibili.com/video/BV1EP4y1273t/?spm_id_from=333.1007.top_right_bar_window_history.content.click&vd_source=83831fc0970a6c8704479f7cfc679937">【绝密雅思资料免费公开】小作文上6.5必备法宝，超多干货！_哔哩哔哩_bilibili</a></strong></li>
<li><a href="https://www.bilibili.com/video/BV15S4y1T7Tf/?spm_id_from=333.788&vd_source=83831fc0970a6c8704479f7cfc679937">【雅思经验第一弹】超全雅思备考小白避坑指南| 零基础入门 |全方位扫盲_哔哩哔哩_bilibili</a></li>
<li><a href="https://www.bilibili.com/video/BV1sh411s7PQ/?spm_id_from=333.788&vd_source=83831fc0970a6c8704479f7cfc679937">【雅思经验第三弹】yyds！速领雅思备考计划Excel表 |听说读写时间规划全覆盖 |保姆式有进度条划分_哔哩哔哩_bilibili</a></li>
<li><a href="https://www.bilibili.com/video/BV1M34y1Z7du/?vd_source=83831fc0970a6c8704479f7cfc679937">【雅思经验第二弹】雅思问题Q&amp;A | 搜集了大家问的最多的几个问题_哔哩哔哩_bilibili</a></li>
<li><a href="https://www.bilibili.com/video/BV1P64y1z7cu/?spm_id_from=333.337.search-card.all.click&vd_source=83831fc0970a6c8704479f7cfc679937">雅思备考快速冲分攻略｜书籍推荐｜网课推荐｜个人建议｜评论区有惊喜哟_哔哩哔哩_bilibili</a></li>
<li><strong><a href="https://www.bilibili.com/video/BV1zP4y1K7Aq/?spm_id_from=333.337.search-card.all.click&vd_source=83831fc0970a6c8704479f7cfc679937">8.5分清华学长，详尽无比雅思备考规划，一定考出来！_哔哩哔哩_bilibili</a></strong></li>
</ol>
</blockquote>
<h2 id="如何背单词"><a href="#如何背单词" class="headerlink" title="如何背单词"></a>如何背单词</h2><ol>
<li><a href="https://www.zhihu.com/question/406092879">有哪些高质量的雅思词汇书? - 知乎 (zhihu.com)</a></li>
<li><a href="https://www.zhihu.com/people/paul-winterbottom">Paul Winterbottom - 知乎 (zhihu.com)</a></li>
<li><strong><a href="https://www.zhihu.com/question/28732131/answer/2753702877">如何高效背「雅思词汇」，有哪些雅思词汇值得推荐？ - 知乎 (zhihu.com)</a></strong></li>
<li></li>
</ol>
<p>丢掉丢掉传统的死记硬背法，采用词根词缀➕情景记忆➕声象记忆等多重联合记忆法。不仅背单词，轻松愉快，更能从深层次掌握单词实际运用。</p>
<h1 id="3-资料"><a href="#3-资料" class="headerlink" title="3 资料"></a>3 资料</h1><ol>
<li><a href="https://www.xuebapan.com/info/40374e648950901a59e7b23df6fc3285.html">【绝版】刘洪波阅读真经9分班网盘资源下载 - 学霸盘 (xuebapan.com)</a></li>
<li>🔴 <strong><a href="https://zhuanlan.zhihu.com/p/33893805">来自一只老烤鸭的雅思经验贴（5.5-7.5） - 知乎 (zhihu.com)</a></strong></li>
<li><a href="https://bbs.pinggu.org/thread-7071629-1-1.html">分享雅思刘洪波阅读写作真经课（绝版） - 外语学习 - 经管之家(原人大经济论坛) (pinggu.org)</a></li>
<li><a href="https://www.ieltsday.com/6880.html">刘洪波-《IELTS雅思词汇真经》 - 开源雅思 (ieltsday.com)</a></li>
<li></li>
</ol>
<h1 id="4-如何备考"><a href="#4-如何备考" class="headerlink" title="4 如何备考"></a>4 如何备考</h1><p><img src="https://cdn.staticaly.com/gh/peirsist/blog_img@master/%E9%9B%85%E6%80%9D%E5%A4%87%E8%80%83.5qnuw46v0ds0.png"></p>
<h1 id="5-初期准备阶段"><a href="#5-初期准备阶段" class="headerlink" title="5 初期准备阶段"></a>5 初期准备阶段</h1><h2 id="5-1-是否报班"><a href="#5-1-是否报班" class="headerlink" title="5.1 是否报班"></a>5.1 是否报班</h2><ol>
<li>线下班  ❌</li>
<li>网课班 ✅<ol>
<li>口语：Tara</li>
<li>写作：徐卫</li>
<li>阅读：王希伟</li>
<li>听力：何琼，总结的技巧很受用</li>
</ol>
</li>
</ol>
<p>听力是一个技巧性很强的科目</p>
<p>🔴 <strong><font color="red">Warning</font></strong></p>
<blockquote>
<p>选定一位老师的课程，就不要再听别的老师的了，每一为老师都有自己的授课风格，一套思路。尤其是写作和口语，写作和口语是输出项</p>
</blockquote>
<h2 id="5-2-书籍"><a href="#5-2-书籍" class="headerlink" title="5.2 书籍"></a>5.2 书籍</h2><ol>
<li>真题类<ol>
<li>剑桥雅思官方真题4-16</li>
</ol>
</li>
<li>辅导类<ol>
<li>没有必要买，因为和网课的内容是重复的，提升的效果不是很大，消耗精力</li>
</ol>
</li>
<li>单词书<ol>
<li><a href="https://zhuanlan.zhihu.com/p/548241358">刘洪波雅思阅读538考点词，高清PDF可打印 - 知乎 (zhihu.com)</a></li>
<li><a href="https://www.zhihu.com/question/431595764">大家觉得雅思刘洪波538考点词和179听力有用吗，因为有老师和我说没用，现在纠结要不要背，谢谢大家? - 知乎 (zhihu.com)</a></li>
<li></li>
</ol>
</li>
</ol>
<h2 id="5-3-APP"><a href="#5-3-APP" class="headerlink" title="5.3 APP"></a>5.3 APP</h2><ol>
<li>每日英语听力<ol>
<li>剑桥雅思听力集合</li>
<li>九分达人听力集合</li>
<li>刷题时候以1.2倍速听，考场上的难度和速度是高于真题集的</li>
</ol>
</li>
<li>雅思哥 <ol>
<li>考场回忆。每一场考试后都有同学去回忆考的是什么，也会有口语题库</li>
</ol>
</li>
<li>欧陆词典</li>
<li>flip timer<ol>
<li>刷题的时候以倒计时的方式，严格按照考试的时间来，在规定的时间内做完题，并且把答案腾到答题卡上，模拟考场的紧张感</li>
</ol>
</li>
</ol>
<h1 id="6-中期集中备考复习阶段"><a href="#6-中期集中备考复习阶段" class="headerlink" title="6 中期集中备考复习阶段"></a>6 中期集中备考复习阶段</h1><h2 id="6-1-刷题"><a href="#6-1-刷题" class="headerlink" title="6.1 刷题"></a>6.1 刷题</h2><ol>
<li>刷剑桥雅思足够</li>
<li>4-14按照顺序依次来刷，剑8之后，难度上一个level，剑11之后难度又上升一个level。</li>
<li>听力倍速。</li>
<li>阅读60分钟倒计时做完并且把答案填到答题卡上。</li>
<li>写作要写，批改</li>
</ol>
<h2 id="6-2-是否购买批改模考预测"><a href="#6-2-是否购买批改模考预测" class="headerlink" title="6.2 是否购买批改模考预测"></a>6.2 是否购买批改模考预测</h2><ol>
<li>批改作文需要。不要大机构，小工作室可以</li>
<li>推荐模拟口语，知道口语又哪些错误和不太好的表现</li>
</ol>
<h2 id="6-3-背诵要注意的事情"><a href="#6-3-背诵要注意的事情" class="headerlink" title="6.3 背诵要注意的事情"></a>6.3 背诵要注意的事情</h2><ol>
<li>每一科都需要背诵</li>
<li>口语<ol>
<li>背一些好的词搭</li>
<li>形成自己的答案</li>
</ol>
</li>
<li>听力<ol>
<li>背同义替换。何琼雅思网课里附带的。</li>
</ol>
</li>
<li>阅读<ol>
<li>单词，真题里的即可</li>
<li>同义替换</li>
</ol>
</li>
<li>写作<ol>
<li>素材</li>
<li>高级搭配</li>
</ol>
</li>
</ol>
<h2 id="6-4-报名"><a href="#6-4-报名" class="headerlink" title="6.4 报名"></a>6.4 报名</h2><ol>
<li>报名要提前。12月份的考试，11月多点就已经没有位置了。</li>
<li>雅思考试是分季度的，一个季度它的口语话题会替换掉，所以尽量在12月份尽量考出来，考不出来，到1月份准备的话，要重新准备新的口语话题。</li>
<li>考场选择。分为国内考和国外考<ol>
<li>不要选大城市。众所周知，国内压分在口语和写作这两项上。不要选北上广这种城市，因为压分，去三四线的小城市，给分会好一点</li>
<li>也不要选语言类大学。</li>
</ol>
</li>
<li>考试类型<ol>
<li>普通雅思A类</li>
<li>普通雅思G类，移民用的</li>
<li>UKVI</li>
</ol>
</li>
<li>机考和笔试<ol>
<li>机考出分快一周左右，不适合打字慢的人，需要长时间盯着电子屏幕做阅读（我真的哭了）</li>
<li>笔试，写写画画</li>
</ol>
</li>
</ol>
<h1 id="7-临近考试阶段"><a href="#7-临近考试阶段" class="headerlink" title="7 临近考试阶段"></a>7 临近考试阶段</h1><h2 id="7-1-转考退考"><a href="#7-1-转考退考" class="headerlink" title="7.1 转考退考"></a>7.1 转考退考</h2><ol>
<li>都要交手续费400大洋…….</li>
</ol>
<h2 id="7-2-口语预约"><a href="#7-2-口语预约" class="headerlink" title="7.2 口语预约"></a>7.2 口语预约</h2><ol>
<li>以邮件的形式</li>
</ol>
<h2 id="7-3-打印准考证"><a href="#7-3-打印准考证" class="headerlink" title="7.3 打印准考证"></a>7.3 打印准考证</h2><ol>
<li>提前打印</li>
</ol>
<h2 id="7-4-考试当天注意事项"><a href="#7-4-考试当天注意事项" class="headerlink" title="7.4 考试当天注意事项"></a>7.4 考试当天注意事项</h2><ol>
<li>不要多喝水，因为会很紧张，时间也长，会上厕所</li>
<li>考口语之前和考完之后不要说话，否则判为作弊！！！</li>
<li>阅读的时候，严格按照老师的指令来</li>
</ol>
<h2 id="7-5-成绩复议"><a href="#7-5-成绩复议" class="headerlink" title="7.5 成绩复议"></a>7.5 成绩复议</h2><ol>
<li>手续费1400大洋</li>
</ol>
<hr>
<p>雅思老师来说一下，up说得很实在也很具体，对于考雅思的小白同学绝对值得参考。<br>另外有一些补充：  </p>
<ol>
<li><p>关于刷题。<br>不要盲目刷题，刷题基本上分为三个阶段，主要是听力阅读两科。<br>（1）纯小白，最开始随机做两三套题：了解考试题型难度等，同时对自己现在的能力和目标分数之间的差距有大致的概念。并且不要过于在意分数：网络上传播最广的自然是绝对的高分能力者，但是这不是现实。<br>（2）正式备考阶段：<br>首先，练习是循序渐进的：比如阅读第一篇是最简单的，那如果第一篇都做不好就没有必要强行做后两篇。听力1、2部分没有较好的把握能力就不要强刷3、4部分。否则就只是在浪费题目。<br>其次，也是最重要的部分，这个步骤的刷题不是单纯在做题、堆积数量，而是通过错题发现问题，并且分析自己的错误原因，然后解决问题，再继续做题验证问题是否得到解决。能力和策略方法才是得分的关键，换句话说，能力在那个地方没有做过的题也能得分，反过来没有真正提升能力、掌握方法的话刷再多的题也很难见到效果。<br>尤其是备考时间短的同学，切忌盲目刷题。在备考一段时间之后，好好想想你是否知道你各科的具体问题，是否有在针对性地练习解决，如果答案是否定的，那可能问题很大。  </p>
</li>
<li><p>关于同义替换，同义替换的本质就是表达多样性，无处不在。基础类的同义替换可以去背单词，但是追求绝对高分（大概目标分7.5以上）的同学要知道，灵活类的同义替换是没法死记硬背的。  </p>
</li>
<li><p>背单词。<br>这方面up讲得很具体了，我只说两点。<br>（1）不管你用什么工具，背单词的核心是多重复，要少量多餐而不是一次吃到吐。<br>（2）四科词汇背单词的方法要严格区分开来，搞清楚各科词汇的重点。</p>
</li>
</ol>
<p>加油，祝大家顺利拿到想要的分数。</p>
<hr>
<ol>
<li><a href="https://www.bilibili.com/video/BV1c54y187SH/?vd_source=83831fc0970a6c8704479f7cfc679937">雅思备考，先看完雅思教父刘洪波的雅思真经第一课。备考雅思|雅思听力|雅思口语|雅思写作|雅思阅读|新东方雅思|新航道雅思|顾家北写作|雅思书籍app_哔哩哔哩_bilibili</a></li>
<li></li>
</ol>
<h1 id="8-关于雅思"><a href="#8-关于雅思" class="headerlink" title="8 关于雅思"></a>8 关于雅思</h1><p>1、 雅思分为学术类和普通类雅思，留学一般考学术类<br>2、雅思的分为听说读写 4 个部分，每部分的满分为 9 分，总分是 4 项成绩相加除以 4。整体来说，全球大学对雅思的平均要求是总分 6.5 分，听说读写每门不低于 6 分。  </p>
<h1 id="9-各部分如何备考"><a href="#9-各部分如何备考" class="headerlink" title="9 各部分如何备考"></a>9 各部分如何备考</h1><h2 id="9-1-听力。"><a href="#9-1-听力。" class="headerlink" title="9.1 听力。"></a>9.1 听力。</h2><p>（1）听力分为4个section。<br>Section1:10道题，生活场景，双人对话形式<br>Section2:生活场景，单人介绍<br>Section3:学习场景，双人教师和学生的讨论<br>Section4:学习场景，单人教授讲授学科<br>（2）备考<br>S1和S3：场景相对固话，<br>S2和S4：相对难预测<br>可能出现的问题和解决措施：<br>听不懂：高频单词的听觉不敏感。解决措施：<strong>精听跟读，即一周只做一套听力或 s1，听一遍，再拿着原文听力对照听，只要是反应滞后的单词全部划记出来，将划记出来的单词反复读</strong>。<br><strong><font color="red">任务：一天至少将 50 个听力核心单词变为和 and 一样的熟悉级别。</font></strong><br>听不到：对雅思考点不熟悉<br>写不对<br>资料：刘洪波《雅思听力考点词真经179》——将听力中的同义替换和高频词筛选出来了<br>王陆《雅思王听力真题预料库》  </p>
<h2 id="9-2-阅读"><a href="#9-2-阅读" class="headerlink" title="9.2 阅读"></a>9.2 阅读</h2><p>（1） 阅读共3篇，40题，共60分钟，4大题型：单词题、句子题、断落题、匹配题<br>（2） 备考<br>资料：刘洪波《剑桥雅思阅读考点词真经 538》,——归纳了阅读中常考的词汇和同义替换  </p>
<h2 id="9-3-写作"><a href="#9-3-写作" class="headerlink" title="9.3 写作"></a>9.3 写作</h2><p>（1） 写作分为大作文250字和小作文150字<br>小作文分为：曲线图、饼图、柱状图、表图<br>大作为一般是议论文，偶尔也有议论文<br>（2） 雅思评分标准：谋篇布局、逻辑、词汇、语法  </p>
<h2 id="9-4-口语"><a href="#9-4-口语" class="headerlink" title="9.4 口语"></a>9.4 口语</h2><p>（1） 三个部分，P1为5分钟的基本寒暄、P2抽卡片回答问题、P3就话题进行深入交流<br>（2） 备考<br>资料：雅思口语真经总纲<br>背诵输入、句型为重——句型能帮助你放到任何话题中、自然放松、逻辑沟通  </p>
<h1 id="10-备考的基本逻辑"><a href="#10-备考的基本逻辑" class="headerlink" title="10 备考的基本逻辑"></a>10 备考的基本逻辑</h1><p>1、 <strong>修炼内功</strong>：搭配记忆—这样写作和口语才能适当应用，放到文章中记忆。回忆小学如何增加词汇<br>2、 <strong>掌握技巧</strong>：真经总纲、阅读考点词538、真经5预测、写作总纲、口语总纲、听力179词汇<br>3、 <strong>真题模考</strong><br>4、 <strong>考前预测</strong></p>
<p><strong>你做题 vs 考试 :)</strong><br><img src="https://cdn.staticaly.com/gh/peirsist/blog_img@master/Pasted-image-20221111213429.1eojyj6bge2o.png" alt="Pasted-image-20221111213429"></p>
]]></content>
      <categories>
        <category>英语</category>
      </categories>
      <tags>
        <tag>雅思</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构视频</title>
    <url>/2022/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<h2 id="视频">视频</h2>
<ul>
<li><p><a href="https://www.bilibili.com/video/BV1MK411j7CR?spm_id_from=333.1007.top_right_bar_window_history.content.click">数据结构：懒猫老师-数据结构-(34)哈夫曼树(Huffman Tree,霍夫曼树,赫夫曼树)_哔哩哔哩_bilibili</a></p></li>
<li><p><a href="https://zhuanlan.zhihu.com/p/387679625">数据结构：懒猫老师-数据结构-(34)哈夫曼树(PPT文稿) - 知乎 (zhihu.com)</a></p></li>
<li><p><a href="https://www.bilibili.com/video/BV1nJ411V7bd?from=search&amp;seid=2456030176850049565&amp;spm_id_from=333.337.0.0">数据结构：数据结构与算法基础（青岛大学-王卓）_哔哩哔哩_bilibili</a></p></li>
<li><p><a href="https://blog.csdn.net/qq_28114615/article/details/86633509">前缀树(字典树)应用——实现 Trie (前缀树)、添加与搜索单词_HerofH_的博客-CSDN博客</a></p></li>
</ul>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
  </entry>
  <entry>
    <title>URL和URI的区别</title>
    <url>/2022/05/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/URI%E5%92%8CURL%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<h2 id="url和uri的区别">URL和URI的区别</h2>
<h3 id="uri">URI</h3>
<ul>
<li><strong>定义</strong>：统一资源标志符(<code>Uniform Resource Identifier， URI</code>)，表示的是web上每一种可用的资源，如 HTML文档、图像、视频片段、程序等都由一个URI进行标识的。</li>
<li><strong>如何理解</strong>：
<ul>
<li><code>Identifier</code>标识符，那就是用来标识的，唯一作用就是标识某个资源。</li>
<li>那么按照什么方式、以什么标准去标识？
<ul>
<li>用<strong>定位</strong>的方式：URL (Uniform Resource <code>Locator</code>)</li>
<li>用<strong>命名</strong>的方式：URN (Uniform Resource <code>Name</code>)</li>
</ul></li>
</ul></li>
</ul>
<h3 id="url">URL</h3>
<ul>
<li><p><strong>定义</strong>：统一资源定位符(<code>Uniform Resource Locator，URL</code> )，用于表示互联网上某一资源的网址。简单来说，<code>URL</code>就是<strong>网址</strong>。</p></li>
<li><p><strong>格式</strong>：</p>
<ul>
<li><p>协议<code>://</code>服务器地址<code>:</code>端口号<code>/</code>路径<code>/</code>文件名<code>?</code>查询参数<code>#</code>片段。</p>
<p>protocol <code>://</code> hostname[<code>:</code>port]<code>/</code>path <code>/</code>[;parameters] [<code>?</code>query]<code>#</code>fragment</p></li>
<li><p>参数在<code>?</code>之后开始，使用<code>参数名=参数值</code>的方式，多个参数用<code>&amp;</code>隔开。</p></li>
<li><p><code>#</code>左边部分是浏览器可以从服务器下载的资源。</p></li>
<li><p><code>#</code>右边部分是片段标识符。片段表示资源的某一位置，与从服务器返回的资源无关。</p></li>
<li><p>端口号、查询、片段ID都属于选填项。</p></li>
</ul></li>
</ul>
<blockquote>
<p>[!Note|style:callout|label:总结] <code>URI</code>和<code>URL</code>都定义了资源是什么，但<code>URL</code>还定义了该如何访问资源。<code>URL</code>是一种具体的<code>URI</code>，它是<code>URI</code>的一个子集，它不仅唯一标识资源，而且还提供了定位该资源的信息。</p>
</blockquote>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
  </entry>
  <entry>
    <title>生词</title>
    <url>/2022/10/21/%E8%8B%B1%E8%AF%AD%E5%AD%A6%E4%B9%A0/%E7%94%9F%E8%AF%8D/</url>
    <content><![CDATA[<h3 id="科研中的生词">科研中的生词</h3>
<p><code>unicast</code> 单播</p>
<p><code>Ethernet</code> 以太网</p>
<p><code>unicast reliability feature</code> 单播可靠性功能</p>
<p><code>parse</code> 解析[电子、计算机、通信]</p>
]]></content>
      <categories>
        <category>英语</category>
      </categories>
      <tags>
        <tag>生词</tag>
      </tags>
  </entry>
  <entry>
    <title>英语学习方法</title>
    <url>/2022/10/21/%E8%8B%B1%E8%AF%AD%E5%AD%A6%E4%B9%A0/%E5%90%AC%E5%8A%9B/</url>
    <content><![CDATA[<ul>
<li><p>👉<a href="https://mp.weixin.qq.com/s/kcG36rL8G3CXVxT27ptrxQ">英语听、说、读、写完整学习思路—【学英语那点事】微信公众号</a></p></li>
<li><p>👉<a href="https://mp.weixin.qq.com/s/ZDpUzAD-Pq9dnMPK11C2tw">英语听力不好的朋友看过来—【学英语那点事】微信公众号</a></p></li>
<li><p>👉<a href="https://mp.weixin.qq.com/s/H1AzYxw22eYRuC5fzhCWeA">还是听力—【学英语那点事】微信公众号</a></p></li>
<li><p>👉<a href="https://mp.weixin.qq.com/s/edq2Td458ibvTLPgXsd7dw">口语—【学英语那点事】微信公众号</a></p></li>
<li><p>👉<a href="https://mp.weixin.qq.com/s/j1R5oIkiZlTQauIKT5T9Og">英语学习要回归到句子上—【学英语那点事】微信公众号</a></p></li>
<li><p>👉<a href="https://mp.weixin.qq.com/s/-Kr15Zt-KZQkACQpFdIanA">一个戒掉手机的好办法：—【学英语那点事】微信公众号</a></p></li>
</ul>
]]></content>
      <categories>
        <category>英语</category>
      </categories>
      <tags>
        <tag>听力</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机组成原理</title>
    <url>/2022/06/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<h1 id="计算机组成原理">计算机组成原理</h1>
<!-- [TOC] -->
<h3 id="说明">说明</h3>
<p>此课程参考<a href="https://www.bilibili.com/video/BV1BE411D7ii?p=2">王道计算机考研 计算机组成原理_哔哩哔哩_bilibili</a>， 其中所出现的图片均是学习过程中的截图，放到网页上，以便随时随地地复习。</p>
<h3 id="正文">正文</h3>
<p><a href="https://imgtu.com/i/ORpONd"><img src="https://s1.ax1x.com/2022/05/15/ORpONd.png" alt="ORpONd.png"></a></p>
<p>硬件上的一个个的金属针脚就是用来传递电信号，传递一个个的高低电平，来代表<code>0、1</code>信号，<code>0、1</code>信号传到电路内部，就会使得相应的晶体管导通、截止，就会形成相应的电路，用来处理数据。</p>
<p>计算机在运算的时候，实际上就是在处理电信号，处理电信号的是晶体管（以前是电子管），使用用晶体管组成的电路来进行运算。</p>
<ul>
<li>电子管时代。体积大、耗电大，运算速度慢</li>
</ul>
<p><a href="https://imgtu.com/i/ORpX4A"><img src="https://s1.ax1x.com/2022/05/15/ORpX4A.png" alt="ORpX4A.png"></a> <a href="https://imgtu.com/i/ORpx3t"><img src="https://s1.ax1x.com/2022/05/15/ORpx3t.png" alt="ORpx3t.png"></a> <a href="https://imgtu.com/i/ORpv9I"><img src="https://s1.ax1x.com/2022/05/15/ORpv9I.png" alt="ORpv9I.png"></a> ### 硬件的发展 <a href="https://imgtu.com/i/ORpLAH"><img src="https://s1.ax1x.com/2022/05/15/ORpLAH.png" alt="ORpLAH.png"></a> <a href="https://imgtu.com/i/ORpzgP"><img src="https://s1.ax1x.com/2022/05/15/ORpzgP.png" alt="ORpzgP.png"></a> <a href="https://imgtu.com/i/OR99u8"><img src="https://s1.ax1x.com/2022/05/15/OR99u8.png" alt="OR99u8.png"></a> <a href="https://imgtu.com/i/OR9Sjf"><img src="https://s1.ax1x.com/2022/05/15/OR9Sjf.png" alt="OR9Sjf.png"></a> <a href="https://imgtu.com/i/OR9CDS"><img src="https://s1.ax1x.com/2022/05/15/OR9CDS.png" alt="OR9CDS.png"></a> <a href="https://imgtu.com/i/OR9PHg"><img src="https://s1.ax1x.com/2022/05/15/OR9PHg.png" alt="OR9PHg.png"></a> <a href="https://imgtu.com/i/OR9FEQ"><img src="https://s1.ax1x.com/2022/05/15/OR9FEQ.png" alt="OR9FEQ.png"></a> <a href="https://imgtu.com/i/OR9kNj"><img src="https://s1.ax1x.com/2022/05/15/OR9kNj.png" alt="OR9kNj.png"></a> <a href="https://imgtu.com/i/OR9A4s"><img src="https://s1.ax1x.com/2022/05/15/OR9A4s.png" alt="OR9A4s.png"></a> ### 软件的发展 <a href="https://imgtu.com/i/OR9VCn"><img src="https://s1.ax1x.com/2022/05/15/OR9VCn.png" alt="OR9VCn.png"></a> <a href="https://imgtu.com/i/OR9Z3q"><img src="https://s1.ax1x.com/2022/05/15/OR9Z3q.png" alt="OR9Z3q.png"></a> <a href="https://imgtu.com/i/OR9eg0"><img src="https://s1.ax1x.com/2022/05/15/OR9eg0.png" alt="OR9eg0.png"></a> <a href="https://imgtu.com/i/OR9mvV"><img src="https://s1.ax1x.com/2022/05/15/OR9mvV.png" alt="OR9mvV.png"></a> ### 计算机基本组成</p>
<p><a href="https://imgtu.com/i/OR9uuT"><img src="https://s1.ax1x.com/2022/05/15/OR9uuT.png" alt="OR9uuT.png"></a> <a href="https://imgtu.com/i/OR9MbF"><img src="https://s1.ax1x.com/2022/05/15/OR9MbF.png" alt="OR9MbF.png"></a> <a href="https://imgtu.com/i/OR9KDU"><img src="https://s1.ax1x.com/2022/05/15/OR9KDU.png" alt="OR9KDU.png"></a> <a href="https://imgtu.com/i/OR9lE4"><img src="https://s1.ax1x.com/2022/05/15/OR9lE4.png" alt="OR9lE4.png"></a> <a href="https://imgtu.com/i/OR91UJ"><img src="https://s1.ax1x.com/2022/05/15/OR91UJ.png" alt="OR91UJ.png"></a> <a href="https://imgtu.com/i/OR9359"><img src="https://s1.ax1x.com/2022/05/15/OR9359.png" alt="OR9359.png"></a> <a href="https://imgtu.com/i/OR9GCR"><img src="https://s1.ax1x.com/2022/05/15/OR9GCR.png" alt="OR9GCR.png"></a> <a href="https://imgtu.com/i/OR9J81"><img src="https://s1.ax1x.com/2022/05/15/OR9J81.png" alt="OR9J81.png"></a> <a href="https://imgtu.com/i/OR9Ygx"><img src="https://s1.ax1x.com/2022/05/15/OR9Ygx.png" alt="OR9Ygx.png"></a> <a href="https://imgtu.com/i/OR9UKK"><img src="https://s1.ax1x.com/2022/05/15/OR9UKK.png" alt="OR9UKK.png"></a> <a href="https://imgtu.com/i/OR9tv6"><img src="https://s1.ax1x.com/2022/05/15/OR9tv6.png" alt="OR9tv6.png"></a> ### 主存储器的组成 <a href="https://imgtu.com/i/OR9aDO"><img src="https://s1.ax1x.com/2022/05/15/OR9aDO.png" alt="OR9aDO.png"></a></p>
<table>
<tbody>
<tr class="odd">
<td>- 对于菜鸟驿站来说，我们只能从货架上取走包裹</td>
</tr>
<tr class="even">
<td>- <strong>对于CPU不仅可以从存储体取走数据（读），还可以写入数据</strong></td>
</tr>
<tr class="odd">
<td>- 1个word的大小是不确定的，可能是8bit、16bit、32bit...具体要看计算机硬件是怎么设计的</td>
</tr>
</tbody>
</table>
<p><a href="https://imgtu.com/i/OWVEMd"><img src="https://s1.ax1x.com/2022/05/16/OWVEMd.png" alt="OWVEMd.png"></a> <a href="https://imgtu.com/i/OWVFRe"><img src="https://s1.ax1x.com/2022/05/16/OWVFRe.png" alt="OWVFRe.png"></a> <a href="https://imgtu.com/i/OWVkxH"><img src="https://s1.ax1x.com/2022/05/16/OWVkxH.png" alt="OWVkxH.png"></a> <a href="https://imgtu.com/i/OWVPPO"><img src="https://s1.ax1x.com/2022/05/16/OWVPPO.png" alt="OWVPPO.png"></a> <a href="https://imgtu.com/i/OWViGD"><img src="https://s1.ax1x.com/2022/05/16/OWViGD.png" alt="OWViGD.png"></a> <a href="https://imgtu.com/i/OWVZqI"><img src="https://s1.ax1x.com/2022/05/16/OWVZqI.png" alt="OWVZqI.png"></a> <a href="https://imgtu.com/i/OWVmZt"><img src="https://s1.ax1x.com/2022/05/16/OWVmZt.png" alt="OWVmZt.png"></a> <a href="https://imgtu.com/i/OWVuIf"><img src="https://s1.ax1x.com/2022/05/16/OWVuIf.png" alt="OWVuIf.png"></a></p>
<h3 id="运算器">运算器</h3>
<table style="width:6%;">
<colgroup>
<col style="width: 5%">
</colgroup>
<tbody>
<tr class="odd">
<td>运算器：用于实现算术运算（如：加减乘除）、逻辑运算（如：与或非）</td>
</tr>
<tr class="even">
<td>- ACC（Accumulator）：寄存器、累加器，用于存放操作数，或运算结果。 - MQ（Multiple-Quotient Register）：乘商寄存器，在乘、除运算时，用于存放操作数或运算结果。 - X：通用的操作数寄存器，用于存放操作数 - ALU（）核心单元：算术逻辑单元，通过内部复杂的电路实现算数运算、逻辑运算</td>
</tr>
</tbody>
</table>
<p><a href="https://imgtu.com/i/OWVMi8"><img src="https://s1.ax1x.com/2022/05/16/OWVMi8.png" alt="OWVMi8.png"></a></p>
<h3 id="控制器">控制器</h3>
<p><a href="https://imgtu.com/i/OWVndP"><img src="https://s1.ax1x.com/2022/05/16/OWVndP.png" alt="OWVndP.png"></a> <a href="https://imgtu.com/i/OWVQJS"><img src="https://s1.ax1x.com/2022/05/16/OWVQJS.png" alt="OWVQJS.png"></a> <a href="https://imgtu.com/i/OWVlRg"><img src="https://s1.ax1x.com/2022/05/16/OWVlRg.png" alt="OWVlRg.png"></a> <a href="https://imgtu.com/i/OWV1zQ"><img src="https://s1.ax1x.com/2022/05/16/OWV1zQ.png" alt="OWV1zQ.png"></a></p>
<p><a href="https://imgtu.com/i/OW1Ats"><img src="https://s1.ax1x.com/2022/05/16/OW1Ats.png" alt="OW1Ats.png"></a> <a href="https://imgtu.com/i/OW1mcV"><img src="https://s1.ax1x.com/2022/05/16/OW1mcV.jpg" alt="OW1mcV.jpg"></a> <a href="https://imgtu.com/i/OW1e10"><img src="https://s1.ax1x.com/2022/05/16/OW1e10.png" alt="OW1e10.png"></a> <a href="https://imgtu.com/i/OW1Ehn"><img src="https://s1.ax1x.com/2022/05/16/OW1Ehn.png" alt="OW1Ehn.png"></a> <a href="https://imgtu.com/i/OW1Zpq"><img src="https://s1.ax1x.com/2022/05/16/OW1Zpq.png" alt="OW1Zpq.png"></a> <a href="https://imgtu.com/i/OW1nXT"><img src="https://s1.ax1x.com/2022/05/16/OW1nXT.png" alt="OW1nXT.png"></a> <a href="https://imgtu.com/i/OW1Q74"><img src="https://s1.ax1x.com/2022/05/16/OW1Q74.png" alt="OW1Q74.png"></a> <a href="https://imgtu.com/i/OW1MBF"><img src="https://s1.ax1x.com/2022/05/16/OW1MBF.png" alt="OW1MBF.png"></a> <a href="https://imgtu.com/i/OW11AJ"><img src="https://s1.ax1x.com/2022/05/16/OW11AJ.png" alt="OW11AJ.png"></a> <a href="https://imgtu.com/i/OW1KnU"><img src="https://s1.ax1x.com/2022/05/16/OW1KnU.png" alt="OW1KnU.png"></a> <a href="https://imgtu.com/i/OW1J91"><img src="https://s1.ax1x.com/2022/05/16/OW1J91.png" alt="OW1J91.png"></a> <a href="https://imgtu.com/i/OW18hR"><img src="https://s1.ax1x.com/2022/05/16/OW18hR.png" alt="OW18hR.png"></a> <a href="https://imgtu.com/i/OW1Y1x"><img src="https://s1.ax1x.com/2022/05/16/OW1Y1x.png" alt="OW1Y1x.png"></a></p>
]]></content>
      <categories>
        <category>计算机组成原理</category>
      </categories>
  </entry>
  <entry>
    <title>计算机网络视频</title>
    <url>/2022/05/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0-%E3%80%90%E4%B8%AD%E7%A7%91%E5%A4%A7%E9%83%91%E7%83%87%E3%80%91/</url>
    <content><![CDATA[<p>中科大郑烇、杨坚全套《计算机网络（自顶向下方法 第7版，James F.Kurose，Keith W.Ross）》课程</p>
<p><a href="https://www.bilibili.com/video/BV1JV411t7ow?p=13&amp;spm_id_from=333.880.my_history.page.click">中科大郑烇、杨坚全套《计算机网络（自顶向下方法 第7版，James F.Kurose，Keith W.Ross）》课程_哔哩哔哩_bilibili</a></p>
<p><a href="https://blog.csdn.net/qq_53111905/article/details/119002010?spm=1001.2014.3001.5501">中科大郑烇、杨坚《计算机网络》课程 第一章笔记_爱好学习的青年人的博客-CSDN博客_中科大计算机网络笔记</a></p>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
  </entry>
  <entry>
    <title>ByteCuts</title>
    <url>/2022/11/04/%E8%AE%BA%E6%96%87/2019-ByteCuts/</url>
    <content><![CDATA[<h1 id="启示">1 启示</h1>
<h1 id="摘要">2 摘要</h1>
<h1 id="基础知识">3 基础知识</h1>
<h2 id="预备知识">3.1 预备知识</h2>
<h2 id="文中基础概念">3.2 文中基础概念</h2>
<h1 id="introduction">4 Introduction</h1>
<h1 id="background">5 Background</h1>
<h1 id="方案">6 方案</h1>
<h2 id="b.-树状选择">B. 树状选择</h2>
<p>基于树的方法，包括 ByteCuts，存在着一个叫做规则复制的问题。规则复制是由于通配符造成的规则落入多个分区，迫使它们被多次复制。这可以从图 5 中看出，规则 ra 和 rb 都被复制到了多个分区。现有的方法，如 EffiCuts[3]和 SmartSplit[4]，试图通过对规则进行分区，使同一分区的所有规则具有类似的特征来缓解这一问题。这大大减少了所需的复制量，因为更容易找到不触发任何通配符的好切割。</p>
<p>我们还根据规则的特征将规则列表 <span class="math inline">\(L\)</span> 划分为一个树的列表 <span class="math inline">\(T\)</span>。我们试图将具有相似特征的规则放在同一棵树上，因为这将导致更短的树。我们通过确保同一棵树上的所有规则都使用相同的核心比特集来做到这一点。这确保了至少有一个好的切割会存在。使用一个更大的核心将允许更多的良好切割，减少树的高度，但会排除不符合更严格要求的规则，增加树的数量。我们通过在排除的规则数量和给定切割的预期最大分区大小之间取得平衡来处理这个问题。为了提高效率，我们只使用连续的比特（以小数点为单位）作为核心；对于前缀字段，这相当于测量该特定字段的长度。</p>
<p>我们定义了两个阈值：一个是切割效率，一个是树的大小。我们定义 <span class="math inline">\(c\)</span> 为最大碰撞率，<span class="math inline">\(n_c=c-n_L\)</span>，其中 <span class="math inline">\(n_L\)</span> 是 <span class="math inline">\(L\)</span> 中尚未被放入树中的规则数量。同样地，我们定义<span class="math inline">\(χ\)</span>为最大排除率，<span class="math inline">\(n_χ=χ-n_L\)</span> 。<span class="math inline">\(n_c\)</span> 和 <span class="math inline">\(n_χ\)</span> 在以后的树中都会变小，因为 <span class="math inline">\(n_L\)</span> 会变小；<span class="math inline">\(n_c\)</span> 定义了可接受的碰撞极限，而 <span class="math inline">\(n_χ\)</span> 定义了所需的最大排除规则数。</p>
<p>我们的目标是在满足某些平衡要求的情况下，使规则数量最大化（从而使树的数量最小化）。如果任何 filed 长对 <span class="math inline">\((f, w_f)\)</span> 的碰撞限制低于 <span class="math inline">\(n_c\)</span>，那么我们选择使排除的规则数量最小化的对。否则，从那些最多排除 <span class="math inline">\(n_χ\)</span> 条规则中，我们选择碰撞限制最小的一对。如果这两个目标都无法达到，我们就选择 <em>碰撞大小+排除规则 (collision size + rules excluded)</em> 之和最小的一对。</p>
<p>一旦选择了一个字段长度对（f，wf），我们就从字段 f 的前缀长度至少为 wf 的所有规则中创建一棵树，如下一节所述。然后我们在剩下的规则上重复树的选择过程。</p>
<p>一旦剩余规则的数量低于某个阈值 <span class="math inline">\(τ\)</span>（在我们的实验中为<em>5%</em>），我们就宣布剩余的规则为 "坏"（并推而广之，以前的规则为 "好"）。<strong>坏规则</strong> 通常在两个地址字段中都有相对较少的比特。如果 TCAM 是可用的，我们就把坏规则放到 TCAM 中。对于一个纯粹的 <em>ByteCuts</em> 解决方案，我们试图用所有的坏规则建立一个单一的树，只有当规则在切割阶段需要太多的规则复制时才会被移除（见第三部分-C）。具体来说，如果一条规则在树上的任何单独的切割中具有 <em>5</em> 个或更多的通配符位，我们才会因为规则复制而将其从树上删除。</p>
<p>对于每个字段，我们考虑每个可能的最左边的位，并为每个 <span class="math inline">\(0 &lt; δ ≤ k\)</span> 选择下一个可能的<span class="math inline">\(δ\)</span> 位，这给我们一个 <span class="math inline">\(δ\)</span> 位的选择。从每个规则 <span class="math inline">\(r_i\)</span> 中，我们然后提取这些比特，并将其解释为一个数字。带有通配符的规则计算多个数字（通过用 0 和 1 替换 * ）。我们计算每个数字出现多少次。我们<strong><em>选择具有最小的最大频率</em></strong>的切割。这种切割将<strong>使最大的子树最小化</strong>。在出现平局的情况下，我们倾向于选择δ较小的切割，因为这样可以节省内存。</p>
<p>一旦选择了一个切割，我们就对规则进行分区。我们创建 <span class="math inline">\(2^δ\)</span> 个分区。与上面类似，从每个规则 <span class="math inline">\(r_i\)</span> 中，我们提取选定的 <span class="math inline">\(δ\)</span> 位，将其解释为一个数字，然后将 <span class="math inline">\(r_i\)</span> 放入与该数字对应的分区中。带有通配符的规则将被放置到多个分区中。然后我们对每个分区进行递归，创建一个新的子树。有些列表包含相同的规则集（因为有通配符）。我们检测到这一点，并只创建一个子节点，为这些子列表中的每一个共享。</p>
<p>例如，考虑分类器 I 的规则。在第三部分 B 中，我们选择了规则 r1 到 r7。如果我们选择源字段的前两位，那么一个分区将包含规则 r3、r4 和 r4，但如果我们选择最后两位，那么每个分区至多有 2 条规则，使其成为更好的选择。命运字段上的切割都没有那么好，因为它们需要将 r6 和 r7 复制到所有分区。因此，我们选择（011，000）作为我们切割的掩码。这就产生了四个孩子，其中 00 部分包含 r1 和 r6，01 包含 r2，10 包含 r3 和 r7，11 包含 r4 和 r5。在这种切割之后，每个分区只有 <span class="math inline">\(2≤n_{leaf}\)</span> 规则，所以我们为每个部分创建一个叶子结点。</p>
<p>我们有两个优化，使切割选择更快。首先，如果一个规则在选择的位上有超过 4 个通配符，我们就认为它最终会出现在每个分区中。我们将这种规则的数量作为惩罚，而不是将其计入各个分区。这就避免了为有许多通配符的规则增加成千上万的频率。</p>
<p>第二个优化是，我们把所有的切割都对准了 <em>nybble</em> 边界：我们的最小切割尺寸是 1 <em>nybble</em> ，我们把切割长度增加 1 <em>nybble</em> ，在我们的实验中，我们的最大切割长度是 <span class="math inline">\(k=4\)</span> <em>nybbles</em> （16 位）。这限制了子数组的大小，最多只能有 65536 个节点；增加这个限制会使数组大小增加，从而使潜在的内存使用量呈指数增长。我们只选择 <em>nybbles</em> ，因为在实践中，这些长度明显比其他长度更常见。因此，更精细的切割带来的好处很少，而时间成本却很高。</p>
<h1 id="实验">7 实验</h1>
<h1 id="结论">8 结论</h1>
<h1 id="参考文献">9 参考文献：</h1>
]]></content>
      <categories>
        <category>论文</category>
      </categories>
      <tags>
        <tag>数据包分类</tag>
        <tag>决策树</tag>
      </tags>
  </entry>
  <entry>
    <title>BitCuts</title>
    <url>/2022/11/02/%E8%AE%BA%E6%96%87/2017-BitCuts/</url>
    <content><![CDATA[<h1 id="启示">启示</h1>
<h1 id="摘要">摘要</h1>
<h1 id="基础知识">基础知识</h1>
<h2 id="预备知识">预备知识</h2>
<h2 id="文中基础概念">文中基础概念</h2>
<h1 id="introduction">Introduction</h1>
<h1 id="background">Background</h1>
<h1 id="方案">方案</h1>
<h1 id="实验">实验</h1>
<h1 id="结论">结论</h1>
<h1 id="参考文献">参考文献：</h1>
]]></content>
      <categories>
        <category>论文</category>
      </categories>
      <tags>
        <tag>数据包分类</tag>
        <tag>决策树</tag>
      </tags>
  </entry>
  <entry>
    <title>数据包分类方案整理</title>
    <url>/2022/11/03/%E8%AE%BA%E6%96%87/%E6%95%B0%E6%8D%AE%E5%8C%85%E5%88%86%E7%B1%BB%E6%96%B9%E6%A1%88%E6%95%B4%E7%90%86/</url>
    <content><![CDATA[<p>2022&#x2F;12&#x2F;01</p>
<p><a href="http://www.wenjunli.com/">土鳖云 | Wenjun’s Academic Space (wenjunli.com)</a></p>
<ol>
<li><a href="http://wenjunli.com/CutTSS/">CutTSS (wenjunli.com)</a></li>
<li><a href="http://wenjunli.com/CutTSS/observations/index.html">Observations (wenjunli.com)</a></li>
<li><a href="http://wenjunli.com/CutSplit/">CutSplit (wenjunli.com)</a></li>
<li><a href="http://wenjunli.com/HybridTSS/">HybridTSS (wenjunli.com)</a></li>
<li><a href="http://wenjunli.com/TabTree/">TabTree (wenjunli.com)</a></li>
<li><a href="http://www.wenjunli.com/HybridCuts/">HybridCuts (wenjunli.com)</a></li>
</ol>
<p><strong>2022&#x2F;11&#x2F;16晚思考bit cutting</strong></p>
<p>bit cutting 本质也是 Equi size cutting，但是不是一种“简单的”Equi size cutting，bit cutting 考虑了规则集的分布，Equi size cutting 并没有考虑规则集的分布（我认为 bit cutting 是可以较少 overlapping 的）。</p>
<p>bit cutting 通过不同的算法选择不同的 effective bits，对应着不同的切割方案，而规则的分布决定了如何选择 effective bits。bit cutting既可以减少overlapping，又可以加速索引。<br><img src="https://cdn.staticaly.com/gh/peirsist/blog_img@master/%E4%BD%8D%E5%88%87%E5%89%B2.75nmcu7rtww0.png" alt="位切割"></p>
<p>effective bit 的多少决定了树的高低，effective bit 中 0、1 分布决定了树的平衡性，effective bit 中 * 的多少决定 overlapping 多少。我们期望 overlapping 越少越好，树高度越低越好，树越平衡越好。</p>
<p>由此得到，选择effective bits需要遵循以下原则：</p>
<ol>
<li>尽可能不选择含有通配符 * 的那一列 → 减少 overlapping（2021 MBitTree 启发得来）</li>
<li>选的列 0 1 尽可能分布均匀 → 树会平衡（2021 MBitTree 启发得来）</li>
<li>可以选多个 effective bit → 树的高度会降低</li>
</ol>
<hr>
<h1 id="1-硬件"><a href="#1-硬件" class="headerlink" title="1 硬件"></a>1 硬件</h1><h1 id="2-软件"><a href="#2-软件" class="headerlink" title="2 软件"></a>2 软件</h1><h2 id="2-1-决策树"><a href="#2-1-决策树" class="headerlink" title="2.1 决策树"></a>2.1 决策树</h2><h3 id="2-1-1-规则集分组"><a href="#2-1-1-规则集分组" class="headerlink" title="2.1.1 规则集分组"></a>2.1.1 规则集分组</h3><p>事实上，规则集中部分规则之间存在明显的差异。对访问控制列表 <em>( access control list， ACL)</em> 、防火墙 <em>( firewall，FW)</em> 和 IP 链 <em>( IP chain， IPC)</em> 类型规则集进行统计分析，结果如图 3 所示。从图中可得，IP 地址字段前缀长度为边缘分布，即大部分位于 0 附近或 32 附近。因此不加任何区分直接切割整个搜索空间将导致严重的规则复制，其中一个解决方案便是分治思想，<strong>即将具有相似特征的规则放到一个规则子集中，然后应用节点切割技术为每个子集单独构建决策树</strong>，最后形成多棵决策树。规则集分组方式分为：</p>
<ol>
<li><strong>按字段大小分组</strong>。根据规则在每个字段覆盖的范围来划分规则子集，该类方法应用最广泛。<ul>
<li><del>HiCuts(1999), HyperCuts(2004)</del>, <em>Efficuts(2010)</em>, <del>HyperSplit(2011),</del> <em>SmartSplit(2014), CutSplit(2018)</em></li>
</ul>
</li>
<li><strong>按前缀长度分组</strong>。根据规则在特定字段的前缀长度来划分规则集。<ul>
<li>HashTable</li>
<li><em>ByteCuts(2018)</em></li>
</ul>
</li>
<li><strong>基于聚类算法分组</strong>。使用聚类算法来划分规则子集。<ul>
<li><em>ParaSplit</em></li>
</ul>
</li>
<li><strong>基于深度神经网络模型分组</strong>。将机器学习技术应用到报文分类问题中，如使用深度神经 网络模型来学习优化节点切割和规则集分组，以 获得最大的奖励函数( 分类速度、内存消耗等) ， 从而构建性能优异的决策树。<ul>
<li><em>NeuroCuts(2019)</em></li>
</ul>
</li>
</ol>
<p>按字段大小、前缀长度分组等启发式策略建立在对规则集分布特征观察的基础之上，原理相 对简单、容易实现，但对于不同的规则集，往往需 要手动调整部分参数以获得理想结果; 聚类算法、 神经网络模型则可以使用机器学习来替代人工调 整，实现对规则子集的自适应划分，但需要经过大 量的训练和迭代才能收敛。</p>
<h3 id="2-1-2-节点切割"><a href="#2-1-2-节点切割" class="headerlink" title="2.1.2 节点切割"></a>2.1.2 节点切割</h3><p>节点切割基本思想是将整个多维规则集视为树的根节点，然后沿一个或多个特定的维度迭代地切割节点，直到每个叶节点包含的规则数不大于预定义的阈值时停止切割，从而构建单棵决策树。</p>
<p>各类决策树算法在节点切割方面的主要区别为:</p>
<ol>
<li><p>**<font color="red">切割维度的选择</font>**。选择哪个维度切割最优; 一次选择单个维度还是多个维度进行切割。</p>
</li>
<li><p><strong><font color="red">切割端点的选择</font></strong></p>
<ol>
<li><strong>Equi - size</strong><ul>
<li>快速将节点等分为 $2^n$ 个子节点，但会带来严重的规则复制问题,即同一条规则分布在多个子节点中</li>
<li><em>HiCuts(1999), HyperCuts(2004), Efficuts(2010)</em></li>
</ul>
</li>
<li><strong>Equi-dense</strong><ul>
<li>而等密切割能够缓解规则复制问题，但也存在树深度增加、节点索引复杂等问题。</li>
<li><em>HyperSplit(2011), SmartSplit(2014)</em></li>
</ul>
</li>
<li><strong>Bit cutting</strong><ul>
<li>利用规则每一位都可表示为 0、1 或者 * ( 通配符) 的特点，选择其中有效比特将规则映射到各个子节点中，从而避免了盲目地切割整个搜索空间。</li>
<li><em>BitCuts(2017), ByteCuts(2018), MBitTree(2021)</em></li>
</ul>
</li>
</ol>
</li>
</ol>
<blockquote>
<p>另一个角度看，等分切割也是一种特殊的比特切割，但只允许使用连续的最高有效位。</p>
</blockquote>
<h3 id="2-1-3-HiCuts"><a href="#2-1-3-HiCuts" class="headerlink" title="2.1.3 HiCuts"></a>2.1.3 HiCuts</h3><ol>
<li><strong>思路</strong>： 一次选择单个维度，将搜索 空间划分为等大小的子空间</li>
<li><strong>规则集分组方式</strong>：无</li>
<li><strong>节点切割方式</strong>：<em><strong>equi-size</strong></em></li>
<li><strong>优点</strong>：首个决策树分类算法，快速 切割规则空间</li>
<li><strong>缺点</strong>：树深度较大，规则复制问 题严重，内存消耗大</li>
</ol>
<h3 id="2-1-4-HyperCuts"><a href="#2-1-4-HyperCuts" class="headerlink" title="2.1.4 HyperCuts"></a>2.1.4 HyperCuts</h3><ol>
<li><strong>思路</strong>： 一次选择多个维度，将搜索 空间划分为等大小的子空间</li>
<li><strong>规则集分组方式</strong>：无</li>
<li><strong>节点切割方式</strong>：<em><strong>equi-size</strong></em></li>
<li><strong>优点</strong>：HiCuts 的改进，树深度较小， 分类速度较快，规则复制相 比 HiCuts 有所优化</li>
<li><strong>缺点</strong>：内存消耗仍然较大，可扩展性较差</li>
</ol>
<h3 id="2-1-5-EffiCuts"><a href="#2-1-5-EffiCuts" class="headerlink" title="2.1.5 EffiCuts"></a>2.1.5 EffiCuts</h3><ol>
<li><strong>思路</strong>： </li>
<li><strong>规则集分组方式</strong>：</li>
<li><strong>节点切割方式</strong>：<em><strong>equi-size</strong></em></li>
<li><strong>优点</strong>：大大减少了规则复制</li>
<li><strong>缺点</strong>：划分树的数目太多，查找速度慢</li>
</ol>
<h3 id="2-1-6-HyperSplit"><a href="#2-1-6-HyperSplit" class="headerlink" title="2.1.6 HyperSplit"></a>2.1.6 HyperSplit</h3><p>HyperSplit 算法提出了等密切割的思路，进一 步缓解了规则复制问题，但由于算法构建的决策树 为二叉树，且每次只能判断一次维度，因此随着规 则集规模的扩大和维度的增加，树的深度也会增 加，相应的遍历决策树所需的访存次数也将增加。</p>
<ol>
<li><strong>思路</strong>： 一次选择单个维度和特定的 端点，将搜索空间划分为两 个规则数几乎相等的子空间</li>
<li><strong>规则集分组方式</strong>：无</li>
<li><strong>节点切割方式</strong>：<em><strong>equi-dense</strong></em></li>
<li><strong>优点</strong>：进一步优化规则复制问题， 内存消耗小</li>
<li><strong>缺点</strong>：树深度较大，遍历树所需 的访存次数较多</li>
</ol>
<h3 id="2-1-7-BitCuts"><a href="#2-1-7-BitCuts" class="headerlink" title="2.1.7 BitCuts"></a>2.1.7 BitCuts</h3><ol>
<li><strong>思路</strong>： 选择规则中的有效比特来划分搜索空间</li>
<li><strong>规则集分组方式</strong>：无</li>
<li><strong>节点切割方式</strong>：<em><strong>bit-cutting</strong></em></li>
<li><strong>优点</strong>：分类速度在 4 种算法中最快，吞吐量高</li>
<li><strong>缺点</strong>：树深度较大，规则复制问题严重，内存消耗大</li>
</ol>
<h2 id="2-2-哈希表"><a href="#2-2-哈希表" class="headerlink" title="2.2 哈希表"></a>2.2 哈希表</h2><h2 id="2-3-决策树结合哈希表"><a href="#2-3-决策树结合哈希表" class="headerlink" title="2.3 决策树结合哈希表"></a>2.3 决策树结合哈希表</h2><h2 id="2-4-机器学习"><a href="#2-4-机器学习" class="headerlink" title="2.4 机器学习"></a>2.4 机器学习</h2><h2 id="2-5-其他"><a href="#2-5-其他" class="headerlink" title="2.5 其他"></a>2.5 其他</h2>]]></content>
      <categories>
        <category>论文</category>
      </categories>
      <tags>
        <tag>数据包分类</tag>
      </tags>
  </entry>
  <entry>
    <title>MBitTree</title>
    <url>/2022/10/31/%E8%AE%BA%E6%96%87/2021-MBitTree/</url>
    <content><![CDATA[<h1 id="启示">启示</h1>
<ol type="1">
<li>位切割</li>
<li>为每一颗树设立优先级</li>
<li>划分方法，不采用规则范围，采用前缀长度，来聚类，似乎更合理。</li>
</ol>
<p><a href="https://blog.csdn.net/wolfzone025/article/details/6577668">IP数据包分类经典算法总结</a></p>
<h1 id="摘要">摘要</h1>
<p>摘要--数据包分类是许多网络服务的关键组成部分，如服务质量和网络安全。这些网络服务要求数据包分类尽可能快，同时使用较少的内存并支持可扩展性。此外，软件定义的网络交换机在规则集的高维度和大尺度方面对数据包分类提出了新的挑战。在本文中，我们提出了一个名为MBitTree的新解决方案，它包括对现有决策树算法的两个主要改进。首先，我们引入了一种新的规则集划分技术，以实现自适应和快速的规则集划分。第二，采用新的多比特切割方案来构建短树，同时很少造成规则复制。</p>
<p>MBitTree可以提供较高的分类速度，并具有良好的可扩展性。实验结果表明，与CutSplit相比，MBitTree实现了高达6.8倍的内存消耗，以及高达1.7倍的内存访问次数的减少。此外，我们在FPGA上实现了MBitTree的原型，实施结果表明，我们的方法对于10K的规则集可以实现超过100Gbps的吞吐量，在NetFPGA上可以处理超过100K的规则集。</p>
<p>Index Terms-packet classification, decision tree, bit cutting, FPGA</p>
<h1 id="基础知识">基础知识</h1>
<h2 id="预备知识">预备知识</h2>
<ol type="1">
<li>K-means聚类分析
<ol type="1">
<li>与分类、序列标注等任务不同，聚类是在事先并不知道任何样本标签的情况下，通过数据之间的内在关系把样本划分为若干类别，使得同类别样本之间的相似度高，不同类别之间的样本相似度低（即增大类内聚，减少类间距）。</li>
<li><a href="https://blog.csdn.net/qq_43741312/article/details/97128745">K-means聚类算法原理及python实现</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/184686598">KMeans聚类算法详解</a></li>
</ol></li>
<li>距离的度量
<ol type="1">
<li><a href="https://img-blog.csdn.net/20161218152146962?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdGFveWFucWk4OTMy/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast">距离的度量</a></li>
</ol></li>
</ol>
<h2 id="文中基础概念">文中基础概念</h2>
<ol type="1">
<li>IP地址的前缀长度倾向于分布在边缘，即很大一部分前缀长度位于0或32附近，如图3所示。因此，我们使用IP地址作为聚类的基础。</li>
<li>FW规则集中有更复杂的几何结构</li>
</ol>
<h1 id="introduction">Introduction</h1>
<p>数据包分类是许多网络服务的关键组成部分，例如服务质量(QoS)、网络安全和策略路由。数据包分类的速度对这些网络服务的性能有着重要的影响。因此，包分类是网络研究中一个非常活跃的课题。</p>
<p>当前的数据包分类解决方案可以大致分为两类:基于硬件的解决方案和基于软件的解决方案[1]。使用三态内容可寻址存储器(TCAM) [2]、[3]、[4]的基于硬件的解决方案已成为行业中数据包分类的主要实施方式。它们利用TCAM将所有规则存储在关联存储器中，然后并行地将数据包与所有这些规则进行匹配。TCAM提供了恒定的分类时间并保证了高性能，但它有一些明显的限制，如高成本和高能耗[5]，使其无法实现大型分类器。相比之下，基于软件的解决方案，也称为算法解决方案，因其低成本和灵活性而受到广泛关注。随着软件定义网络(SDN)的出现，对高性能分组分类算法有着强烈的需求。</p>
<p>有两种类型的包分类软件算法:基于散列和基于决策树的解决方案。其中，基于哈希的解决方案[6]、[7]、[8]支持快速更新，并使用线性内存，但由于大型规则集中的哈希冲突和元组扩展，它们存在性能问题。另一方面，决策树算法正被积极地研究，因为它们适合于处理具有许多领域的分类器，并且有助于在硬件上实现。在过去的二十年里，人们提出了大量的决策树算法，如基于等长切割的决策树[9]、[10]和基于等密切割的决策树[11]。这些算法的总体目标是在降低内存消耗的同时提供高吞吐量。</p>
<p>然而，由于这些算法没有充分利用规则集的分布特征，随着字段数量和规则集大小的增长，设计高效的决策树算法非常具有挑战性。例如，OpenFlow交换机需要检查超过15个字段来对传入的数据包进行分类[12]，并且字段的数量预计在未来会增加。现代数据中心中大型规则集的规模可能达到数十万条规则[13]。</p>
<p>此外，随着软件交换机的部署，在吞吐量、内存占用、可扩展性和更新性能方面对分组分类算法提出了更严格的要求。</p>
<p>为了更好地利用规则集的分布特性，本文提出了一种新的决策树算法MBitTree，该算法能够以适中的内存占用提供较高的分类速度，并具有良好的可扩展性。</p>
<p>MBitTree分两个阶段构建决策树。首先，我们提出了一种基于聚类算法的高效规则集划分技术，以实现自适应的快速规则集划分。这样就得到几个子集，其中特定领域前缀长度比较接近的规则属于同一个子集。第二，由于大多数规则属于前缀长度较长的子集，并且有更多的可选位来分隔规则，同时很少在这些子集中引起规则复制，因此使用新的多位切割方案来为这些子集构建短树。还有少数规则前缀长度短，可选位数少，所以使用优先级排序元组搜索空间[7]等其他算法辅助。</p>
<p>本文的主要贡献如下: 1. 提出了一种新的<strong>规则集划分技术</strong>，能够实现快速、自适应的规则集划分，适用于各种类型的规则集。 2. 提出了一种新的<strong>位切割方案</strong>，它可以构建一个短树，同时很少引起规则复制。 3. 我们揭示了为什么我们提出的多位切削是可行和有效的原因。 4. 我们在FPGA上实现了MBitTree的原型，我们的方法可以为10K规则集实现超过100 Gbps的吞吐量，并且可以处理超过100K个规则集</p>
<p>我们使用ClassBench [14]来评估我们的方法。实验结果表明，MBitTree可以生成有限数量的短决策树，并且具有适中的内存占用。与CutSplit [15]相比，MBitTree的内存消耗减少了6.8倍，平均内存访问次数减少了1.7倍。MBitTree可以在100k规则集上以毫秒而不是秒的速度构建决策树。此外，我们在FPGA上实现了MBitTree的原型。</p>
<p>本文的其余部分组织如下。第二节介绍了研究背景，并对相关工作进行了总结。第三节介绍了MBitTree的技术细节。</p>
<p>第四节提供了实验结果。最后，第五部分得出结论和我们未来的工作</p>
<h1 id="background">Background</h1>
<p>在本节中，我们首先回顾了数据包分类的背景。之后，我们简要介绍两种相关的算法方法：决策树和基于哈希的解决方案。</p>
<h2 id="a.-数据包分类问题">A. 数据包分类问题</h2>
<p>一个数据包分类器包含一个规则列表，每个规则由多个匹配字段和数据包匹配时要采取的行动组成。例如，在标准的5元分类器中，有IP地址、端口号和协议类型。</p>
<p>OpenFlow 1.0扩展了标准5元组，增加了7个头字段[12]。数据包分类的目的是从规则列表中找到一个传入的数据包所匹配的具有最高优先级的规则。表一显示了一个2元组分类器的例子。</p>
<h2 id="b.-基于决策树的解决方案">B. 基于决策树的解决方案</h2>
<p>数据包分类可以被看作是计算几何学中的点定位问题[16]。数据包头中的字段对应于几何空间的尺寸。而一个数据包表示一个点，而一条规则表示空间中的一个超矩形。那么，对一个数据包进行分类就相当于找到包含代表数据包的点的最高优先级的超矩形。表一中的规则集的几何视图如图1所示。 <img src="https://cdn.staticaly.com/gh/peirsist/blog_img@master/1.3x6q7w68qew0.png" alt="规则集"></p>
<p>在基于决策树的解决方案中，数据包分类问题的几何视图被采纳，并建立了一棵决策树。树的根节点覆盖了包含所有规则的整个搜索空间。然后迭代地将搜索空间划分为更小的子空间，直到每个子空间所覆盖的规则不超过一个称为binth的桶大小。接下来，我们将讨论建立决策树进行数据包分类的两种常见技术：节点切割和规则集分区。</p>
<h3 id="节点切割">1）节点切割。</h3>
<p>根据搜索空间的划分方法，节点切割技术可分为三种主要方法：等尺寸切割、等密度切割和比特切割。</p>
<ol type="1">
<li><strong>等大小切割。</strong></li>
</ol>
<p>HiCuts[9]对搜索空间进行切割，以创建一组等大小的子空间，这些子空间将规则尽可能均匀地分开。然而，HiCuts只考虑在一个节点上切割一个维度，所以HiCuts构建的树的深度会很高。HyperCuts[17]是HiCuts的一个改进。首先，HyperCuts提出在一个节点上同时切割多个维度。其次，HyperCuts提出了一个优化方案，将所有兄弟姐妹共有的规则移到父节点。然而，在HyperCuts中仍然存在相当多的规则冗余。原因是，等密切割适合于规则集分布均匀的情况，但在现实中并不均匀。</p>
<ol start="2" type="1">
<li><strong>等密切割。</strong></li>
</ol>
<p>HyperSplit[11]提出沿规则边界切割搜索空间，构建一个平衡的二叉树，使规则均匀地分布在子节点。HyperSplit在一定程度上减少了内存消耗，但它只考虑一个节点的一个维度。随着规则集规模的扩大，HyperSplit构建的树的深度将迅速增加。等密切割基本上是牺牲了分类速度来换取较低的内存使用量。</p>
<ol start="3" type="1">
<li><strong>比特切割。</strong></li>
</ol>
<p><strong>位切割的想法是从规则中提取一些离散的位，将这些位解释为一个数字，并将这个数字作为索引放入子节点的阵列中。</strong></p>
<p>与等尺寸切割和等密度切割相比，位切割更加灵活，但其性能取决于位选择方案。研究人员提出了许多位选择方案，如D2BS中的最大子节点最小化[18]，BitCuts中的规则分离性[19]，MC-SBC中的信息熵[20]，以及ByteCuts中的子节点规则数最小化[21]。这些方案从不同角度对位选择提出了独特的见解。然而，它们也有一些不足之处。例如，它们中的大多数没有考虑到位之间的相关性，很容易陷入局部最优方案中。</p>
<h3 id="规则集的划分">2）规则集的划分。</h3>
<p>通过节点切割建立单一的决策树存在固有的缺陷。它没有考虑规则之间的差异，如表I中的R1和R11，导致了大量的规则复制。解决这个问题的方法之一是规则集分区技术。它根据规则的特点将一个规则集划分为若干个子集，这样可以大大减少内存的消耗，同时对算法的吞吐量造成很小的影响。</p>
<p>EffiCuts[10]是一个著名的算法，它根据字段大小对规则集进行分区。EffiCuts提出了可分离树的思想，将小规则和大规则放在不同的子集中，然后用等大小的切割来为每个子集建立一棵独立的树。EffiCuts的问题是，它使用所有字段来划分规则集，并产生了太多的子集。例如，对于F元组的规则集，最多可以生成2F的子集。HybridCuts[22]和SmartSplit[23]只使用IP地址字段来划分规则集，以避免产生过多的子集。CutSplit[15]和CutTSS[24]通过选择极少数小字段作为规则集划分的基础，进一步将其扩展到多字段规则集。基于字段大小的规则集划分可以有效地分离规则集，它需要定义一个关键阈值来区分大字段和小字段。然而，对于各种类型的规则集来说，很难找到一个最佳阈值。</p>
<p>ParaSplit[25]使用聚类和模拟退火算法来寻找最佳分区，但它需要数万次的迭代才能收敛。最近的工作NeuroCuts[26]使用深度神经网络对规则集进行自适应的分割。在面对各种规则集时，它的通用性更强，但它也需要大量的训练，并且需要很长的时间来收敛到其最佳解决方案。PartitionSort[27]通过将规则集划分为几个可排序的子集并为每个子集构建一个MITree，实现了对数的分类和更新时间。然而，由于对分区的严格限制，PartitionSort比SmartSplit和CutSplit产生更多的树，导致更多的内存访问和更慢的分类速度。</p>
<h2 id="c.-基于哈希的解决方案">C. 基于哈希的解决方案</h2>
<p>元组空间搜索（TSS）[6]将规则划分为不同的元组，每个元组对应一个哈希表，所以它只需要一次内存访问就可以向哈希表插入和删除规则。TSS具有使用线性内存和支持快速更新的优点，但由于哈希碰撞和元组扩展，有一个性能问题。PSTSS [7] 和 TupleMerge [8] 是 TSS 的改进。PSTSS通过对图元按优先级降序排序来减少平均查表次数，但其最差的搜索性能与TSS相同。TupleMerge通过放宽规则可以放在同一个元组中的限制来减少元组的数量，但是合并元组可能导致哈希冲突的增加。</p>
<h1 id="方案">方案</h1>
<p>在本节中，我们首先介绍了MBitTree的框架。然后，我们对规则集的分布做了几个关键的观察，并根据我们的观察结果提出了一个自适应的规则集划分技术。之后，使用多比特切割方案来构建子集的树，以利用规则集的分布特征。最后，我们描述了如何对一个数据包进行分类。</p>
<h2 id="a.-思路与框架">A. 思路与框架</h2>
<p>根据以上回顾，规则集分区可以大大减少规则的复制，同时对吞吐量造成的影响很小。与等尺寸切割和等密度切割相比，位切割是一种更灵活的节点切割方法，其性能取决于位选择方案。因此，我们的想法是将规则集分区和位切割结合起来，建立一个高效的决策树。我们提出了一个自适应的规则集分区技术和一个多比特切割方案来建立一个高效的决策树。</p>
<p>MBitTree的框架包括构建决策树和数据包分类，如图2所示。MBitTree通过两个步骤建立决策树：规则集分区和多比特切割。</p>
<figure>
<img src="https://cdn.staticaly.com/gh/peirsist/blog_img@master/Snipaste_2022-10-31_23-25-10.1p3lqj6awa80.png" alt="MBitTree的框架"><figcaption aria-hidden="true">MBitTree的框架</figcaption>
</figure>
<h3 id="a-自适应规则集分区">a) <strong>自适应规则集分区</strong>。</h3>
<p>我们根据对规则集的观察结果，选择一些适当的字段作为规则集分区的基础。然后使用聚类算法来实现快速和自适应的规则集划分，因此得到了几个子集。</p>
<h3 id="b-多位切割">b) <strong>多位切割</strong>。</h3>
<p>采用多比特切割方案来建立子集的树，它使用比特分离能力和通配符比率作为选择切割比特的标准，称为有效比特。</p>
<h3 id="c-数据包分类">c) <strong>数据包分类</strong>。</h3>
<p>MBitTree搜索每一棵树以找到匹配规则。为了搜索一棵树，我们首先看它的根节点并检查节点的类型。如果它是一个叶子节点。</p>
<p>我们使用线性搜索来获得匹配规则。否则，我们使用存储在内部节点的有效位来遍历树，直到到达一个叶子节点为止。</p>
<h2 id="b.-自适应规则集分区">B. 自适应规则集分区</h2>
<p>规则集的分布有特定的特点，利用这些特点有助于建立一个更好的树。我们对访问控制列表（ACL）、防火墙（FW）和IP链（IPC）规则集做了一些观察。可以发现，IP地址的前缀长度倾向于分布在边缘，即很大一部分前缀长度位于0或32附近，如图3所示。因此，我们使用IP地址作为聚类的基础。具体来说，首先得到每个规则的SrcIP和DstIP前缀长度，并用二维坐标系中的一个点表示，其中X轴代表SrcIP的前缀长度，Y轴代表DstIP的前缀长度。例如，一个SrcIP为8.76.223.16/31，DstIP为184.144.168.0/24的规则被映射到坐标系中的点（31，24）。此外，我们还分析了OpenFlow分类器中IP前缀长度的分布。我们使用ClassBench-ng[28]，一个新的开源工具，来生成OpenFlow 1.0流量规则。类似的趋势也可以在OpenFlow规则集中找到。 <img src="https://cdn.staticaly.com/gh/peirsist/blog_img@master/Snipaste_2022-10-31_23-25-24.4s1lkko2nle0.png" alt="SIP前缀长度分布"></p>
<p>在将规则集中的所有规则映射到二维坐标系后，我们使用基于分区的聚类算法K-means对规则集进行分区，因为其聚类速度快，时间复杂度低。K-means的关键是选择聚类的数量和每个聚类的初始中心点。我们根据规则集的分布特征，设定聚类数k=4，每个聚类的初始中心点为C0（24，24）、C1（24，0）、C2（0，24）、C3（0，0）。需要注意的是，聚类数量和初始聚类中心的选择对聚类结果有很大影响。通过实验证明，我们的选择是合理的。一般来说，完成聚类过程只需要2-4次迭代，所以聚类的时间开销很低。</p>
<p>在选择了k个初始聚类中心后，计算每个规则的点到k个中心的距离，并将该规则归入最近的聚类，然后重新计算新的聚类中心。我们在聚类过程中<strong>使用平方的欧几里得距离</strong>。重复上述过程，直到满足收敛条件，即每个聚类中心的位置没有变化。聚类的目的是把SrcIP和DstIP前缀长度比较接近的规则放到同一个聚类中，每个聚类对应一个子集，这样可以为以后的多比特切割提供更多的可选位。</p>
<p>以表I中的规则为例，由于每个字段的位宽为3，所以每个簇的初始中心分别为C0（3，3）、C1（3，0）、C2（0，3）和C3（0，0）。</p>
<p>规则R1-R11的聚类结果如表二所示。</p>
<p>从这个例子中可以看出，大部分规则被归入前缀较长的集群，包括C0、C1和C2，而C3集群中的规则数量非常少。 <img src="https://cdn.staticaly.com/gh/peirsist/blog_img@master/Snipaste_2022-10-31_23-26-13.6xrnfggmojc0.png" alt="规则R1-R11的聚类结果"></p>
<h2 id="c.-有效位的选择">C. 有效位的选择</h2>
<p>在规则集分割后得到几个子集，然后用多位切割来建立子集的决策树。</p>
<p>关键问题是如何选择最佳的切割位，称为有效位，以均匀地分离规则。对于一个有d个字段和l个长度的规则集（例如，在传统的五元组规则集中，d等于5，l等于104），我们为每条规则创建一个比特串。位串中每个比特的值是0、1和通配符（*）中的一个。</p>
<p>有两个指标被用来选择有效的位：位分离能力和通配符比率。位分离能力决定了规则分布在这个位位置上是否均匀，通配符比率估计了规则复制的程度。 <img src="https://cdn.staticaly.com/gh/peirsist/blog_img@master/Snipaste_2022-10-31_23-25-41.10u4nzrv8068.png" alt="ACL规则集位分布"></p>
<p>Effective Bit选择算法如图所示： <img src="https://cdn.staticaly.com/gh/peirsist/blog_img@master/Snipaste_2022-10-31_23-25-52.4yvd5idejwo0.png" alt="Effective Bit选择算法"></p>
<h2 id="d.-位的相关性">D. 位的相关性</h2>
<p>当面对大规模的规则集时，需要在一个节点上选择多个位来降低树的高度。在随后的位选择中，如果我们只用S（i）和P（i）作为选择标准，就会产生位之间的相关性问题，即这些位上的值大致相同。</p>
<p>例如，对于表二中的规则R1-R7，第3位和第5位上的数值几乎相同，所以选择这两个位作为有效位的结果与选择其中一个位相同。</p>
<p>有两种方法可以解决比特之间的相关性问题：计算比特之间的相关性和从最大的子节点中选择有效比特。然而，计算比特的相关性会带来很多额外的计算。此外，计算两个比特之间的相关性很容易，但要计算三个或更多比特之间的相关性就很难。在实践中，我们经常需要在一个节点上选择三个以上的有效比特。</p>
<p>因此，我们采用第二种方法：从最后一个比特选择过程中形成的规则数量最多的子节点中选择有效比特，这样所选择的有效比特可以进一步分离非叶子节点[29]。这种方法可以保证这次选择的有效位不会与之前的有效位产生关联问题。例如，图4中第一次选位后形成了两个子节点，在接下来的选位过程中，我们将左边的子节点作为计算对象，所以选择了第3位作为有效位。MBitTree对规则R1-R7产生的树如图6所示。 <img src="https://cdn.staticaly.com/gh/peirsist/blog_img@master/Snipaste_2022-10-31_23-26-04.kt4p7eydw5c.png" alt="切割后结果"></p>
<figure>
<img src="https://cdn.staticaly.com/gh/peirsist/blog_img@master/Snipaste_2022-10-31_23-26-26.42pmis2c6te0.png" alt="多位切割"><figcaption aria-hidden="true">多位切割</figcaption>
</figure>
<p>通过多位切割建立的决策树是一个迭代过程，所以我们需要决定何时停止多位切割过程。在节点中的规则数量不超过一个叫做binth的阈值的情况下，多比特切割就会停止。</p>
<h2 id="e.-数据包分类">E. 数据包分类</h2>
<p>通过多位切割建立的树数量有限。为了对一个数据包进行分类，MBitTree搜索每一棵树，以找到匹配的规则。<strong>为了避免不必要的查找，每棵树都引入了一个树的优先级，它被设置为树中最高的规则优先级</strong>。在查找时，如果匹配规则的优先级大于树的优先级，那么就跳过这棵树。为了搜索一棵树，我们首先看它的根节点，并检查节点类型。如果它是一个叶子节点，我们使用线性搜索来获得匹配规则。否则，我们使用存储在内部节点的有效位来遍历树，直到到达一个叶子节点。</p>
<p><strong>MBitTree的节点数据结构</strong>如图7所示。我们用1个字节来表示节点的类型：内部节点或叶子节点。对于每个内部节点，我们用1个字节表示有效位的数量，8个字节用于有效位信息，包括维度和位置。叶子节点用1个字节表示叶子节点所覆盖的规则数。内部节点和叶子节点都使用4个字节来存储阵列指针。 <img src="https://cdn.staticaly.com/gh/peirsist/blog_img@master/Snipaste_2022-10-31_23-26-37.2swxztywvju0.png" alt="MBitTree的节点数据结构"></p>
<h2 id="f-.-基于fpga的实现">F . 基于FPGA的实现</h2>
<p>为了实现高吞吐量，我们将MBitTree构建的决策森林（包括n个子树）映射到具有n个线性管道的并行多管道架构中，如图8所示，其中黄色块表示内部节点的遍历，蓝色块表示叶节点的规则匹配。每条管道都用来遍历决策树，并与树的叶子节点上的规则列表相匹配。树的遍历阶段由一个存储树节点的内存块和一个基于有效位生成内存访问地址的逻辑组成，如图9所示。叶子节点中的规则是并行匹配的，以充分利用FPGA上可用的并行性，包括规则之间和规则内字段之间的并行搜索。优先级解析器从n条流水线的输出中选择具有最高优先级的规则。</p>
<p>此外，由于FPGA上的块RAM支持双端口读取，流水线可以利用这一功能在每个时钟周期内处理两个数据包。因此，一个双包搜索流水线可以实现2倍的速度提升。由于篇幅有限，我们简要介绍一下初步结果。</p>
<p>最大的时钟速率是从后置和路由报告中得到的。使用10K规则集，在NetFPGA上实现的时钟超过150MHz。这相当于64字节最小尺寸数据包的吞吐量超过100Gbps。</p>
<p>我们的架构也可以处理超过100K的规则集。 <img src="https://cdn.staticaly.com/gh/peirsist/blog_img@master/Snipaste_2022-10-31_23-26-53.6mtp2g7e9ok0.png" alt="MBiTree多流水线架构"></p>
<figure>
<img src="https://cdn.staticaly.com/gh/peirsist/blog_img@master/Snipaste_2022-10-31_23-27-13.1mzhoi75kyv4.png" alt="硬件中树遍历过程"><figcaption aria-hidden="true">硬件中树遍历过程</figcaption>
</figure>
<h1 id="实验">实验</h1>
<p>在本节中，我们将MBitTree与HybridCuts[22]、PartitionSort[26]和CutSplit[15]进行比较。我们使用ClassBench[14]来生成实验的规则集。ClassBench包括3个不同类别的12个不同的种子文件。5个访问控制列表（ACL），5个防火墙（FW），和2个IP链（IPC）。我们为每个种子生成3种不同大小的规则集，分别为1k、10k和100k。规则集是用种子类型和大小来命名的，例如，ACL1 1k意味着ACL1类型的规则集有大约1000条规则。此外，我们还为ACL1、FW1和IPC1种子类型生成了500k和1M的规则集，以验证MBitTree的可扩展性。</p>
<p>我们测量了四个指标：内存访问、内存足迹、构建时间和可扩展性。所有的实验都是在一台装有Intel Core i7 CPU @ 1.80GHz和8GB内存的机器上进行的，运行Ubuntu 18.04并使用GCC 7.5.0编译。</p>
<h2 id="a.-内存访问">A. 内存访问</h2>
<p>图10显示了MBitTree以及HybridCuts、PartitionSort和CutSplit的平均内存访问次数。</p>
<p>很明显，MBitTree的表现优于其他算法，而且随着规则集的增大，其改善程度也在增加。例如，对于FW 1k规则集和FW 10k规则集，MBitTree需要20和23次内存访问来分类一个数据包，而CutSplit分别需要31和38次内存访问。MBitTree平均需要16次内存访问来对数据包进行分类，而在HybridCuts、PartitionSort和CutSplit中，它分别需要30、28和38次内存访问。与HybridCuts、PartitionSort和CutSplit相比，MBitTree平均实现了1.9倍、2.4倍和1.7倍的改进。</p>
<p>优先排序树的优化方法可以大大降低平均内存访问量。如果找到一个高优先级的规则，就不需要搜索后面的树，因为这些树中没有更高优先级的规则。因此，MBitTree可能只需要查看一棵大树。此外，MBitTree使用多个比特来分隔规则，所以可以建立更短的决策树。例如，在一个节点上选择i个有效位可以创建2i个子节点。</p>
<p>这些解释了为什么MBitTree在内存访问数量上比HybridCuts和CutSplit表现得好得多。</p>
<p>PartitionSort需要更多的内存访问来对一个数据包进行分类，因为它比其他三种算法产生更多的分区子集。PartitionSort中分区子集的数量从2到49不等，平均为21.8个子集。相比之下，无论规则集的类型和大小如何，MBitTree产生的子集数量相对稳定，平均为3.8个子集。 <img src="https://cdn.staticaly.com/gh/peirsist/blog_img@master/Snipaste_2022-10-31_23-27-29.4qj5clqn0vi0.png" alt="平均内存访问次数"></p>
<h2 id="b.-内存占用">B. 内存占用</h2>
<p>图11显示了MBitTree以及HybridCuts、PartitionSort和CutSplit的内存足迹。对于大多数规则集，MBitTree比HybridCuts、PartitionSort和CutSplit消耗的空间更少。在所有的规则集中，MBitTree平均消耗13.2字节/规则，而在HybridCuts、PartitionSort和CutSplit中，它平均需要35.4字节/规则、55.4字节/规则和90.3字节/规则。MBitTree的低内存占用率意味着在MBitTree构建的树中很少有规则重复。应该注意的是，CutSplit在一些FW规则集上消耗的空间更大。原因是在这些FW规则集中有更复杂的几何结构。而且CutSplit在预切割阶段后使用HyperSplit来构建树，而HyperSplit对这些规则集有某些不兼容的问题，产生了突然的内存爆炸。 <img src="https://cdn.staticaly.com/gh/peirsist/blog_img@master/Snipaste_2022-10-31_23-27-51.ni7s0vsqab4.png" alt="平均内存占用"></p>
<h2 id="c.-构建时间">C. 构建时间</h2>
<p>图12显示了MBitTree以及HybridCuts、PartitionSort和CutSplit在100k规则集上的构建时间。很明显，PartitionSort是其中最快的一个。相比之下，MBitTree比PartitionSort多花了一点时间，因为它在位选择过程中进行了几次迭代。然而，MBitTree仍然可以在一秒钟内为所有100k规则集建立决策树，比HybridCuts和CutSplit快得多。与CutSplit相比，MBitTree对100k规则集的平均构建时间减少了一个数量级。 <img src="https://cdn.staticaly.com/gh/peirsist/blog_img@master/Snipaste_2022-10-31_23-28-00.rba08lozb2o.png" alt="100K规则集构建时间"></p>
<h2 id="d.-可扩展性">D. 可扩展性</h2>
<p>图13显示了MBitTree从1k规则集到1M规则集的内存占用情况。可以发现，内存占用与规则集的规模之间几乎呈线性关系。MBitTree为50万条规则集构建决策树只消耗了几个MBytes，为100万条规则集构建决策树则消耗了大约10Mbytes。内存占用的良好可扩展性使得MBitTree适用于大型分类器。 <img src="https://cdn.staticaly.com/gh/peirsist/blog_img@master/Snipaste_2022-10-31_23-28-13.20ozqkc5j3s0.png" alt="不同大小规则集内存占用"></p>
<h1 id="结论">结论</h1>
<p>我们提供了两个关键的贡献。首先，我们提出了<strong>一种基于聚类的新的规则集划分技术</strong>，以实现自适应和快速的规则集划分。其次，我们提出了<strong>一种新的多比特切割方案</strong>，以建立一个短的树，同时很少引起规则复制，它使用比特分离能力和通配符比例来选择有效的比特。我们一起提出了MBitTree，一个新的基于树的数据包分类解决方案，在内存访问和内存占用方面改进了现有的决策树算法，包括CutSplit。我们还在FPGA上实现了MBitTree的原型，我们的方法可以在NetFPGA上处理超过100K的规则集。</p>
<h1 id="参考文献">参考文献：</h1>
]]></content>
      <categories>
        <category>论文</category>
      </categories>
      <tags>
        <tag>数据包分类</tag>
        <tag>决策树</tag>
      </tags>
  </entry>
  <entry>
    <title>数据包现状</title>
    <url>/2022/11/06/%E8%AE%BA%E6%96%87/%E7%8E%B0%E7%8A%B6/</url>
    <content><![CDATA[<h1 id="数据包过滤规则匹配与并行化技术研究">1 数据包过滤规则匹配与并行化技术研究</h1>
<p><mark>主要介绍的哈希线性查找和分层树查找。没有介绍传统的软件和硬件</mark>，具体内容看论文。</p>
<p>数据包分类功能是由一个包含有一系列规则的数据包分类器完成，每一类数据包至少遵循其中的一个规则。这些规则是依据数据包头的内容把数据包分为不同的类流，以进行不同的处理，即丢弃、转发。决策代表数据包成功匹配规则之后该进行如何处理，如防火墙中包含的允许（Peimit）拒绝 (Deny)，路由器中包含的丢弃 (Drop)、转发（Forward）等。</p>
<ol type="1">
<li>线性查找</li>
<li>分层树查找</li>
</ol>
<h1 id="基于-gpu-加速的包分类算法研究与实现">2 2020-基于 GPU 加速的包分类算法研究与实现</h1>
<p>OpenFlow 作为数据层面转发数据包依据的主流协议，它打破了传统网络分层的概念，所有需要匹配的字段都包括在一张流表里面，实现了协议的扁平化。</p>
<p>从上面目前 OpenFlow 包分类算法面临的字段匹配需求来看，主要问题在于原有的基于纯 CPU 设计的包分类算法在包分类规模以及字段数量快速增加的情况下，该类算法的性能会大大降低，大部分原因是由于 CPU 的计算能力还不足导致的。从而我们可以考虑寻求计算能力更加强大的硬件来结合 CPU 构建异构包分类架构。其中可选的硬件主要有 TCAM、 FPGA、 GPU。</p>
<p>包分类是一种在预定义规则集中匹配数据包从而根据规则定义的动作处理数据包的方法， 其中输入包可以匹配一个或多个规则， 我们选择具有最高优先级的规则定义的动作处理输入数据包[5]。</p>
<ol type="1">
<li><strong>软件</strong>
<ol type="1">
<li>Tries
<ol type="1">
<li>Hierarch Tries， Grid-of-tries [6-8]</li>
</ol></li>
<li>X-tree
<ol type="1">
<li>布谷鸟过滤器</li>
</ol></li>
<li>分割
<ol type="1">
<li>Hicuts，HyperCuts</li>
</ol></li>
<li>哈希表
<ol type="1">
<li>TSS...</li>
</ol></li>
<li>维度降解
<ol type="1">
<li>RFC</li>
</ol></li>
</ol></li>
<li><strong>硬件</strong>
<ol type="1">
<li>TCAM
<ol type="1">
<li>三态内容地址寄存器） 设计了一系列的包分类算法， 该系列算法具有的很高并行查找能力和极高包类吞吐量[4,15-17]</li>
<li>TCAM 有高功耗高成本等问题</li>
</ol></li>
<li>FPGA
<ol type="1">
<li>利用 FPGA 的流水线架构， 能够在大规模规则集上取得很高的吞吐量， 然而算法的处理延迟很高[18-23]</li>
</ol></li>
<li>GPU
<ol type="1">
<li>利用 GPU 的并行计算能力， 基于 GPU 的计算特点来设计包分类算法， 该类算法能很好的加速数据包的匹配， 有效的缩短数据包处理时间[4,23-28]。</li>
<li>在国内， 也有很多学者基于 TCAM， FPGA，GPU 研究了很多优秀的包分类算法[29-31]，</li>
</ol></li>
</ol></li>
</ol>
<h2 id="指标">2.1 指标</h2>
<p>对于任何一个算法都有其性能评价标准，而包分类算法主要包括下面几个性能指标：</p>
<ol type="1">
<li><p><strong>数据包的匹配速度（分类速度）</strong> ： 包分类算法就是为数据包的快速匹配所设计的，所以数据包的匹配速度作为包分类算法的核心评价指标， 关乎着包分类算法的设计意义。它是包分类算法最重要的性能指标，数据包处理系统应该满足线性处理能力，否则将成为整个系统的瓶颈，影响整个网络的服务质量。数据包的分类速度包括多种情况：</p>
<ol type="1">
<li><strong>平均包分类速度</strong>，对一个包进行分类查找的平均速度；</li>
<li><strong>最坏包分类速度</strong>，对一个包进行分类查找可能的最慢速度；</li>
<li><strong>统计包分类速度</strong>，在符合某种预先指定的规则下，对一个包进行分类查找的速度。<mark>（来源：2015基于OpenFlow协议的高速包分类算法研究_万云凯）</mark></li>
</ol></li>
<li><p><strong>算法内存占用</strong> ： 一个好的算法设计， 不光要考虑到算法的运行速度，该算法的内存占用， 即空间复杂度也是需要考虑的， 优秀的算法都是在一定程度上优化空间复杂度， 以降低该算法的硬件成本， 所以算法的内存占用也是衡量包分类算法性能的重要指标之一。数据包分类算法的内存使用不仅包括</p>
<ol type="1">
<li><strong>存放规则集本身所占用的存储空间</strong></li>
<li>还包括算法建立的<strong>用于查找的数据结构的存储空间</strong></li>
<li>一些算法在<strong>预处理阶段还需要一定的内存使用</strong> <mark>（来源：2015基于OpenFlow协议的高速包分类算法研究_万云凯）</mark></li>
</ol></li>
<li><p><strong>预处理时间</strong>： 对于包分类算法， 在设计过程中会涉及一些数据结构，而<strong>包分类算法的预处理时间基本上都耗费在数据结构的初始化过程中</strong>， 过长预处理时间会降低该包分类算法的整体效率， 由此可见尽量减少预处理时间是至关重要的。</p></li>
<li><p><strong>算法更新时间（更新代价）</strong>： 在包分类算法中， 需要考虑到<strong>规则集的动态更新过程，需要保证规则集动态更新不能过长</strong>， 不然会拉低整个匹配速度， 降低了算法匹配的效率。在规则库中添加或删除规则所需要的代价，同样分为多种情况：</p></li>
<li><p><strong>完全更新</strong>：修改整个规则集，甚至要重新建立包分类算法的数据结构；</p></li>
<li><p><strong>增量更新</strong>：在规则集中增加或删除一条包分类规则。在一些规则集较为固定或者改动较小的场景下，更新代价显得不那么重要；而在一些规则库频繁更新的场景下，更新代价十分重要，某些算法分类速度很快，但更新代价很大，则不适用于这些场景。 <mark>（来源：2015基于OpenFlow协议的高速包分类算法研究_万云凯）</mark></p></li>
<li><p><strong>算法的可扩展性</strong>： 包分类算法涉及到网络中的数据包和规则集， 而随着互联网的发展， 网络中的数据包和规则集的架构会发生变化， 比如规则集的数量增多， 规则集中的字段增加， 这些都是在设计包分类算法的过程中需要考虑的，尤其是在 SDN 网络兴起后， 规则集的规模和字段数量急剧增加， 包分类算法的可扩展性变得越来越关键。</p>
<p>主要是对规则的适应性，包括以下两个方面：<strong>一是对规则数量的扩展</strong>，当规则集中规则数量增多时，算法性能要求能够稳定；<strong>另一方面是分类规则维数和层次上的扩展</strong>，要求算法能够根据更多的字段分类，而这些字段可能来自于数据链路层、网络层、传输层等，网络发展日新月异，理想的包分类算法应该能够处理规则集在数量和维度上的扩展。 <mark>（来源：2015基于OpenFlow协议的高速包分类算法研究_万云凯）</mark></p></li>
</ol>
<p>然而以上五个包分类算法的性能评价指标之间难以同时满足， 达到最优化，从而 <strong>现实中设计包分类算法可以针对一些场景的特点， 适当提高某些性能指标的性能， 牺牲其它指标的性能来满足一些特定场景需求。</strong></p>
<p><strong>如果能够对规则集进行预处理归类， 在查找匹配的过程中只在某个类别的规则集中进行查找， 将会避免遍历整个规则集， 从而提高查找效率</strong>，（🟢 <strong><font color="red">Tips 划重点</font></strong>） 例如上文提到的元组空间查找算法（TSS） 就依据字段之间组合的长度的不同把规则集进行元组划分， 在查找匹配的过程中只在某个元组中进行查找， 大大提高了查找匹配的速度。</p>
<p>🟢 <strong><font color="red">Tips 划重点</font></strong></p>
<blockquote>
<p><strong><mark>所有方法都是这一思想，就是想办法怎么把更快的分类别查找</mark></strong></p>
</blockquote>
<p>在本文中将<strong>利用网络中存在的局部流现象</strong>， 并结合规则集的优先级， <strong>把规则集拆分为主规则集（Major-Table） 和次规则集（Rarely-Table） 两部分</strong>， 查找匹配的时候优先在主规则集中查找， 若查找不到再去次规则集中进行查找， 下文将用 Major-Table 和 Rarely-Table 来分别代替主规则集和次规则集。 为了更快的查找匹配， <strong>对于主规则集和次规则集划分比例将依据局部流现象存在的比例进行划分</strong>。</p>
<p>有大量的研究表明，在现实网络中存在着这样一种现象： 在网络中某段时间内的流往往属于同一段流，而这部分分流占据了网络中的大部分流量，此部分分流被一些研究人员称之为<strong>大象流</strong>，而那部分占据网络中的少部分流量的分流则被称为<strong>老鼠流</strong>。并且有许多研究人员针对大象流和老鼠流的识别做了大量的研究工作, 同时应用于像数据中心这样的大数据流环境当中[44-45]。研究试验后，给出了具体的数据信息如下：</p>
<blockquote>
<p><strong>有大约 9% 的流量占据了网络中 86.7% 的数据包，而且该部分流量的字节数占据了总字节数的 90.5%[46]</strong> （<mark>什么意思不懂</mark>）。总结来说， <strong>网络流的局部现象表现为： 网络中某一个连接的数据包往往会批量集中的到达，当一个数据包到达时，往往下一个数据包也同属于一个连接</strong>[47]。</p>
</blockquote>
<p>一般规则集都是存储在交换设备中， 由一条条的规则项组成， 每条规则项都具有相同的结构</p>
<h2 id="规则集字段的维度划分">2.2 规则集字段的维度划分</h2>
<p>如前文所述， 可以将规则集中的字段匹配方式分为精确匹配， 范围匹配， 前缀匹配三类， 精确匹配的代表字段有协议类型（TCP/UDP） ， 对于像端口号类型字段的匹配则采用范围匹配的方式， 而例如 IP 字段的匹配则采用的是前缀匹配。</p>
<p><strong>由于不同匹配方式的特点不一样，目前还没有一种统一的匹配方式来满足三种字段匹配方式的需求，通常针对每种类型字段的特点，设计不同的匹配算法来各自进行匹配。</strong> （🟢 <strong><font color="red">Tips 划重点</font></strong>）</p>
<p>🟢 <strong><font color="red">Tips 划重点</font></strong></p>
<blockquote>
<p><strong><mark>不同字段就得采用不同的查找方式</mark></strong></p>
</blockquote>
<p>本文在研究三种类型字段的特点后，<strong>针对每种类型的字段各自提出了相应的匹配算法：</strong></p>
<ol type="1">
<li>针对<strong>精确匹配字段</strong>，设计一种可以均衡哈希冲突和哈希查找时间的基于位运算的哈希算法；</li>
<li>对于<strong>范围匹配字段</strong>，利用了区间排序的思路对该类字段提出了聚类查找算法；</li>
<li>为<strong>前缀匹配字段建立了一颗前缀树</strong>，通过宽度优先搜索的方式去掉不相关的树分支，从而达到快速查找的目的，下面将进行具体的介绍。</li>
</ol>
<p>在包分类问题中， <strong>规则集中存在的字段大部分都是属于精确匹配字段</strong>， <strong>所采用的查找算法几乎都是利用哈希来设计的</strong>。 本文设计了一种可以均衡哈希冲突和哈希查找时间的哈希算法， 通过加入位运算的一些特性来减少哈希冲突的概率。</p>
<p>根据上文所述， <strong>在规则集中如源端口号， 目的端口号等字段的取值往往不是一个单一的数值， 基本上是以一个范围区间的形式来展现的</strong>， 针对此类字段我们需要设计相应的查找算法来进行范围匹配字段的查找， <strong>目前针对范围匹配字段的查找算法往往都归类到了前缀匹配字段查找算法中</strong>， 主要思路是根据范围区间构建一棵类似前缀树的范围树来归类范围区间， 在查找的时候通过树结构查找特性快速的进行范围区间的定位， 从而查找到对应的规则集。 但此种<strong>根据范围树来设计的范围匹配字段查找算法的构建过程比较繁琐， 特别是范围区间之间交叠较多的时候， 构建的时间会显得比较长， 不利于快速的更新操作。</strong>（🟢 <strong><font color="red">Tips 划重点</font></strong>）</p>
<p>🟢 <strong><font color="red">Tips 划重点</font></strong></p>
<blockquote>
<p><strong><mark>缺点，有没有更好的解决方案</mark></strong></p>
</blockquote>
<p>前缀匹配字段的查找算法目前比较主流的思路都是通过构建<strong>前缀查找树</strong>来设计的算法， 例如文献中所介绍的算法[50-51]。 此类基于<strong>前缀查找树的算法通常应用于 IP 查找</strong>中， 算法的主要思路在于像 IP 字段中会存在共同的前缀， 通过提取前缀构建查找树， 在查找匹配的过程中就可根据前缀范围快速的进行查找树减枝查找， 缩小查找范围， 加快查找速度。</p>
<p>本章介绍了<strong>一种基于维度分解的实时动态包分类算法</strong>，（🟢 <strong><font color="red">Tips 划重点</font></strong>） 其中基于维度分解的实时动态包分类算法分为了规则集的动态更新算法和字段的维度分解两部分， 对于<strong>字段的维度分解</strong>主要包括了三类字段各自的查找算法：</p>
<ol type="1">
<li><p>基于位运算的哈希算法</p></li>
<li><p>基于二分查找的聚类查找算法（范围）</p></li>
<li><p>基于前缀树的查找算法</p></li>
</ol>
<p>🟢 <strong><font color="red">Tips 划重点</font></strong></p>
<blockquote>
<p><strong><mark>决策树和哈希表能够结合，那么决策树和维度降解，哈希表和维度降解能不能结合</mark></strong></p>
</blockquote>
<h2 id="异构平台编程模型-opencl">2.3 异构平台编程模型-OpenCL</h2>
<p>在目前的计算机架构体系下， 现行的处理器有 CPU， GPU 等， 而不同的处理器所涉及的应用场景不一样， 对于 CPU 来说， 需要处理多条指令和多条数据，属于典型的多指令多数据（Mutiple Instruction Mutiple Data， MIMD） 处理单元。而对于 GPU 来讲， 只需要处理单条指令和多条数据即可满足需求， 属于典型的单指令多数据（Single Instruction Mutiple Data， SIMD） 处理单元。</p>
<p>通常来讲，GPU 是执行特定的任务种类的， 只需要由控制器编译一条指令， 然后通过广播的方式发送到每个处理单元上执行即可[40]。 然而对于 CPU 的设计来说， 要并发处理多条指令和多条数据， 其结构设计十分复杂， 包括很复杂的流水线结构， 不再是单个控制路径， 具有多个控制路径的同时预编译也变得很复杂[41]。 基于以上 CPU 和 GPU 的设计理念来说， <strong>GPU 更加适合处理逻辑单一但数据量密集型的任务， 而 CPU 适合处理逻辑较复杂数据量较小的任务。</strong></p>
<p>由于不同类型的处理器的执行逻辑不一样， 要想结合不同类型的处理器的优点设计一些异构计算的平台， 还需要一个能够统筹不同类型处理器的一个框架，而恰恰 OpenCL 就是这样一个异构平台的框架， 最开始有苹果公司提出， 经过多年发展， 已经成为了异构平台的一个标准， 应用非常广泛。</p>
<h1 id="基于-fpga-的包分类算法的设计与实现">3 基于 FPGA 的包分类算法的设计与实现</h1>
<p>综合比较 ， 区域分割算法相对适合 处理高速数据报文，典型的 区域分割算法有 Hicuts 算法和 HyperCuts 算法 ，是需要进行决策树的构造， 耗费大量时间。</p>
<p>表 2-2 各种算法性能比较 （33 页）</p>
<h1 id="基于规则聚集特征的高速分类算法">4 基于规则聚集特征的高速分类算法</h1>
<p>里面有分类方法，分成了四类（<strong>没看完，再看吧，现在不想看 2022/11/06/15:34</strong>，原因实验室太压抑了，受不人这么多....</p>
<p>待看：</p>
<h1 id="gpu">5 2016-GPU</h1>
<blockquote>
<ol type="1">
<li>有关于硬件 FPGA，TCAM，GPU 包分类的阐述。</li>
<li>软件有树方案，端口范围的元组表达：嵌套层和范围编号。</li>
</ol>
</blockquote>
<p>一个规则集含有任意多条规则，<strong>每条规则由三部分组成</strong>：</p>
<ol type="1">
<li><strong>与域有关的条件表达式</strong>，表达式可能是<strong>前缀</strong>（数据包中的 IP 地址域需要进行前缀匹配），也可能是<strong>范围</strong>（端口号域需要进行范围匹配），或者是一个<strong>精确的值</strong>（协议类型需要进行精确匹配）</li>
<li><strong>优先级</strong>，声明该条规则在规则集中的优先级，当一个数据包和多条规则匹配时，优先级最高的规则生效</li>
<li><strong>执行动作</strong>，如果输入的数据包与规则匹配，则根据该动作对数据包处理。</li>
</ol>
<h2 id="基于软件的方案">5.1 基于软件的方案</h2>
<p>字典树（Trie）广泛应用于 IP 地址查找以实现高效、稳定的最长前缀匹配[1-3]。由于多域规则匹配的难度和复杂性也主要来自于对于 IP 地址域的处理，层次化字典树同样也被采用来解决多域规则匹配[46]。文献[7]提出一种二维字典树结构来组织分类规则，并给出了相应的查找及更新算法。<strong>利用字典树结构的特性将各种长度的前缀组合进行分组，并依此将整个规则集分成多个子集</strong>。查找时将每一次查找过程分解成若干个可以独立运行的子任务，每个子任务处理一个子集。两级混合字典树结构保持了规则之间的独立性，因此可以快速地对单条规则进行增量删除或添加。实验结果表明，该算法在保持高速查找的基础上，将单条规则的增量更新操作速度提高到了和单次查找操作同样的量级，同时并行查找使得算法对规则类型和规模的敏感度大大降低，具有较好的可扩展</p>
<p><strong>CBHT（Counting Bloom filter and Hash Table）算法</strong>[23]1 从数据包匹配规则的聚集特性出发，将计数布鲁姆过滤器和哈希表相结合。基于包匹配规则的聚集特性，对于五维包分类问题，CBHT 算法首先利用计数布鲁姆过滤器的过滤功能结合单域匹配获得与前两维匹配的小规模规则集，而后在此有限规则集中对后三维进行匹配。利用计数布鲁姆过滤器提高了包匹配速度并有效支持规则库的动态更新。实验结果表明 CBHT 算法比现有的 B2PC 算法节省 60% 的硬件资源，包匹配访问内存次数平均低于 B2PC 算法 22.8%。</p>
<p>文献[24]提出一种<strong>基于流的局部特性和多级查找的高效包分类算法</strong>，同时可以支持规则集动态更新，实现快速包分类。该算法分为<strong>三级结构</strong>，<strong>第一级</strong>缓存用于存放最近 10 秒内到达的流，<strong>第二级</strong>计数布鲁姆过滤器存放最近 10 秒至 60 秒内到达的流，<strong>第三级</strong>计数布鲁姆过滤器存放剩余的流。实验表明，该算法比传统的包分类算法，在空间消耗相近的情况下具有更好的时间性能。</p>
<p>元组空间（Tuple Space）的思想[25]于 1999 年被首次提出，作者设计了一系列基于元组空间的包分类算法。基于元组空间算法的基本思想是将整个规则库根据每个维度规则的特征，将规则集划分成多个子规则集，具有<strong>相同特征</strong>（<mark>划重点：什么叫相同特征，不同划分方式可以吗</mark>）的规则属于一个子规则集中。据此将一个复杂的问题分为多个简单的问题，那么一次复杂的包分类操作可以转化为多个互不相关的、较简单的匹配操作，不但匹配速度性能可以得到优化，分类器的设计也能得到简化。 表 2.2 中给出了一个简单规则集，作为说明元组空间算法思想的样例，其中源/目的 IP 地址域前缀长度为 4 比特，源/目的端口号为 4 比特，协议类型为 8 比特。<strong>对于不同的域，作者定义元组值的方式不同</strong>：</p>
<ol type="1">
<li><strong>对于源/目的 IP 地址域</strong>，以前缀长度作为元组值；</li>
<li><strong>对于协议类型域</strong>，如果协议类型是确定值，则定义元组值为 1，如果协议类型是通配符，则定义元组值为 0；</li>
<li><strong>对于源/目的端口域</strong>，作者引入<strong>嵌套层</strong>（Nesting Level）和<strong>范围编号</strong>（Range ID）的概念，并将嵌套层的值作为端口域的元组值。如图 2.1 所示，<strong>嵌套层指明了层次</strong>，而<strong>范围编号是该层中范围的标识</strong>。这样可以把所有的端口范围转成一个由嵌套层和范围编号构成的二元组。 <img src="https://cdn.staticaly.com/gh/peirsist/blog_img@master/规则集.58z6u2akcz40.png" alt="规则集"> <img src="https://cdn.staticaly.com/gh/peirsist/blog_img@master/嵌套层.39o4uppt3100.png" alt="嵌套层"></li>
</ol>
<p>通过<strong>将原规则集按照规则特征分割成若干子规则集</strong>，在各个子规则集（元组空间）中的搜索可以采用高效的哈希技术，将数据包头中的值作为哈希函数的搜索关键字。例如，为元组空间 [4，0，2，0，0] 设计哈希函数，可以将源/目的 IP 地址、源/目的端口号范围编号以及协议类型作为搜索关键字。 对每个元组空间进行数据包分类的过程是独立的，因此<strong>元组空间算法可以并行实现，即并行地对所有的元组空间进行搜索，再合并搜索结果</strong>。然而，采用并行实现的难处在于，每个元组空间或其子集的大小是不可预料的，导致每个元组空间的时间耗费较为不稳定。但在大多数情况下，元组空间算法的性能表现较为理想。</p>
<h2 id="基于硬件的方案">5.2 基于硬件的方案</h2>
<h3 id="基于-fpga-的解决方案">5.2.1 基于 FPGA 的解决方案</h3>
<p>FPGA 包含可重编程逻辑块阵列，并且是可以重构互连，允许各块连接在一起的层次结构。以硬件描述语言（HDL 或者 ASIC）所完成的电路设计，可以经过简单的布局与设计，烧制到 FPGA 进行调试。因此 FPGA 是作为集成电路里面一种半定制的电路出现的，既解决了定制电路的不足，又克服了原有可编程器件门电路数有限的缺点。因此 FPGA 日益受到各方面研究者的欢迎，尤其是对于某些需要进行特定配置和能够进行重复配置的电路设计，如包分类算法电路的设计。</p>
<p>文献（26）在型号为 Xilinx Virtex 2 Pro 的 FPGA 上部署了 DCFL（Distributed Crosspro-ducting of Field Labels）算法[27]，完整实现了防火墙功能，并且支持规则集的更新功能。当规则集中有 128 条规则时，该实现方案可以达到 50 MPPS 的吞吐率。并且他们预测如果该方案在 Virtex-5 FPGA 上实现时，吞吐率可以达到 24 Gbps。 文献[28]提出一种基于维度分解的数据包分类算法，该算法在每个域使用了布鲁姆过滤器加速查询，最后合并查询结果。作者将该算法在 FPGA 上实现，称为 2sBFCE。该实现方案对内存空间的需求非常小，仅 178K 字节存储 4 千条规则。但是他们的实现方案平均 26 个时钟周期完成一次包分类，导致总体的系统吞吐率不高，平均只有 1.875 Gbps。并且该方案由于使用了布鲁姆过滤器，还存在假阳性的问题。</p>
<p>为了降低能耗，文献（29) 提出在型号为 Altera's Cyclone III 的 FPGA 上实现一种简化的 HyperCuts 算法。他们在叶子节点中存储上百条规则，并且在执行包分类时并行查询，因此芯片以很低的频率运行（32MHz）。但是由于决策树的结构不能实现流水线，该实现方案的性能不理想，在规则集为 2 万条防火墙类型规则的情况下，需要 23 个时钟周期去完成一次数据包分类，总体系统的吞吐率只有 0.47 Gbps。</p>
<h3 id="基于-tcam-的解决方案">5.2.2 基于 TCAM 的解决方案</h3>
<p>TCAM（Ternary Content Address Memory）是一种基于内容查找的存储器。<strong>TCAM 不但能存储“0”、“1”状态，而且能够存储 “ * ”（Don’t Care）状态，因而被称为“三态”（Ternary Content）。</strong> 包分类规则<strong>在 TCAM 内部存储时一般以比特串和前缀掩码的形式表示</strong>。当包头关键字被送到 TCAM 输入端，TCAM 内部的所有存储表项都会被<strong>同时触发</strong>与输入进行匹配比较，并且能够保证在一个时钟内完成查找。当匹配发生时，匹配表项的地址将会被作为输出结果返回。</p>
<p>前缀扩展算法[30]是一种经典的使用 TCAM 实现包分类的算法。该算法将规则中源/目的端口域的范围匹配转换成若干个前缀匹配，并将每条前缀分别存储在 TCAM 中。例如，范围[0，10]可以转换成三条前缀匹配：0**<em>，100</em> 和 1010（<mark>怎么算的，不懂</mark>）。虽然该算法实现简单，性能较好，并且支持规则集的更新操作，但 TCAM 的利用率极低。在一般的五维包分类规则中，源端口域和目的端口域都属于范围匹配，在最差情况下，一条规则最多需要扩展为 900 条 TCAM 表项。而 Taylor[31]对多个实际规则集进行范围前缀扩展实验，结果显示每条规则的平均扩展系数为 6 倍多，TCAM 的存储空间利用率仅为 16.12%。</p>
<p>总体上，TCAM 的优点是逻辑简单，基于内容查找的特点和完全并发进行的能力，一个时钟就可以完成一次匹配过程，可以实现 O（1）的时间复杂度。但 TCAM 的缺点在于：<strong>（1）价格相对其他内存昂贵很多，且集成度低</strong>。这些是由于其内部实现的复杂，包含众多的比较器和逻辑连线，使得难以大规模的集成，并造成昂贵的价格。<strong>（2）能耗较大</strong>。由 TCAM 的工作原理可知，每次查找匹配时都进行完全并发的操作，所有表项均参与内容比较，从而导致了 TCAM 的运行功耗极高。<strong>（3）不支持数值范围类型的规则域值</strong>，需要将范围匹配转换成前缀匹配的形式，或者以编码的方式克服。</p>
<h3 id="基于-gpu-的解决方案">5.2.3 基于 GPU 的解决方案</h3>
<p>基于 GPU 的包分类解决方案兼顾了灵活性与高性能，同时在可扩展性方面也有较大的优势，因此受到研究者们广泛的关注。基于 GPU 的解决方案通过编写并行程序，以软件形式实现高性能的包分类。其运行的程序可以及时、灵活地进行配置、更新。同时，整体系统平台通过升级、加装新的 GPU、CPU、网卡即可获得相应的性能的提升，容易实现横向扩展性能，因而系统的可扩展性较强。</p>
<p>文献[35]提出使用 GPU 加速线性搜索算法和 RFC 算法的方法，利用 GPU 的线程级并行处理能力加速包分类吞吐率，并对其性能及优化方法进行详细分析。实验结果表明，GPU 加速的线性搜索算法和 RFC 算法与纯 CPU 系统执行相比可达到 4.4 至 132.5 倍的加速比。 <img src="https://cdn.staticaly.com/gh/peirsist/blog_img@master/GPU数据包.2x5kabxe8fs0.png" alt="GPU 数据包"></p>
<p><mark>GPU 方法没看完，等做的时候在看吧。2022/22/07/11:58</mark></p>
<h2 id="classbench">5.3 ClassBench</h2>
<p>由于涉及到网络的安全问题，实际网络中的用于数据包分类的规则集都是非公开的。这使得只有极少数的科研团体和组织中能够获得这些规则集，并用来对包分类算法进行测试、评估。华盛顿大学的 David E.Taylor 和 Jonathan S.Turner 开发了包分类规则集生成软件 ClassBench[46]，作为包分类算法的评估工具。</p>
<p>ClassBench 工具的设计者首先从实际应用场景中采集规则集，并分析这些规则集的特征，针对每个匹配域进行统计分析，得到一系列能够反映规则集特征的参数，并且据此生成与真实规则集类似的合成规则集。同时，它也能够根据生成的规则集，产生对应的模拟的数据包头文件，便于对数据包分类算法的验证和检测。<strong>ClassBench 由三个工具组成：</strong></p>
<ol type="1">
<li><strong>规则集分析器（database analyzer）</strong>
<ol type="1">
<li>规则集分析器能够根据实际使用的真实规则集生成参数文件（parameter files）。该参数文件包含对真实规则集进行抽象之后的统计和概率分布，并作为规则集产生器的输入文件，以生成大量和原始规则集具有相关特性的合成规则集。此工具选择了 3 种类型（ACL、FW、IPC）共 12 个真实的规则集进行了筛选和研究。</li>
</ol></li>
<li><strong>规则集生成器（filter set generator）</strong>
<ol type="1">
<li>在规则集生成器生成的规则集文件中，每一行含有一条规则。每条规则以 @ 开头，其各个域之间以制表符分隔。第一个域是点式十进制表示的源 IP 地址以及其前缀大小，例如 192.168.0.0/16 表示前 16 个比特满足 192.168 的前缀匹配。第二个域是目的 IP 地址及其前缀长度，与源 IP 地址域的表示形式相同。第三个域是源端口号，其下限值与上限值以冒号分隔，例如 0：1023 表示源端口号需在[0，1023]的范围内。第四个域是目的端口号，与源端口号域的表示形式相同。最后一个域是以十六进制形式表示的协议类型以及其掩码。</li>
</ol></li>
<li><strong>流生成器（trace generator）</strong>
<ol type="1">
<li>流生成器的作用是分析规则集文件，并生成与之对应的数据包头文件，便于算，法的性能、正确性等各个方面的检测。其生成的数据包头中，每条规则都会有对应的确定数量的数据包。</li>
</ol></li>
</ol>
<h3 id="比特划分树">5.3.1 比特划分树</h3>
<p>比特划分树（Bit-Split Tree，简写为 BSTree）是一种基于比特划分的树形数据结构。 在 OpenFlow 协议的流表查询操作中，<strong>数据域有两种匹配条件</strong>，<strong>一种是前缀匹配</strong>，适用于 IP 地址，形如 192.168.0.0/16，即前 16 比特的前缀匹配，也可以转换为二进制的形式 1100000010101000 * * * * * * * * * * * * * ；<strong>另一种是可能含有通配符的精确匹配</strong>，适用于端口号、MAC 地址等域。因此，通过将前缀匹配转换成二进制，可以将规则视为含有通配符的比特串，形如 01010 *** 01010。</p>
<p>首先将流表中所有的规则转换为含有通配符的比特串形式。在构建 BSTree 的起始时，根节点中含有所有的规则。根据规则中某一比特位为 0 或 1，可以对规则集进行划分，形成两个子规则集，分别生成左、右子树。如果某条规则在选取的比特位是通配符，则该条规则同时进入两个子树。<strong>如何选取合适的比特位进行分割对 BSTree 的结构和性能影响重大</strong>。这里使用贪心的策略选取比特位，枚举所有的比特位，分别计算以该比特位划分后左右子树的大小。优先选择使得两棵子树大小的最大值最小化的比特位，如果有多个比特位满足这一条件，则进一步选择使得子树大小总和最小化的比特位。如果仍有多个比特位满足条件，则随机选取任一比特位。</p>
<p>通过不断地选取比特位、划分规则集、生成子树，子树中含有的规则数目将越来越小。如此递归地分割，直到叶子节点中规则数小于预设的阅值，则停止划分，该节点成为叶子节点。</p>
<p>一个简单的构造 BSTree 的例子如图 5.1 所示，这里假设有规则集中共有 5 条规则。 为了方便举例，假设每条规则有 2 个维度，每个维度中有 2 个比特位。</p>
<p>对于一些含有通配符较多的规则，例如 60%以上的比特位均为通配符的规则，若参与树的构建，将出现在绝大多数的叶子节点中，造成极大的空间开销，并且影响性能。所以这样的规则将不参与树的构建，而在查询时将单独处理。</p>
<h3 id="流表查询操作">5.3.2 流表查询操作</h3>
<p><mark>什么叫流表</mark></p>
<p>对一个数据包的流表查询操作从 BSTree 的根节点开始，每进入一个非叶子节点，从数据包头中取出该节点选取的比特位，根据该比特位为 0 或 1，决定向左子树或右子树转移。该数据包不断地在 BSTree 中转移，直到进入叶子节点。当进入叶子节点，对叶子节点中的规则集进行线性搜索，找出与该数据包匹配的优先级最高的规则。</p>
<h3 id="更新操作">5.3.3 更新操作</h3>
<ol type="1">
<li>插入</li>
<li>删除</li>
</ol>
<p><mark>看论文部分</mark></p>
<h1 id="openflow-协议">6 2015-openflow 协议</h1>
<blockquote>
<ol type="1">
<li>TCAM的介绍和分类方法的简介</li>
</ol>
</blockquote>
<p>网络安全和网络服务要求网络流量进行更加细粒度的分类[1-3]，以满足在防火墙 (Firewall)[4]、服务质量(Quality of Service)[5-6]、策略路由(Policy Routing)[7]、流量计费 (Traffic Billing)[8]等各个领域[9]的需求。数据包分类技术应运而生。</p>
<p>🟢 <strong><font color="red">Tips 划重点</font></strong></p>
<blockquote>
<p><strong><mark>包分类算法的背景还需要了解一下，了解背景有助于发现问题的本质。比如包分类在哪些地方应用，Action都有哪些，</mark></strong></p>
</blockquote>
<p>网络功能虚拟化（Network Function Virtualization）[10-11]以及软件定义网络（Software Defined Network，SDN）[12-13]等一系列前沿网络技术的发展，对数据 包分类技术提出了更高的标准和要求</p>
<p><mark>了解一下SDN</mark></p>
<p>表 2.1 是一个<strong>决策只包括允许和拒绝的 ACL 规则集</strong>，假设此时一个包头为（175.77.88.254, 195.156.61.102, 102, 1710，UDP）的数据包到来，那么它将匹配的规则是规则 1，也就是说它被允许通过。</p>
<h1 id="高性能-ip-路由查找和分组分类技术的研究_郑凯-里面有详细分类">7 2001-高性能 IP 路由查找和分组分类技术的研究_郑凯 里面有详细分类</h1>
<blockquote>
<ol type="1">
<li>详细的分类简介</li>
</ol>
</blockquote>
<h1 id="包分类算法研究综述张杰鑫张铮">2015 包分类算法研究综述张杰鑫，张铮</h1>
<h2 id="规则集特征概述和管理">规则集特征概述和管理</h2>
<p>文献［８］对大量实际的规则集进行了研究，结果表明，实际规则集的规则数目不会太多，规则的协议域通常只有很少的几个取值，端口号的取值范围很广等特征。实际统计结果是所有规则集的实际复杂度均远小于理论复杂度［９］。 [8] Gupta P, McKeown N. Packet Classification on Multiple Fields (C) // Proce edings of ACM SIGCOMM' 99. New York, USA: ACM Press, 1999:14 7-160. [9] 元亚炬，李军. 高性能网包分类理论与算法综述[J]. 计算机学报，2013，36（2）：408-421.</p>
<h1 id="决策树网包分类算法综述">2018-决策树网包分类算法综述</h1>
<h2 id="实际应用中规则集的特点">实际应用中规则集的特点</h2>
<p>虽然理论上的复杂性让我们很难设计一个单一的算法来很好的适应各种情况。但是，网包分类问题在现实应用中有一些内在的特点，可以用来降低网包分类的复杂度［7，8］ 。 Gupta 等人［9］通过对实际规则集的观察，总结出一系列<strong>规则集的特征</strong>:</p>
<ol type="1">
<li><p><strong>规则集的协议域限定在一个很小的范围内</strong>。Taylor［10］等人通过对 12 个真实的规则集进行分析， 得到规则集中常出现的协议为 TCP、UDP、ICMP、IPE、GRE、ESP、AH、EIGRP、OSPF，其中 <strong>TCP 的使用频率 最高</strong>。</p></li>
<li><p><strong>端口号的范围通常很大，经常出现大于1023 的端口号</strong>。</p></li>
<li><p><strong>与同一网包完全匹配的规则一般情况下少于5 个</strong>。</p></li>
<li><p><strong>常见的前缀长度为</strong>0、32、21、23、24、30。</p></li>
<li><p><strong>同一规则集内，多个规则往往在某个域上有相同的值</strong>。</p></li>
<li><p><strong>规则集中含有部分冗余的规则</strong>。</p></li>
</ol>
<p>其中冗余是指: ①规则 T 出现在规则 R 之前，并且 R 是 T 的子集，因此网包会先匹配规则 T，而不会匹配规则 R。②规则 T 出现在规则 R 之后，并且 R 是 T 的子集，R 和 T 具 有相同的动作，在R 和 T 之间的规则，要么与R 不相交，要么与R 具有相同的动作。这种前向冗余可以只保 留具有相同动作并且范围更大的规则 T，对数据包进行匹配。</p>
<p>实际应用中的规则集重叠的情况也与理论上的有所不同，Qi［11］等人对 WUSTL( 华盛顿大学圣路易斯分校) 公开的数据集进行分析，统计包括 ACL、FW、IPC 等一系列的规则集在各个维度上的投影区间个数，说 明了网包分类问题的实际复杂性，如表2 所示，根据表2 结果可以看出:</p>
<ol type="1">
<li><p>同一类型规则集合在不同维度上的统计特性不同。</p></li>
<li><p>不同种类的规则集合的统计特性不同，虽然不同类型的规则有不同的特点。</p></li>
<li><p>所有规则集合的实际复杂度均远小于理论复杂度。</p></li>
</ol>
<figure>
<img src="https://cdn.staticaly.com/gh/peirsist/blog_img@master/规则集复杂性比较.4ra856lh60s0.png" alt="规则集复杂性比较"><figcaption aria-hidden="true">规则集复杂性比较</figcaption>
</figure>
<p>第二种，基于规则集的特点优化的软件算法，这类算法是对实际规则集 进行观察，了解规则集的一些特点，利用这些特点实现更有效的网包分类算法应用于实际网络中。算法通常在特定的规则集上才有明显的效果，由于不同环境下的规则集具有不同的特点，很少有算法可以 适应所有条件下的规则集。</p>
<p>最长前缀匹配，<strong>掩码匹配</strong>（<mark>什么是掩码匹配</mark>），精确匹配这些匹配方式的混合使用使得决策树中的每个节点都变得更加复杂。一种简单的解决方式是选择单一类型的匹配方式来覆盖匹配条件。例如将精确匹配，最长前缀匹配转 换成掩码匹配的形式，用1，0，* ( 通配) 来表示。表 4 规则集中的规则包含 2 个域: 3bit 的地址前缀，3bit 的 端口号范围。表5 为表4 的 bit 向量形式，将2 个域的向量串接起来即可构成一棵决策树，其中每个叶子都 唯一的代表规则集中的一条规则。图1 为根据表5 构建的决策树的部分示意图。</p>
<p>HyperCuts 并不是对所有域进行切割，而是选择部分域进行切割，其中的选择方式为计算每个域中唯一区间的数量，以及所有域唯一区间数量的均值，选择唯一区间数量大于均值的域进行切割。例如，对于五元 组的5 个域，每个域的唯一区间数量为45、15、35、10、3，均值是 22。那么选择第 1 个和第 3 个域进行切割。 切割次数 NC( number of cuts) 利用启发式算法来确定。通过以下3 个方面来确定切割次数 NC: ①所有叶子 中规则数量的均值; ②叶子中含有规则数量的最大值; ③空的叶子的数量。切割次数从 1 开始，每次调整将 切割的次数乘2，然后判断均值是否减小? 子节点中规则最大值是否减小? 空节点数量是否增加? 这样持 续下去，在可允许的空间内选择最优的切割次数。如果某次切割后，空节点数量明显增加，那么就回退到上 次的切割次数，作为最优的切割次数。</p>
<p>本文按照发展过程介绍了 7 个受到广泛关注的基于决策树的网包分类算法。决策树的结构提升了网包分类的速度，<strong>构建决策树的结构需要考虑以下几个方面</strong>:</p>
<ol type="1">
<li><p>是否划分规则集;</p></li>
<li><p>域空间的切割方式;</p></li>
<li><p>决策树节点的数据结构。</p></li>
</ol>
<p>基于决策树的网包分类算法普遍存在<strong>以牺牲内存为代价提升了网包的分类速度</strong>的情况，为了快速的分类，树中不可避免的存在冗余的规则。通过划分规则集的方式可以减少规则冗余的数量，然而过多的规则子集数量将影响网包的分类速度。分类速度与内存空间构成矛盾，需按照实际情况平衡。但是基于决策树的算法规则更新的速度差强人意，规则的更新很可能导致决策树的重建。</p>
<p>总之，基于决策树的网包分类算法其优秀的分类性能满足了当前巨大网络流量的网络环境。但基于决策树的算法产生的规则冗余，占用大量内存空间，以及规则更新性能不佳的缺点导致其无法适用于对内存空间有严格限制，更新频繁的场景。减少决策树中的规则冗余，提高规则更新速度也是网包分类技术的研究重点。</p>
]]></content>
      <categories>
        <category>论文</category>
      </categories>
  </entry>
  <entry>
    <title>论文笔记-背景-RelatedWork</title>
    <url>/2022/11/03/%E8%AE%BA%E6%96%87/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0-%E8%83%8C%E6%99%AF-RelatedWork/</url>
    <content><![CDATA[<h1 id="面向未来网络的高性能数据包查找与分类技术研究">2019面向未来网络的高性能数据包查找与分类技术研究</h1>
<p>沈潼 张大方 湖南大学 信息科学与工程学院</p>
<p>本文提出了范围向量的概念，并依据这个概念提出了一种基于散列函数的支持规则快速更新的高性能包分类算法。本文根据真实规则的源与目的地址前缀长度的分布将规则映射到不同的范围向量空间，数据包分类时需要在各个范围向量空间内查找，通常需要遍历所有范围向量空间。基于这个观察，本文设计并实现了一种基于范围向量的散列算法。每一个范围向量对应的散列表使用各字段的最大公共比特长度进行散列计算。范围向量散列算法具有常数级的规则更新速度。由于数据包分类是根据匹配规则的最高优先级决定，因此该算法需要搜索所有散列表。本文通过定义散列表的优先级对散列表进行优先级排序。因此，该算法可以在不降低更新性能和不增加内存消耗的前提下，进一步提高包分类的速度。</p>
<p>现有的基于软件的包分类算法大多是单线程，少数算法能够扩展到多线程，因此研究多线程包分类算法具有非常重要理论依据和应用意义。本文针对不同的算法逻辑和数据结构，合理运用数据并行模式和流水线并行模式，设计了一个通用的多线程包分类框架。同时，本文还对多线程的锁机制进行优化，利用原子操作和硬件同步原语设计无锁化多线程版本，实现真正意义上每个线程的独立运行。</p>
<h2 id="背景">背景</h2>
<p>互联网实际上就是由网络节点和网络链路组成的一个庞大系统。其中，网络节点负责网络功能的实现与运行，而网络链路负责数据与信息的传输。网络链路的传输速度由链路介质及传输技术决定，而网络节点的性能则由数据层的相关技术决定。</p>
<p>数据包分类是指根据指定的数据包携带的一系列信息（如源地址、目的地址、源端口号、目的端口号和协议等）在一套规则集中按照最高优先级匹配的原则，找到该数据包待执行的操作或任务。</p>
<p><mark>软件定义网络是什么？</mark></p>
<p>包分类是交换机、路由器和其他网络设备中用于支持安全性[56]、QoS[57,58]和高级功能[59,60]的基本操作之一，其中数据包在分类器中根据多字段规则集进行匹配。 例如，为了保护网络资源不被攻击，五元组防火墙规则通常被添加到交换机以筛选 哪些数据包应该被通过哪些应该被丢弃。在传统的网络应用中，规则保持相对静态。 因此，离线构建的分类器通常拥有设计精良的数据结构，这类分类器可以实现高效 的数据包分类。数据包分类器设计的主要目标是通过合理的内存占用来执行高速数 据包转发。由于规则更新不频繁，分类器可以离线构建。</p>
<p>软件定义网络[50,61,62]（SDN）的出现为网络创新提供了巨大的机会，以使网 络支持新的特性和增值功能。这些功能包括流量工程[63]、网络功能虚拟化[64,65]（NFV）和高性能云计算[66,67]的支持。然而，这些新功能除了依赖于基本的快速包 分类外，还依赖于分类器中规则的动态更新能力[40,68]。一方面，网络应用必须对大 量的用户和请求进行即时响应，使得分类器规则必须频繁更新，以满足不同的需求。 另一方面，网络功能的常规迁移或变更总是会改变拓扑结构和策略，从而分类器的 规则必定会有相应的更新。因此，快速的规则更新对于当前的分类器是绝对必要且 有意义的。</p>
<p>尽管包分类非常重要，并且已经吸引了很多研究者的关注，但是现有的算法往往不能同时满足上述两个要求，即快速包分类的同时支持快速规则更新。决策树的算法，如HyperCuts[36]、EffiCuts[37]和SmartSplit[38]，都能实现快速的包分 类，但不能实现快速的规则更新。基于哈希的算法，比如在Open vSwitch[69]（OVS） 中实现的元组空间搜索[39]（TSS），可以实现快速规则更新但不能实现高速包分类。 PartitionSort[40]（PS）和TupleMerge[41]（TM）可以提升包分类的速度但都牺牲了规 则更新的性能。同时实现快速的包分类和规则更新是满足先进的网络管理和高效云 计算的新需求和基本挑战之一。</p>
<h2 id="现状">现状</h2>
<p>在工业界，大型路由器以及高端分类器都是利用硬件设备，如三态内容寻址存储器（TCAM）、现场可编程门阵列（FPGA）和专门的网络处理器芯片，来实现高性能的数据包查找和分类。尽管这些器件设备具有非常好的性能，也能满足当前的大多数需求，但是它们的成本非常昂贵，导致它们的售价非常高。</p>
<p>路由查找算法根据数据结构的不同可分为基于字典树的算法、基于决策搜索树的算法以及基于哈希表过滤器的算法，而包分类算法则可以分为基于维度降解的算法和基于空间划分的算法。本文所提出的所有方法，都是基于软件的，并不针对某一类特殊硬件。</p>
<p>高性能在线包分类算法的研究。该研究点是对匹配内容的维度的扩展。即从单维度扩展到了多维度。包分类从匹配过程这个角度来看是多个字段的查找匹配，或者说路由查找是包分类在单维度上的特例。为了解决包分类规则频繁更新的问题，本文提出了一种基于范围向量哈希的在线包分类算法，在保证高效的数据包分类的同时，提供快速的规则更新。</p>
<p>包分类技术不仅仅会被应用在路由器上，它们还可能会被应用在网管、防火墙、端系统等所有可能的网络节点上。而这些设备往往不仅仅只是用于包分类，而是集成了其它的功能。通常，<strong>用于包分类的那部分功能会被作为模块抽取出来，形成分类器</strong>，便于重复利用。图2.2为一个普通分类器的结构和功能图。通常分类器会包含一个规则集，当数据包到达时，先对包头进行解析，然后根据包头字段在规则集找到匹配的规则，并实行匹配规则规定的行为。</p>
<blockquote>
<p>通常在传统的TCP/IP协议里为5个字段，在OpenFlow协议[32]里可以达到40多个字段。</p>
</blockquote>
<figure>
<img src="https://cdn.staticaly.com/gh/peirsist/blog_img@master/分类器.5fwaxpgm8nk0.png" alt="分类器"><figcaption aria-hidden="true">分类器</figcaption>
</figure>
<p>包分类规则集是分类器中最关键的数据结构之一。规则集通常是由控制器生成并进行维护的。规则集包含一系列分类规则，每一个规则又包含了用于分类数据包 需要判断的所有包头字段（匹配域）、规则优先级以及一个或多个行为（操作）。包 分类规则集通常包含几十万条规则，因此存储在片外存储器上。为了加快分类速度， 分类器通常会在片上存储器中维护一个或多个小规则集作为大规则集缓存。在数据 包分类的过程中，可能会有多个规则与分类对象匹配，这时根据最高优先级匹配的 原则，选择这些匹配规则中优先级最高的规则作为最终的匹配结果，并执行其规定的操作。</p>
<h2 id="包分类算法">包分类算法</h2>
<p>基于维度降解的算法 Cross-producting[33]和RFC[34]将多维规则分割成若干个单维规则。它们逐个与单维规则进行匹配，然后合并各个匹配的结果。这类方法的更新速度非常缓慢，因为 每个单维规则都对应一次规则更新。此外，最终的合并过程将成为性能瓶颈，尤其 当规则集较大时。</p>
<p>基于空间划分的方法通常将 <strong>整个规则空间划分为若干个子空间，将规则集分为几组分别放入每个子空间中</strong>。 分为两个步骤，<strong>1）确定要搜索的子空间</strong> ，以及 <strong>2）将数据包与相应子空间中的子规则集进行匹配</strong>，而不是将传入的数据包直接与整个规则集进行匹配。这种类型的方法进一步分为两个主要的子类别：基于决策树的方法和基于哈希的方法。</p>
<p>基于决策树的方法，它们的关键思想如HiCuts[35]和HyperCuts[36]是将搜索空间 <strong>递归划分</strong> 成若干子区域，直到每个区域中的规则数量低于某一阈值。由于决策树的效率，这些方法可以实现高速数据包分类。然而，其中一个缺点是由于规则复制而导致大量内存消耗，因为有些规则可能需要复制到多个分区中。<strong>缓慢和复杂的规则更新是这些方法的另一个缺点</strong>。虽然EffiCuts[37]和SmartSplit[38]基于规则分布，采用不同的规则空间分区策略来减少规则复制和内存访问量，但它们仍然不能支持快速更新。</p>
<p><strong>现有的基于散列的方法可以实现快速规则更新，但不能高效分类</strong>。在OVS中实现的元组空间搜索方法[39]（TSS）基于元组将规则划分成不同的子集。<strong>一个元组是一组前缀长度构成的向量</strong>，每个前缀长度对应于规则集中各个字段的长度。<strong>每个子集部署为哈希表</strong> 以实现数据包的快速索引分类和快速规则更新。为了对数据包进行分类并遵循优先级优先的原则，需要搜索所有的哈希表，从而其分类时间将随着哈希表的数量线性增加。 修剪元组空间搜索算法[39]（PTSS）通过元组按照包含关系以字典树的形式过滤掉那些不可能匹配的远足空间来提升分类性能。虽然在PTSS中确实可以减少用于 匹配的元组的数量，但是合并结果非常耗时，并且更新操作仍然很复杂。</p>
<p>PartitionSort[40]（PS）结合了TSS和决策树的优点。PS不是基于元组划分规则，而是将规则划分成可排序的规则集，并通过平衡搜索树存储它们。因此，PS以处理可排序规则集为代价，减少了哈希计算次数，实现了比TSS更快的数据包分类。换 句话说，与TSS相比，PS以降低规则更新的速度来加快数据包的分类速度。</p>
<p>TupleMerge[41]（TM）通过减少得到的哈希表的数量来改进TSS的分类。TM重新定义了规则和元组之间的兼容性，以便那些相似但不完全相同的规则可以放在同 一个哈希表（元组）中。然而，这种方法可能导致哈希表的重叠，这将导致一个规则可能映射到的哈希表是不确定的，从而严重损害了规则更新的性能。此外，哈希表的数量会随着时间的推移而增加，因此，在一定时间后其分类性能会急剧下降。 为了重新提升性能，当哈希表的数量超过某一阈值时，必须重新构建所有哈希表。 这使得它不能应用于在线包分类。</p>
<blockquote>
<p>什么是OVS? OVS是一个高质量的，多层虚拟交换机。虚拟交换呢？就是，利用软件的方式形成交换部件，所以也叫软件交换机，跟传统的物理交换机相比，虚拟交换机同要具备很多有点：1.配置灵活，因为是软件实现的，一台物理服务器上可以配置数十太或者数百台虚拟交换机，而且端口数目可以灵活选择 2. 成本低廉，通过软件的方式可轻易达到10Gbps的交换速度。 <a href="https://blog.csdn.net/sqx2011/article/details/39344869">OVS - 简介</a></p>
</blockquote>
<p><strong>数据包查找和分类技术本身并不复杂，但是随着网络技术和网络功能的不断更新和发展，已有的算法已经不适应当前网络对于性能以及功能的需求</strong>。 尤其，面向未来的高性能网络，数据包查找和分类技术还需要进一步被研究和发展。通常情况下，判断一个路由查找算法或数据包分类算法的好坏，往往会从以下四个方面进行 评估。 1. <strong>查找（分类）速度</strong>。算法的性能是判断该算法最直接的评价指标之一。通常， 对于路由查找算法以及数据报分类算法都会使用<strong>每秒完成多少次查找（lps）</strong> 来定量评价算法的性能。在某些时候可以用每秒完成千次查找（Klps）和每 秒完成兆次查找（Mlps）来更合理地描述。 2. <strong>更新速度</strong>。除了查找（分类）性能之外，前缀（规则）更新的速度也是重要 的评价指标之一。尤其近年来，查找和分类算法的更新速度越来越受到重视， 因为当前及未来网络对路由器和分类器的更新性能需求非常高。一般地，对于前缀或规则更新的速度都会使用<strong>每秒完成多少次更新（ups）</strong>、每秒完成多少千次（Kups）或兆次（Mups）更新来定量评价。 3. <strong>内存需求</strong>。一般而言，<strong>对于任何算法它的运行内存占用必定越小越好</strong>。因为 <strong>内存越小就越有可能放入片上存储器，通过提高缓存的命中率来提高算法的性能</strong>。另一方面，对于一些存储非常有限的设备，如TCAM等，内存占用是 一个非常重要的指标。通常情况下，兆字节（MB）会用来评估一个算法运行 内存的大小。对于内存需求很大的算法，往往很难被实际部署。</p>
<h1 id="基于范围向量的高性能在线数据包分类算法">基于范围向量的高性能在线数据包分类算法</h1>
<h1 id="基于-gpu-加速的包分类算法研究与实现">2020基于 GPU 加速的包分类算法研究与实现</h1>
<p>华南理工大学 专业硕士学位答辩 电子与信息学院 王君君</p>
<p>虽然 SDN网络有诸多优点，能满足当前或者未来网络的的业务需求，但由于刚起步，整体技术还不完善，性能上存在诸多瓶颈，OpenFlow作为数据层面转 发数据包依据的主流协议，它打破了传统网络分层的概念，所有需要匹配的字段 都包括在一张流表里面，实现了协议的扁平化[2-3]。随着时间的推移，OpenFlow 协议的版本从最初的 1.0，逐渐发展到 1.1，1.2，1.3，1.4 等版本协议，从协议版 本的升级来看，流表里面用来匹配的字段数量不断增加，从最初 1.0 版本的 15 匹配字段，发展到如今高达 45 个匹配字段，其中有 15 个必检字段[4]。而传统五 元组包分类的算法已经无法满足OpenFlow协议字段匹配的需求，由此OpenFlow 协议的匹配成为了数据平面的一个主要的性能瓶颈。</p>
<p>包分类是一种在预定义规则集中匹配数据包从而根据规则定义的动作处理数据包的方法，其中输入包可以匹配一个或多个规则，我们选择具有最高优先级的规则定义的动作处理输入数据包[5]。</p>
<h1 id="introduction">Introduction</h1>
<h2 id="bytecuts-fast-packet-classification-by-interior-bit-extraction"><em>2018-ByteCuts: Fast Packet Classification by Interior Bit Extraction</em></h2>
<p>Packet classification is an important part of many network devices such as firewalls, routers, and other services. When these devices receive a packet, they must decide how to handle it. <strong>Most packet classifiers are defined by a list of rule.</strong> Each rule matches certain packet headers and defines an action for those packets. <strong>Possible actions include “forward onto physical port 1”, “send to the web server running on this device”, and “discard”.</strong> The classifier finds the first rule that matches a given packet and follows the action associated with that rule.</p>
<p>Rule list sizes have been increasing. As new vulnerabilities are found and new devices are added to the network, new rules are added to deal with these new situations. Rule lists with thousands of rules are now commonplace. Any packet classifier used must be able to handle these increasingly large rule lists.</p>
<p><strong>Packet classifiers must be fast. These network devices have real-time constraints</strong>; delays caused at one device propagate through the network as packet take longer to be forwarded between devices.</p>
<p>数据包分类是许多网络设备的一个重要部分，如防火墙、路由器和其他服务。当这些设备收到一个数据包时，它们必须决定如何处理它。大多数数据包分类器是由一个规则列表定义的。每个规则匹配某些数据包头，并为这些数据包定义一个动作。可能的行动包括 "转发到物理端口1"、"发送到在此设备上运行的网络服务器 "和 "丢弃"。分类器找到第一个匹配给定数据包的规则，并遵循与该规则相关的行动。 规则列表的大小一直在增加。随着新的漏洞被发现和新的设备被添加到网络中，新的规则也被添加进来以处理这些新情况。现在，拥有数千条规则的规则列表已经很常见了。任何使用的数据包分类器必须能够处理这些越来越大的规则列表。 数据包分类器必须是快速的。这些网络设备有实时限制；在一个设备上造成的延迟会通过网络传播，因为数据包在设备之间需要更长的时间来转发。</p>
<p>The packet classification problem is as follows. <strong>Given a rule list L and packet p, find the first (highest-priority) rule in L that matches packet p. This should be done as fast as possible.</strong></p>
<p>This yields the following objective. <strong>Given a rule list L, construct a classifier, subject to memory or other constraints, that minimizes the expected search time for incoming packets.</strong></p>
<p>数据包分类问题如下。给定一个规则列表L和数据包p，找到L中第一个（优先级最高的）与数据包p相匹配的规则，这应该尽可能快地完成。</p>
<p>这就产生了以下目标。给定一个规则列表L，在内存或其他约束条件下，构建一个分类器，使传入数据包的预期搜索时间最小。</p>
<p>Most existing decision trees, such as HyperCuts [1] and HyperSplit [2] have <strong>favored</strong> spending more memory for fast searches. These methods build a search tree by cutting the rules into several sets spacially. This yields O(log n) expected search times. <strong>However, the cuts are not clean</strong>; some rules are copied into multiple subtrees which produces super-linear memory.</p>
<p><strong>Later decision tree variants</strong>, such as EffiCuts [3] and SmartSplit [4] have introduced better tools for <strong>controlling memory usage at the cost of search times</strong>. These methods define several categories of rules which are expected not to require much rule replication, which reduces memory consumption, but it produces multiple trees, which increases search times.</p>
<p>Other methods, such as Tuple Space Search [5], TupleMerge [6], and PartitionSort [7] are able to use only linear memory.</p>
<p><strong>These methods partition the rules into other sets</strong> and then <strong>use either hashing (Tuple Space Search, TupleMerge) or sorting (PartitionSort) to be able to search them</strong>. Classification time is thus tied to the number of partitions required. If the number of partitions becomes large, then search times suffer.</p>
<p>These methods used in OpenFlow and other software-defined networks because they support fast updates.</p>
<p>大多数现有的决策树，如HyperCuts[1]和HyperSplit[2]都倾向于为快速搜索花费更多的内存。这些方法通过在空间上将规则切割成几组来建立搜索树。这产生了O（log n）的预期搜索时间。然而，切割并不干净；一些规则被复制到多个子树中，产生了超线性的内存。</p>
<p>后来的决策树变体，如EffiCuts[3]和SmartSplit[4]引入了更好的工具，以搜索时间为代价控制内存使用。这些方法定义了几类规则，预计不需要太多的规则复制，这就减少了内存的消耗，但是它产生了多个树，增加了搜索时间。</p>
<p>其他的方法，如Tuple Space Search[5]、TupleMerge[6]和PartitionSort[7]，能够只使用线性内存。</p>
<p><strong>这些方法将规则分割成其他的集合，然后使用散列（Tuple Space Search, TupleMerge）或排序（PartitionSort）来能够搜索它们</strong>。因此，<strong>分类时间与所需分区的数量有关</strong>。如果分区的数量变得很大，那么搜索时间就会受到影响。</p>
<p>这些方法在OpenFlow和其他软件定义的网络中使用，因为它们支持快速更新。</p>
<hr>
<p><strong>Rule replication is caused by rules falling into multiple partitions due to wildcards which forces them to be copied multiple times.</strong></p>
<p><strong>规则复制</strong>是由于通配符造成的规则落入多个分区，这迫使它们被多次复制。</p>
<p>Existing methods, such as EffiCuts [3] and SmartSplit [4] have attempted to <strong>alleviate this problem</strong> by <strong>partitioning rules</strong> such that <strong>all rules in the same partition have similar characteristics</strong>. This <strong>significantly</strong> reduces the amount of replication required as <strong>it is easier to find good cuts that do not trigger any of the wildcards.</strong></p>
<p>现有的方法，如EffiCuts[3]和SmartSplit[4]，试图通过对规则进行分区，使同一分区的所有规则具有类似的特征来缓解这一问题。这大大减少了所需的复制量，因为更容易找到不触发任何通配符的良好切割。</p>
<h2 id="fast-packet-classification-using-bloom-filters">2006-Fast Packet Classification Using Bloom Filters</h2>
<p>The general packet classification problem has received a great deal of attention over the last decade. The ability to classify packets into flows based on their packet headers is important for QoS, security, virtual private networks (VPN) and packet filtering applications. Conceptually, a packet classification system must compare each packet header received on a link against a large set of rules, and return the identity of the highest priority rule that matches the packet header (or in some cases, all matching rules). Each rule can match a large number of packet headers, since the rule specification supports address prefixes, wild cards and port number ranges. Much of the research to date has concentrated on the algorithmic techniques which use hardware or software lookup engines, which access data structures stored in commodity memory. However none of the algorithms developed to date has been able to displace TCAMs, in practical applications.</p>
<p>在过去的十年中，一般的数据包分类问题得到了大量的关注。根据数据包头将数据包分类为流量的能力对于QoS、安全、虚拟专用网络（VPN）和数据包过滤应用非常重要。<strong>从概念上讲，数据包分类系统必须将一条链路上收到的每个数据包头与一大批规则进行比较，并返回与数据包头相匹配的最高优先级规则的身份（或在某些情况下，所有匹配规则）。</strong>由于规则规范支持地址前缀、通配符和端口号范围，每个规则都可以匹配大量的数据包头。迄今为止，大部分研究都集中在使用硬件或软件查找引擎的算法技术上，该引擎访问存储在商品内存中的数据结构。然而，迄今为止开发的算法中没有一个能够在实际应用中取代TCAMs。</p>
<p>However, we can use Bloom filters to avoid lookups in subsets that contain no matching rules, making it possible to sustain high throughput.</p>
<p>然而，我们可以<strong>使用布鲁姆过滤器来避免在不包含匹配规则的子集中进行查找，从而使维持高吞吐量成为可能</strong>。</p>
<blockquote>
<p><strong>规则集分成子集，如何避免每一个子集查找是提升速度的关键，通过设立树的优先级、这篇文章提到了布鲁姆过滤器</strong></p>
</blockquote>
<p>In particular, we demonstrate a method, based on Bloom filters and hash tables, that can classify a packet in 4 + p + ? memory accesses where ? is a small constant ? 1 determined by the false positive proba- bility of the Bloom filters. The first four memory accesses are required to perform a Longest Prefix Matching (LPM) on the source/destination addresses and the source/destination ports.</p>
<p>特别是，我们展示了一种基于布隆过滤器和哈希表的方法，它可以在4+p+? 的内存访问中对一个数据包进行分类，其中? 是一个小常数? 1，由布隆过滤器的假阳性率决定。<strong>前四个内存访问需要对源/目的地址和源/目的端口进行最长前缀匹配（LPM）。</strong></p>
<p>The next p memory accesses are requires to lookup the p matching rules for a given packet. Furthermore, the LPM phase and the rule lookup phase can be pipelined with two independent memory chips such that the memory accesses per packet can be reduced to max{4, p}.</p>
<p><strong>接下来的p个内存访问需要为一个给定的数据包查找p个匹配规则。</strong>此外，LPM阶段和规则查询阶段可以用两个独立的内存芯片进行流水线处理，这样每个数据包的内存访问量可以减少到最大{4, p}。</p>
<h1 id="related-work">Related Work</h1>
<h2 id="bytecuts-fast-packet-classification-by-interior-bit-extraction-1"><em>2018-ByteCuts: Fast Packet Classification by Interior Bit Extraction</em></h2>
<p>Packet classification is a well studied problem. Taylor [8] divides packet classification algorithms into four general area: <strong>exhaustive search, decision trees, field decomposition, and tuple space.</strong> Our proposed ByteCuts classifier <strong>falls into</strong> the decision tree category.</p>
<p>数据包分类是一个研究得很好的问题。Taylor[8]将数据包分类算法分为四个大的领域：穷举搜索、决策树、场分解和元组空间。我们提出的ByteCuts分类器属于决策树的范畴。</p>
<p><strong>Summary and Limitations of Prior Art（现有技术的总结和限制）</strong></p>
<p>Decision trees are a well-studied area of packet classification. HiCuts [9] is one of the oldest and most well-known classifiers of this type and has spawned several derivatives. In HiCuts, one field of the packet domain is partitioned (or cut) into several equal-sized pieces. The rules are then allocated to the partitions that they correspond to. This process is repeated for each of these sublists until only a few rules remain. One problem with HiCuts is that the rule and domain boundaries do not always align and rules that cross these boundaries must be replicated into multiple partitions. Rules that are orthogonal to the field being cut are especially problematic since they must be replicated into each partition. This can result in a significant memory blowup.</p>
<p>决策树是数据包分类的一个被充分研究的领域。HiCuts[9]是这种类型的最古老和最著名的分类器之一，并且已经产生了几个衍生产品。在HiCuts中，数据包领域的一个领域被分割（或切割）成几个大小相等的部分。然后，规则被分配到它们所对应的分区中。这个过程对每个子列表重复进行，直到只剩下几条规则。HiCuts的一个问题是，规则和领域的边界并不总是一致的，跨越这些边界的规则必须被复制到多个分区。与被切割领域正交的规则尤其成问题，因为它们必须被复制到每个分区。这可能会导致显著的内存爆炸。</p>
<p>HyperCuts [1] is a variant on HiCuts. Its chief improvement is that it allows cutting on multiple fields at once. This allows the overall tree height to be lower resulting in faster classification times, but it suffers from the same rule replication problem as HiCuts does. The tree that HyperCuts produces for Classifier I can be seen in Figure 2.</p>
<p>HyperCuts[1]是HiCuts的一个变种。它的主要改进之处在于，它允许一次对多个字段进行切割。这使得整个树的高度降低，从而加快了分类的速度，但是它和HiCuts一样存在着规则复制的问题。图2中可以看到HyperCuts为分类器I生成的树。</p>
<p>HyperSplit [2] takes a slightly different approach. Instead of creating many equal-sized cuts, HyperSplit creates a single cut (or split) of variable size. This split is chosen to balance the number of rules in the two resulting partitions. Compared to HiCuts and HyperCuts, this results in less replication and lower memory requirements since each rule is copied into at most two partitions. However, the tree height is normally higher since it has a smaller branching factor. The tree that HyperSplit produces for Classifier I can be seen in Figure 3.</p>
<p>Each of these algorithms has memory problems caused by significant rule replication. ByteCuts prevents this rule replication by separating incompatible rules into different trees.</p>
<p>HyperSplit[2]采取了一种略有不同的方法。HyperSplit不是创建许多大小相等的切割，而是创建一个大小可变的单一切割（或分割）。选择这种分割是为了平衡所产生的两个分区中的规则数量。与HiCuts和HyperCuts相比，这导致了较少的复制和较低的内存需求，因为每个规则最多复制到两个分区中。然而，树的高度通常较高，因为它有一个较小的分支因子。HyperSplit为分类器I产生的树可以在图3中看到。</p>
<p>这些算法中的每一种都有因大量规则复制而引起的内存问题。ByteCuts通过将不兼容的规则分离到不同的树中来防止这种规则的复制。</p>
<p>EffiCuts [3] attempts to solve the rule replication problem by dividing the rules into multiple HyperCuts trees. It classifies rules as being either long or short on a particular field (similar to a tuple space method) and all rules with the same classification are placed into the same tree. Since all of the rules in a given tree have similar properties, it is expected that there will not be much replication required. The downside is that searching multiple trees is likely to take longer than searching a single tree.</p>
<p>SmartSplit [4] tries a similar strategy to EffiCuts except it only considers two fields: source and destination address. This results in fewer trees and thus generally faster search times <strong>at the expense of greater rule replication (though generally less than HyperCuts)</strong>. Additionally, they can estimate the memory usage and tree heights of a rule list to determine whether one or multiple trees would be better as well as if they should use HyperCuts or HyperSplit trees. This allows them to better balance the tradeoffs between speed and memory. This can be seen by comparing the trees in Figure 4 to those in Figures 2 and 3.</p>
<p>SmartSplit has a small, fixed set of trees available and EffiCuts has a limited ability to merge the rule lists for its larger, otherwise fixed set of trees. <strong>In contrast, ByteCuts has a larger, more flexible, set to choose from. This allows it to better fit the rules to trees which leads to less replication and faster searches.</strong></p>
<p>EffiCuts[3]试图通过将规则分为多个HyperCuts树来解决规则复制的问题。它将规则分类为特定领域的长或短（类似于元组空间方法），所有具有相同分类的规则都被放入同一棵树中。由于一个给定的树中的所有规则都有类似的属性，预计不会有太多的复制要求。缺点是搜索多棵树的时间可能比搜索一棵树要长。</p>
<p><strong>SmartSplit[4]尝试了一种与EffiCuts类似的策略，只是它只考虑两个字段：源地址和目的地址。</strong>这导致了更少的树，因此通常更快的搜索时间，代价是更大的规则复制（尽管通常比HyperCuts少）。<strong>此外，他们可以估计内存使用量和规则列表的树高，以确定一个或多个树会更好，以及他们是否应该使用HyperCuts或HyperSplit树。</strong>这使他们能够更好地平衡速度和内存之间的权衡。通过比较图4中的树和图2和图3中的树，可以看出这一点。</p>
<p>SmartSplit有一个小的、固定的树集可用，EffiCuts有一个有限的能力来合并其较大的、其他固定的树集的规则列表。相比之下，ByteCuts有一个更大、更灵活的集合可供选择。这使得它能够更好地将规则与树相匹配，从而减少复制和加快搜索。</p>
<p>PartitionSort [7] bases its trees on the rules themselves rather than the decision space. It defines several partial orderings on the rule list and then partitions the list so that each partition is totally ordered on one of these orderings, which can be binary searched. This allows them to completely do away with rule replication (each rule appears only once). PartitionSort’s tree selection strategy is more stringent than ByteCuts, so it requires more trees resulting in slower classification.</p>
<p>PartitionSort[7]将其树建立在规则本身而不是决策空间上。它在规则列表上定义了几个部分排序，然后对列表进行分区，这样每个分区都是在这些排序中的一个上完全排序，这可以进行二进制搜索。<strong>这使他们能够完全摒弃规则复制（每条规则只出现一次）</strong>。PartitionSort的树选择策略比ByteCuts更严格，<strong>所以它需要更多的树，导致分类更慢。</strong></p>
<p>With exact match, all of the rules in the list are searched.</p>
<p>This normally is done in hardware with TCAMs, which can search the entire list in parallel. Unfortunately, TCAMs do not scale very well. Thus methods such as Firewall Compressor [10], TCAM Razor [11], or Diplomat [12] are used to compress the rule list into a smaller list with identical behavior.</p>
<p>One-dimensional packet classification is a much easier problem; linear-memory solutions with O(log n) search times exist. Field decomposition methods like [13] and [14] classify each field (often in parallel) to acquire some sort of token or partial result. They then use the tokens to determine the matching rule.</p>
<p>In tuple space classifiers, such as Tuple Space Search [5] and TupleMerge [6], each rule is tagged with a tuple denoting which bits it uses. Rules with the same tuple are grouped together into a hash table. By extracting only the bits associated with that tuple, a consistent hash key can be produced from either rules or packets, allowing each table to be searched in constant time.</p>
<p>在精确匹配的情况下，列表中的所有规则都被搜索到。</p>
<p>这通常是在硬件上用TCAM完成的，它可以并行地搜索整个列表。不幸的是，TCAM的规模不是很好。因此，诸如Firewall Compressor[10]、TCAM Razor[11]或Diplomat[12]等方法被用来将规则列表压缩成一个具有相同行为的较小列表。</p>
<p>一维数据包分类是一个更容易的问题；存在搜索时间为O（log n）的线性内存解决方案。像[13]和[14]这样的字段分解方法对每个字段进行分类（通常是并行的）以获得某种标记或部分结果。然后，他们使用令牌来确定匹配规则。</p>
<p>在元组空间分类器中，如元组空间搜索[5]和元组合并[6]，每个规则都被标记为元组，表示它使用了哪些位。具有相同元组的规则被归入一个哈希表。通过只提取与该元组相关的比特，可以从规则或数据包中产生一个一致的哈希密钥，允许在恒定时间内搜索每个表。</p>
<h2 id="fast-packet-classification-using-bloom-filters-1">2006-Fast Packet Classification Using Bloom Filters</h2>
<p>There is a vast body of literature on packet classification.</p>
<p>An excellent survey and taxonomy of the existing algorithms and architectures can be found in [11]. Here, we discuss only the algorithms that are closely related to our work. Algorithms that can provide deterministic lookup throughput is somewhat akin to the basic crossproduct algorithm [9].</p>
<p>The basic idea of the crossproduct algorithm is to perform a lookup on each field first and then combine the results to form a key to index a crossproduct table. The best-matched rule can be retrieved from the crossproduct table in only one memory access. The single field lookup can be performed by direct table lookup as in the RFC algorithm [5] or by using any range searching or LPM algorithms. The BV [6] and ABV [3] algorithms use bit vector intersections to replace the crossproduct table lookup. However, the width of a bit vector equals to the number of rules and each unique value on each field needs to store such a bit vector. Hence, the storage requirement is significant, which limits its scalability.</p>
<p>关于数据包分类有大量的文献。</p>
<p>现有算法和架构的优秀调查和分类法可以在[11]中找到。在这里，我们只讨论与我们工作密切相关的算法。能够提供确定性查找吞吐量的算法有点类似于基本的交叉产品算法[9]。</p>
<p>交叉产品算法的基本思想是先对每个字段进行查找，然后结合结果形成一个键来索引交叉产品表。只需一次内存访问就可以从交叉产品表中检索出最佳匹配的规则。单一字段的查找可以通过RFC算法[5]中的直接查表或使用任何范围搜索或LPM算法来进行。BV[6]和ABV[3]算法使用位向量交集来代替交叉产品表的查找。然而，<strong>位向量的宽度等于规则的数量，每个字段上的每个唯一值都需要存储这样一个位向量。因此，存储需求很大</strong>，这限制了它的可扩展性。</p>
<p>For example, at the first level, if a packet matches m nested source IP address prefixes and n nested destination IP address prefixes, we need m × n hash queries to the hash table with the keys that combine these two fields and the lookups typically result in multiple valid outputs that require further lookups. For a multi-dimensional packet classification, this incurs a large performance penalty.</p>
<p>例如，在第一层，如果一个数据包匹配了m个嵌套的源IP地址前缀和n个嵌套的目的IP地址前缀，<strong>我们需要用结合这两个字段的键对哈希表进行m×n个哈希查询，而且查询通常会产生多个有效输出，需要进一步查询。对于一个多维的数据包分类来说，这产生了一个很大的性能损失。</strong></p>
<p>DIRPE [7], uses a clever technique to encode ranges differently which results in overall lesser rule expansion compared to the traditional method.</p>
<p><strong>DIRPE[7]，使用了一种巧妙的技术对范围进行不同的编码，与传统方法相比，其结果是整体上较少的规则扩展。</strong></p>
<p>Yu et. al. described a different algorithm for multimatch packet classification based on geometric intersection of rules [13]. A packet can match multiple rules because the rules overlap. However, if the rules are broken into smaller sub-rules such that all the rules are mutually exclusive then the packet can match only one rule at a time</p>
<p>Yu等人描述了一种不同的算法，用于基于规则的几何交叉的多匹配包分类[13]。<strong>一个数据包可以匹配多个规则，因为这些规则是重叠的。然而，如果规则被分解成更小的子规则，使所有规则相互排斥，那么数据包一次只能匹配一条规则</strong></p>
<p>This overlap-free rule set is obtained through geometric intersection. Unfortunately, the rule set expansion due to the newly introduced rules by the intersection can be very large.</p>
<p>这个无重叠的规则集是通过几何交叉得到的。不幸的是，由于相交所引入的新规则，规则集的扩展可能非常大。</p>
<p>At the same time one would need to probe each subset independently to search a matching rule. Our algorithm is similar to SSA in that we also try to reduce the overlap between the rules by partitioning them into multiple subsets and thus reduce the overall expansion.</p>
<p>同时，人们需要独立地探测每一个子集来搜索一个匹配的规则。我们的算法与SSA类似，我们也试图通过将规则划分为多个子集来减少规则之间的重叠，从而减少整体的扩展。</p>
<p>However, while SSA only cares about an overlap in all the dimensions, our algorithm considers the overlap in any dimension for the purpose of partitioning. Hence the partitioning technique are different.</p>
<p>Moreover, SSA is a TCAM based algorithm whereas ours is memory based. Finally, SSA requires to probe all the subsets formed, one by one, requiring as many TCAM accesses whereas our algorithm needs only p memory accesses, just as many matching rules as there are per packet.</p>
<p>然而，SSA只关心所有维度上的重叠，而我们的算法为了分区的目的考虑任何维度上的重叠。因此，分区技术是不同的。</p>
<p>此外，SSA是一个基于TCAM的算法，而我们的算法是基于内存的。最后，SSA需要逐一探测所有形成的子集，需要同样多的TCAM访问，而我们的算法只需要p个内存访问，就像每个数据包有多少个匹配规则一样。</p>
<p>For 5-tuple classification, we don’t need to perform the LPM for the protocol field; it can be a direct lookup in a small on-chip table</p>
<p>对于5元组分类，我们不需要对协议字段进行LPM，它可以直接在一个小型片上表中进行查找</p>
<blockquote>
<p>前人只关注源IP、目的IP，却没有说源port和目的port怎么查找，源port和目的port是范围</p>
</blockquote>
]]></content>
      <categories>
        <category>论文</category>
      </categories>
  </entry>
  <entry>
    <title>健康作息</title>
    <url>/2022/10/24/%E9%9A%8F%E7%AC%94%E4%B8%8E%E4%B8%AA%E4%BA%BA%E6%96%87%E9%9B%86/00%E5%81%A5%E5%BA%B7%E4%BD%9C%E6%81%AF/</url>
    <content><![CDATA[<h2 id="饮食">饮食</h2>
<ol type="1">
<li>少油少甜</li>
<li>不吃辣</li>
<li>晚上8点后不吃东西</li>
</ol>
<blockquote>
<p>饮食是一个大问题，三分练七分吃。乱吃东西</p>
</blockquote>
<p><strong>1. 高糖高脂食物</strong></p>
<ul>
<li><strong>高糖食物</strong>：以糖果、蛋糕、奶油等食物为代表，一些过甜的干果，如蜜饯、桂圆干等也需要控制摄入量，我们总以为两广当地年轻人好长痤疮是因为气候炎热，但也可能是因为当地夏日漫长，大家喜欢吃冰镇糖水解暑；</li>
<li><strong>高脂食物</strong>：不仅仅是五花肉，核桃、芝麻、花生、油炸食品。油条、炸花生等素食的油脂含量也十分可观；</li>
<li><strong>其他</strong>：一些不起眼的西点，比如曲奇、黄油吐司等，如果你亲自做过，就会很直观地体会到里面的热量有多高，简直再也不想吃</li>
</ul>
<p>2. <strong>远离辛辣食物</strong>：麻辣烫、火锅、辣椒、桂皮、胡椒等。 <strong>因为辛辣温热，引起暗疮复发增长。</strong></p>
<p>3. <strong>远离油腻食物</strong>：油条、炸鸡、薯条、鸡排、肥肉等。</p>
<ol start="4" type="1">
<li>远离上火水果**：荔枝、芒果、龙眼、大枣、榴莲等。</li>
</ol>
<p><strong>这些水果温热容易上火长痘最好不要吃。</strong></p>
<ul>
<li>皮脂溢出者要<strong>适当增加清水洗脸的次数</strong>，但建议每天不超过 3 次，并且不要大力揉搓；</li>
<li>洗完后及时做好<strong>保湿</strong>工作；</li>
<li>少化浓妆，选择<strong>质地清透稀薄的护肤品</strong>；</li>
<li>注意<strong>防晒</strong>，<strong>规律作息</strong>；</li>
<li>最重要的一点：<strong>不要用手挤压、挠抓痘痘</strong>！</li>
</ul>
<p>痤疮是一个慢性皮肤病，生活护理也非一日之功，需要养成习惯，才能长时间保持皮肤的光滑平整</p>
<h2 id="工作">工作</h2>
<ol type="1">
<li>避免长时间（1小时）看电脑，每1小时，户外5分钟</li>
<li>坐姿端正，避免脖子前倾和弯腰驼背</li>
<li>避免低头、久坐</li>
</ol>
<h2 id="运动">运动</h2>
<ol type="1">
<li>每天<strong>户外运动</strong>大于1小时</li>
</ol>
]]></content>
      <categories>
        <category>随笔与个人文集</category>
      </categories>
      <tags>
        <tag>生活</tag>
      </tags>
  </entry>
  <entry>
    <title>每天锻炼</title>
    <url>/2022/10/24/%E9%9A%8F%E7%AC%94%E4%B8%8E%E4%B8%AA%E4%BA%BA%E6%96%87%E9%9B%86/00%E8%BF%90%E5%8A%A8%E5%BD%A2%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="section"></h1>
<h2 id="运动形式">运动形式</h2>
<h3 id="跑步">跑步</h3>
<h3 id="跳绳">跳绳</h3>
<h3 id="体能类">体能类</h3>
<ol type="1">
<li>背部和肩部肌肉
<ul>
<li><a href="https://www.bilibili.com/video/BV1CL411x7gV/?spm_id_from=333.788.recommend_more_video.0&amp;vd_source=83831fc0970a6c8704479f7cfc679937">练出更宽的肩膀和背部，不再瘦弱（一对哑铃在家练）_哔哩哔哩_bilibili</a></li>
<li></li>
</ul></li>
<li>胸部肌肉
<ul>
<li><a href="https://www.bilibili.com/video/BV1rY411H7V2/?spm_id_from=333.788.recommend_more_video.5&amp;vd_source=83831fc0970a6c8704479f7cfc679937">练出有型胸肌，不再单薄（一对哑铃在家练）_哔哩哔哩_bilibili</a></li>
</ul></li>
<li>手臂/腿部肌肉
<ol type="1">
<li>（负重）深蹲</li>
</ol></li>
<li>手臂肌肉
<ul>
<li>直立哑铃交替</li>
</ul></li>
</ol>
<p>🔵 <strong>链接：</strong></p>
<ol type="1">
<li><a href="https://www.jirou.com/html/yalingdaquan.html">哑铃健身图解大全（适合在家锻炼</a></li>
<li></li>
</ol>
<h2 id="运动频率">运动频率</h2>
<p><img src="https://cdn.staticaly.com/gh/peirsist/blog_img@master/Snipaste_2022-10-24_17-35-40.66yls7r574w0.webp" style="zoom:150%;"></p>
<p>markdown流程图代码 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">graph TB</span><br><span class="line">    Start(新的一天) --&gt; badminton&#123;&quot;打羽毛球？&quot;&#125;</span><br><span class="line">    </span><br><span class="line">    badminton --&gt;|是| dumbbell[&quot;力量训练&quot;]</span><br><span class="line">     </span><br><span class="line">    badminton --&gt;|否| running[&quot;耐力、爆发力训练&quot;]</span><br><span class="line">    running --&gt; dumbbell</span><br><span class="line">    </span><br><span class="line">    dumbbell --&gt; End(洗洗睡觉)</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>随笔与个人文集</category>
      </categories>
      <tags>
        <tag>生活</tag>
      </tags>
  </entry>
  <entry>
    <title>LaTex</title>
    <url>/2022/10/21/%E8%BD%AF%E4%BB%B6%E4%BD%BF%E7%94%A8/LaTex/</url>
    <content><![CDATA[<h1 id="超链接"><a href="#超链接" class="headerlink" title="超链接"></a>超链接</h1><ol>
<li><a href="https://blog.csdn.net/weixin_34405332/article/details/85531610">latex 引用 section [转]_weixin_34405332 的博客-CSDN 博客</a></li>
<li></li>
</ol>
<h1 id="beamer"><a href="#beamer" class="headerlink" title="beamer"></a>beamer</h1><ol>
<li><a href="https://zhuanlan.zhihu.com/p/137877025">beamer模板设计（八）beamer中颜色的设置和继承关系 - 知乎 (zhihu.com)</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/136898462">beamer模板设计（五）headline中的色彩和字体 - 知乎 (zhihu.com)</a></li>
<li></li>
</ol>
<p>2022&#x2F;11&#x2F;17</p>
<ol>
<li><a href="https://zhuanlan.zhihu.com/p/472540719">LaTeX 笔记模板整理 - 知乎 (zhihu.com)</a></li>
<li><a href="https://blog.csdn.net/weixin_39278265/article/details/125257636">【已解决】【LaTeX】acmart模板中使用xcolor出错：Option clash for package xcolor._宇内虹游的博客-CSDN博客</a></li>
<li><a href="https://blog.sciencenet.cn/blog-465809-1040538.html">科学网—LaTeX Error: Not in outer par mode. - 朱小栋的博文 (sciencenet.cn)</a></li>
<li></li>
</ol>
<ul>
<li><a href="https://blog.csdn.net/qq_43391414/article/details/115129492">latex中\begin{verbatim}以及\verb有什么用？_音程的博客-CSDN博客</a></li>
<li><a href="https://blog.csdn.net/hysterisis/article/details/114123131">Latex 中的空格汇总_hysterisis的博客-CSDN博客</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/104112163#:~:text=">LaTeX省略号 - 知乎 (zhihu.com)</a>在LaTeX中，分别使用“\ldots”，“\cdots”，“\vdots”，“\ddots”实现各种省略号. 可以看出“\ldots”实现了居底部的省略号，“\cdots”实现了居中的省略号.,而命令“\dots”可以根据实际情况自动地改变省略号的位置. 在写作的过程中，要根据自己的实际情况灵活地使用这些省略号（感谢评论指出）.)</li>
<li><a href="https://blog.csdn.net/zhangpeterx/article/details/86032665">Latex报错Missing $ inserted.inserted text_个人博客-CSDN博客</a></li>
<li><a href="https://blog.csdn.net/m0_37149062/article/details/108240050">Latex输入特殊字符#$%&amp;{}_^-＜＞|_执念斩长河-CSDN博客_latex怎么打&amp;</a></li>
<li><a href="https://blog.csdn.net/sclxf/article/details/5387630">Latex中输入数学中的“属于” 符号_sclxf的专栏-CSDN博客_latex属于符号怎么打</a></li>
<li>[「LaTeX」LaTeX 中三种向量表示：粗体1，粗体2，箭头向量 - 哔哩哔哩 (bilibili.com)](<a href="https://www.bilibili.com/read/cv3599113/#:~:text=%E3%80%8CLaTeX%E3%80%8DLaTeX">https://www.bilibili.com/read/cv3599113/#:~:text=「LaTeX」LaTeX</a> 中三种向量表示：粗体1，粗体2，箭头向量 学习 2019-09-14 20%3A45,–阅读 · –喜欢 · –评论)</li>
<li><a href="https://zhuanlan.zhihu.com/p/338377565">LaTeX宏包学习笔记之tcolorbox - 知乎 (zhihu.com)</a></li>
<li><a href="https://blog.csdn.net/golden1314521/article/details/42871065">Latex彩色框_金良山庄-CSDN博客_latex彩色盒子模板</a></li>
<li>Latex下划线<a href="https://blog.csdn.net/hongnuaa/article/details/6901658?spm=1001.2101.3001.6661.1&utm_medium=distribute.pc_relevant_t0.none-task-blog-2~default~CTRLIST~Rate-1.pc_relevant_default&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2~default~CTRLIST~Rate-1.pc_relevant_default&utm_relevant_index=1">方法1</a> <a href="https://blog.csdn.net/qq_41684259/article/details/108066854?spm=1001.2101.3001.6650.1&utm_medium=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-1.pc_relevant_default&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-1.pc_relevant_default&utm_relevant_index=2">方法2</a> <a href="https://blog.csdn.net/weixin_44471218/article/details/119031672#:~:text=">方法3</a>默认情况下， latex 会将 下划线 “_” 解释为数学模式,中 的下标表示的一部分，这种处理很多情况下是非常不爽的，比如代码 中 的 下划线 变量：host_name之类的。)</li>
<li><a href="https://blog.csdn.net/u011089523/article/details/83578005?spm=1001.2101.3001.6661.1&utm_medium=distribute.pc_relevant_t0.none-task-blog-2~default~CTRLIST~Rate-1.pc_relevant_antiscanv2&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2~default~CTRLIST~Rate-1.pc_relevant_antiscanv2&utm_relevant_index=1">LATEX调整公式、图片与正文间距离，文字间距离，调整空白大小_风景不在对岸wj的博客-CSDN博客_latex调整图片与文字的距离</a></li>
<li><a href="https://blog.csdn.net/weixin_34054866/article/details/86250933">LaTeX 在编译时出现 File ended while scanning use of @writefile错误_weixin_34054866的博客-CSDN博客</a></li>
<li><a href="https://blog.csdn.net/fandroid/article/details/50930137">latex: 改变图的caption Figure 1:为 Fig. 1.</a></li>
<li><mark>抄录一些行内的代码时，可以用\texttt{}命令</mark>&gt; <a href="https://blog.csdn.net/weixin_30848775/article/details/98274223">Tex中如何使得 texttt 的英文自动断字</a></li>
<li><a href="https://zhidao.baidu.com/question/1964965103546603140.html">使用latex book类的每章首页的页眉怎么设置？_百度知道 (baidu.com)</a></li>
<li><a href="https://blog.csdn.net/robert_chen1988/article/details/52739825">latex 中的长度单位，尺寸</a></li>
<li><a href="https://blog.csdn.net/weixin_41672404/article/details/112982523?spm=1001.2101.3001.6650.1&utm_medium=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-1.pc_relevant_antiscanv2&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-1.pc_relevant_antiscanv2">latex消除每章节之间空白页</a></li>
<li><a href="https://blog.csdn.net/nccccc12345/article/details/115335255">LATEX–页边距设置</a></li>
<li><a href="https://blog.csdn.net/Stool_Monster/article/details/107610030">texstudio &#x2F; sublime text 3 - latextools使用minted包遇到的一些问题的解决办法</a></li>
<li><a href="https://blog.csdn.net/gogdizzy/article/details/9136239">Winedt编译minted宏包问题</a></li>
<li><a href="https://lttt.vanabel.cn/2015/03/27/winedt%e5%bc%80%e5%90%afwrite18%e5%92%8cshell-escape.html">WinEdt开启write18和shell-escape</a></li>
<li><a href="https://blog.csdn.net/chichoxian/article/details/19134695#:~:text=%E5%9C%A8Latex%E4%B8%ADs,%EF%BC%88%E4%B8%80%E8%88%AC%E6%98%AF%E7%BA%A2%E8%89%B2%EF%BC%89%E3%80%82">用Beamer制作幻灯片（卷三 动画篇）_君的名字的博客-CSDN博客_beamer 动画</a></li>
<li><a href="https://www.1024sou.com/article/940683.html">LaTeX多种颜色标注高亮修改内容 - 1024搜-程序员专属的搜索引擎 (1024sou.com)</a></li>
<li><strong><a href="https://www.cnblogs.com/ywang-wnlo/p/LaTeX-Beamer.html">【LaTeX】制作 PPT （更新中） - ywang_wnlo - 博客园 (cnblogs.com)</a></strong></li>
<li><a href="https://alexander-qi.github.io/2019/teachbeamer/">从零开始用beamer做学术报告幻灯片 | 墘青 (alexander-qi.github.io)</a></li>
<li><a href="https://www.zhihu.com/question/482758306">Sublime Text4编译完LaTex后又自动弹出一个窗口什么情况？ - 知乎 (zhihu.com)</a></li>
<li><a href="https://www.bilibili.com/video/BV18u411e7mg/">Sublime Text+LaTeX每次编译时都会新建窗口的问题解决_哔哩哔哩_bilibili</a></li>
<li><a href="https://www.latexstudio.net/archives/2464.html">LaTeX技巧788：beamer中的图表编号问题 - LaTeX科技排版工作室 (latexstudio.net)</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/389828721">Beamer入门 - 知乎 (zhihu.com)</a></li>
<li><a href="https://blog.csdn.net/m0_38006970/article/details/95102613">Sublime text 3 + Latex + SumatraPDF反向检索_ta酱mua的博客-CSDN博客</a></li>
<li><a href="https://www.zhihu.com/question/357511411">请问latex的beamer怎么将页面4:3设置为16:9? - 知乎 (zhihu.com)</a></li>
<li><a href="https://www.cnblogs.com/nangongergou/p/13606758.html">Beamer制作演示文档-1：在每个章节前面显示目录 - 南宫二狗 - 博客园 (cnblogs.com)</a></li>
<li><a href="https://blog.csdn.net/G_Barble/article/details/106184870">Latex error: No line here to end （已解决）__52Hz_的博客-CSDN博客</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/137877025">beamer模板设计（八）beamer中颜色的设置和继承关系 - 知乎 (zhihu.com)</a></li>
<li><a href="https://blog.csdn.net/qq_20260069/article/details/88380579">假装认真的LaTeX学习笔记（2）—— LaTeX中如何修改字体（fontspec宏包使用方法）_羊坨不是羊驼的博客-CSDN博客_fontspec</a></li>
<li></li>
</ul>
<h3 id="常用的代码片段"><a href="#常用的代码片段" class="headerlink" title="常用的代码片段"></a>常用的代码片段</h3><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\begin</span>&#123;enumerate&#125;[i)]</span><br><span class="line">	<span class="keyword">\item</span>...</span><br><span class="line">	<span class="keyword">\item</span>...</span><br><span class="line"><span class="keyword">\end</span>&#123;enumerate&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\url</span>&#123;<span class="link">https://github.com/davidgao666/HedaBachelorTemplate</span>&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\begin</span>&#123;description&#125;</span><br><span class="line">  <span class="keyword">\item</span>[Step 1] ... </span><br><span class="line">  <span class="keyword">\item</span>[Step 2] ...</span><br><span class="line">  <span class="keyword">\item</span>[Step 3] ...</span><br><span class="line"><span class="keyword">\end</span>&#123;description&#125;</span><br></pre></td></tr></table></figure>



<h3 id="插入公式"><a href="#插入公式" class="headerlink" title="插入公式"></a>插入公式</h3><h4 id="插入多行公式时，空格问题"><a href="#插入多行公式时，空格问题" class="headerlink" title="插入多行公式时，空格问题"></a>插入多行公式时，空格问题</h4><p>第一个正确，第二个不对，因此在 <strong>插入公式时，就不要有空格</strong> ，避免不必要的麻烦。</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\begin</span>&#123;equation&#125;</span><br><span class="line"><span class="keyword">\left</span><span class="keyword">\&#123;</span> <span class="keyword">\begin</span>&#123;array&#125;&#123;l&#125;</span><br><span class="line">	r<span class="built_in">_</span>k=<span class="keyword">\sum</span><span class="built_in">_</span>&#123;j=1&#125;<span class="built_in">^</span>p&#123;w<span class="built_in">_</span>&#123;kj&#125;x<span class="built_in">_</span>j<span class="keyword">\text</span>&#123;,&#125;&#125;<span class="keyword">\\</span></span><br><span class="line">	v<span class="built_in">_</span>k=r<span class="built_in">_</span>k-<span class="keyword">\theta</span> <span class="built_in">_</span>k,<span class="keyword">\\</span></span><br><span class="line">	y<span class="built_in">_</span>k=<span class="keyword">\varPhi</span> <span class="keyword">\left</span>( v<span class="built_in">_</span>k <span class="keyword">\right</span>),<span class="keyword">\\</span></span><br><span class="line"><span class="keyword">\end</span>&#123;array&#125; <span class="keyword">\right</span>.	</span><br><span class="line"><span class="keyword">\end</span>&#123;equation&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\begin</span>&#123;equation&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">\left</span><span class="keyword">\&#123;</span> <span class="keyword">\begin</span>&#123;array&#125;&#123;l&#125;</span><br><span class="line">	r<span class="built_in">_</span>k=<span class="keyword">\sum</span><span class="built_in">_</span>&#123;j=1&#125;<span class="built_in">^</span>p&#123;w<span class="built_in">_</span>&#123;kj&#125;x<span class="built_in">_</span>j<span class="keyword">\text</span>&#123;,&#125;&#125;<span class="keyword">\\</span></span><br><span class="line">	v<span class="built_in">_</span>k=r<span class="built_in">_</span>k-<span class="keyword">\theta</span> <span class="built_in">_</span>k,<span class="keyword">\\</span></span><br><span class="line">	y<span class="built_in">_</span>k=<span class="keyword">\varPhi</span> <span class="keyword">\left</span>( v<span class="built_in">_</span>k <span class="keyword">\right</span>),<span class="keyword">\\</span></span><br><span class="line"><span class="keyword">\end</span>&#123;array&#125; <span class="keyword">\right</span>.</span><br><span class="line"></span><br><span class="line"><span class="keyword">\end</span>&#123;equation</span><br></pre></td></tr></table></figure>

<h4 id="页眉"><a href="#页眉" class="headerlink" title="页眉"></a>页眉</h4><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line">只给每一章首页加页眉</span><br><span class="line"></span><br><span class="line"><span class="keyword">\makeatletter</span></span><br><span class="line">  <span class="keyword">\let</span><span class="keyword">\ps@plain</span><span class="keyword">\ps@empty</span></span><br><span class="line"><span class="keyword">\makeatother</span></span><br><span class="line"><span class="keyword">\fancypagestyle</span>&#123;plain&#125;&#123;<span class="comment">%</span></span><br><span class="line">    <span class="keyword">\fancyhf</span>&#123;&#125; <span class="comment">%</span></span><br><span class="line">    <span class="keyword">\fancyhead</span>[LO,RE]&#123;...&#125; <span class="comment">%</span></span><br><span class="line">    <span class="keyword">\fancyhead</span>[RO,LE]&#123;...&#125; <span class="comment">%</span></span><br><span class="line">    <span class="keyword">\fancyfoot</span>[C]&#123;...&#125; <span class="comment">%</span></span><br><span class="line">    <span class="keyword">\renewcommand</span>&#123;<span class="keyword">\headrulewidth</span>&#125;&#123;0.4pt&#125;  <span class="comment">%</span></span><br><span class="line">    <span class="keyword">\renewcommand</span>&#123;<span class="keyword">\footrulewidth</span>&#125;&#123;0.4pt&#125;  <span class="comment">%</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>软件使用</category>
      </categories>
      <tags>
        <tag>LaTex</tag>
      </tags>
  </entry>
  <entry>
    <title>Office的使用</title>
    <url>/2022/10/21/%E8%BD%AF%E4%BB%B6%E4%BD%BF%E7%94%A8/Office/</url>
    <content><![CDATA[<h2 id="一word"><strong>一、Word</strong></h2>
<p><code>2022</code>年<code>5</code>月<code>13</code>日于家中</p>
<p>写专业的论文用latex比较方便，但是latex很不直观，平时就用latex写，效率其实很低，建议平时积累用word，排版用Latex</p>
<ul>
<li><a href="https://www.bilibili.com/video/BV1SZ4y1p7hB?p=1">【Word丨毕业论文格式教程】简直是写论文必备~_哔哩哔哩_bilibili</a></li>
<li></li>
</ul>
<h2 id="二excel"><strong>二、Excel</strong></h2>
<p>之前看过以下这个教程，还需要复习以下</p>
<ul>
<li><a href="https://www.bilibili.com/video/BV1ix41137b7?spm_id_from=333.337.search-card.all.click">【公开课】Excel基础大全（1-66集）【超高清版】_哔哩哔哩_bilibili</a></li>
</ul>
]]></content>
      <categories>
        <category>软件使用</category>
      </categories>
      <tags>
        <tag>Office</tag>
      </tags>
  </entry>
  <entry>
    <title>Markdown表情</title>
    <url>/2022/10/27/%E9%9A%8F%E7%AC%94%E4%B8%8E%E4%B8%AA%E4%BA%BA%E6%96%87%E9%9B%86/markdown%E8%A1%A8%E6%83%85/</url>
    <content><![CDATA[<ol type="1">
<li><a href="https://www.emojiall.com/zh-hans/categories/I">分类:🛑符号相关的Emoji大全 | EmojiAll</a></li>
<li><a href="https://apps.timwhitlock.info/emoji/tables/unicode#">Emoji unicode characters for use on the web (timwhitlock.info)</a></li>
<li><a href="https://www.unicode.org/emoji/charts/full-emoji-list.html">Full Emoji List, v15.0 (unicode.org)</a></li>
<li></li>
</ol>
]]></content>
      <categories>
        <category>随笔与个人文集</category>
      </categories>
  </entry>
  <entry>
    <title>人世间句子摘抄</title>
    <url>/2022/03/21/%E9%9A%8F%E7%AC%94%E4%B8%8E%E4%B8%AA%E4%BA%BA%E6%96%87%E9%9B%86/%E4%BA%BA%E4%B8%96%E9%97%B4/</url>
    <content><![CDATA[<h2 id="人世间句子摘抄">人世间句子摘抄</h2>
<!-- <style>
blockquote {
  border-left: 2px dashed #333 !important;
  background:  #e4f2fe 0% !important;  
}
</style> -->
<h4 id="第9集-曲书记"><u>第9集 曲书记 </u></h4>
<blockquote>
<p>[!TIP] 每个人的境遇、条件都不同，不能千篇一律地要求，但一定要把自己的工作，自己的日子过好。</p>
</blockquote>
<h4 id="第9集-曲书记-1"><u>第9集 曲书记 </u></h4>
<blockquote>
<p>[!TIP] 趁着年轻，一定要多读书，多学习。</p>
</blockquote>
<h4 id="第9集-金主任"><u>第9集 金主任 </u></h4>
<blockquote>
<p>[!TIP] 做事，讲话都要讲分寸，不论对谁(亲人，夫妻...)，不要信口开河，张嘴就说。</p>
</blockquote>
<h4 id="郝省长"><u> 郝省长 </u></h4>
<blockquote>
<p>[!TIP] 人有人性的弱点，所以要加强约束、引导和规范。作为一名共产党员，坚守自己的党性原则，并使之培养成自觉自愿的自己的行为准则，这是至关重要的。</p>
</blockquote>
<h4 id="光明">光明</h4>
<blockquote>
<p>[!TIP] 守不住一个 <strong>定</strong> 字，未定时最难，不知道劲儿该往哪使。最坏的结果强过没有结果。</p>
</blockquote>
<p>似乎挺有道理的，比如考试成绩没出来之前，是最煎熬的。出来之后，即使不好，也比没出成绩时要轻松。</p>
<h4 id="冯化成">冯化成</h4>
<blockquote>
<p>[!TIP] 无论遇到多大、多急的事，放一放，冷一冷再行动。不要一遇到事就头脑发热、怎么痛快怎么来。</p>
</blockquote>
]]></content>
      <categories>
        <category>随笔与个人文集</category>
      </categories>
      <tags>
        <tag>人世间</tag>
      </tags>
  </entry>
  <entry>
    <title>科学休息法</title>
    <url>/2022/10/24/%E9%9A%8F%E7%AC%94%E4%B8%8E%E4%B8%AA%E4%BA%BA%E6%96%87%E9%9B%86/%E5%A6%82%E4%BD%95%E9%AB%98%E6%95%88%E4%BC%91%E6%81%AF/</url>
    <content><![CDATA[<h1 id="section"></h1>
<h1 id="如何高效休息">如何高效休息</h1>
<p>今天不谈工作谈休息。当然休息是为了更好地工作，所以谈休息也是谈工作。</p>
<p>什么样的休息，才能最大限度地让人精神饱满地投入到接下来的工作？</p>
<p>流行的休息法大概有两派，就好像气宗和剑宗。老一辈的人认为应该劳逸结合，每工作一段时间就休息一下，搞个什么工间操之类，就好像学生按节上课一样。年轻人强调拼劲，认为最好猛干一天，然后下班拼命放松。具体的休息内容，老一辈建议出门走两圈，或者跟（真）人聊聊天。年轻人则宁可躺在床上读个什么手机段子。</p>
<p><strong>现在我们有强有力的科学证据，老一辈的做法是对的。</strong></p>
<p>今天要说的是99U上的一篇文章，<em>“<strong>A Science-Backed Guide to Taking Truly Restful Breaks</strong>”</em>（良好休息的科学指南），作者 Christian Jarrett。</p>
<p>文章标题有点像微信朋友圈转发的那种生活小常识，但这篇文章其实是一个最新研究的综述。</p>
<p>科学家对休息效果的定义是，你在办公室工作一天，中间使用了什么休息方法，到下午下班前的精神状态和工作效率仍能保持高水平。</p>
<p>我们先来猜一下，在以下这几种休息活动中，哪个效率最高？</p>
<ol type="1">
<li><p><mark>放松：什么都不干，做做白日梦，或者做几个伸展运动</mark></p></li>
<li><p>给身体补充点什么东西：喝杯咖啡之类</p></li>
<li><p><mark>社交：跟同事聊聊天</mark></p></li>
<li><p>认知：读读新闻，查看邮件</p></li>
</ol>
<p>第4项，是我们大多数人最喜欢的休息方法。而且此前就有研究表明，<strong>一个人越累越困，反而越想上网看点什么东西。这个现象非常有意思，这就是为什么我们越晚睡的时候就越会……更晚睡。</strong></p>
<p>但研究结果非常明确——<strong>上网不但不能休息，反而会让我们变得更累。</strong></p>
<p>这是因为<strong>脑力劳动者最需要花费</strong>，也是最需要<strong>从休息中恢复</strong>的两个资源，是“<strong>意志力</strong>”和“<strong>注意力</strong>”。现在很多心理学实验都认为这是<strong>两个有限的资源，最好用在刀刃上</strong>。</p>
<p>所以休息的目的就是让注意力和意志力回血。但是上网——<strong>阅读会消耗注意力</strong>；决定是否点击，是否购买之类的<strong>各种决策会消耗意志力</strong>。</p>
<p>研究结果，真正有用的休息是1、3这两项。喝咖啡也没用。</p>
<p>所以科学家的<strong><font color="red">第一个建议</font></strong>是要休息，先断网。</p>
<p><strong><font color="red">第二个建议</font></strong>是短而频繁的休息比长时间工作然后长时间休息更好。</p>
<p>这个原理是人体不是汽车，你把油快用完了统一加一次就行，而是必须随时用随时补充。大概每隔半小时或者一小时就休息几分钟，效果良好。另外这种短休息流程要从上午就开始做，不要等到下午很累了再做。</p>
<p><strong><font color="red">第三个建议</font></strong>是最好休息的时候离开办公室。</p>
<p>有的公司喜欢让所有同事留在公司午休，吃个午饭也要在一起，其实并不利于休息。多伦多大学的研究者，最近研究观察了一百多位在大学工作的人，看他们午饭怎么吃。结果是如果你午饭跟同事一起吃，不论聊的是不是工作，休息效果都不好——快下班的时候别人评价你看上去很疲惫。如果这顿午饭还是老板要求全体一起吃的，更累。</p>
<p>所以从休息角度，找同事聊天最好用上班时间，午饭还是自由点好。</p>
<p>研究表明，哪怕出去散步五分钟，效果都要好得多。</p>
<h2 id="评论">| 评论</h2>
<p>我看这些研究中价值最大的还是有关上网的一项。对高强度脑力劳动者来说，“上网休息一下”，拿手机找两个猫的可爱图片看看，简直是再正常不过的事情了。可是现在我们知道<strong>凡是调动了注意力和意志力的行为就是消耗而不是休息。</strong></p>
<p>说白了，就是我们常常把“娱乐”和“休息”给混为一谈。</p>
<h2 id="由此得到">| 由此得到</h2>
<p>娱乐不是休息。</p>
<h2 id="总结">| 总结</h2>
<blockquote>
<p>科学家关于休息的几点建议：</p>
<ol type="1">
<li><p>要休息，先断网。</p></li>
<li><p>短而频繁的休息比长时间工作然后长时间休息更好。</p></li>
<li><p>最好休息的时候离开办公室。</p></li>
</ol>
</blockquote>
]]></content>
      <categories>
        <category>随笔与个人文集</category>
      </categories>
      <tags>
        <tag>生活</tag>
      </tags>
  </entry>
  <entry>
    <title>搭建hexo博客</title>
    <url>/2022/10/20/%E9%9A%8F%E7%AC%94%E4%B8%8E%E4%B8%AA%E4%BA%BA%E6%96%87%E9%9B%86/%E6%90%AD%E5%BB%BAhexo/</url>
    <content><![CDATA[<h1 id="搭建hexo博客">搭建hexo博客</h1>
<h2 id="hexo">hexo</h2>
<ol type="1">
<li>很简洁的主题，很喜欢<a href="https://gaoryrt.com/categories/随笔与个人文集/">pln主题</a>，
<ul>
<li>[gaoryrt/hexo-theme-pln: 📝 Plain theme for Hexo. (github.com)](https://github.com/gaoryrt/hexo-theme-pln</li>
</ul></li>
</ol>
<p><img src="https://cdn.staticaly.com/gh/peirsist/blog_img@master/Snipaste_2022-10-27_23-19-43.48teaudc6xq0.webp"></p>
<ol start="2" type="1">
<li><a href="https://hexo.io/themes/">Themes | Hexo</a></li>
<li><a href="https://www.bilibili.com/video/BV18z4y197J7/?spm_id_from=333.337.search-card.all.click&amp;vd_source=83831fc0970a6c8704479f7cfc679937">Hexo博客教程之写文章_哔哩哔哩_bilibili</a></li>
</ol>
<h2 id="指令">指令</h2>
<ol type="1">
<li>hexo g 生成静态页面</li>
<li>hexo d 发布本地内容到仓库</li>
<li>hexo s 生成静态页面</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo g</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure>
<h2 id="错误">错误</h2>
<ol type="1">
<li>错误如下：解决<a href="https://blog.csdn.net/qq_45020818/article/details/126949337">解决Hexo部署时报错：Error: Spawn failed_薛定谔的壳的博客-CSDN博客</a></li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">atal: unable to access <span class="string">&#x27;https://github.com/a956551943/a956551943.github.io/&#x27;</span>: Encountered end of file</span><br><span class="line">FATAL &#123;</span><br><span class="line">  err: Error: Spawn failed</span><br><span class="line">      at ChildProcess.&lt;anonymous&gt; (/usr/local/src/hexo/hanyubolg/node_modules/hexo-util/lib/spawn.js:51:21)</span><br><span class="line">      at ChildProcess.emit (events.js:376:20)</span><br><span class="line">      at Process.ChildProcess._handle.onexit (internal/child_process.js:277:12) &#123;</span><br><span class="line">    code: 128</span><br><span class="line">  &#125;</span><br><span class="line">&#125; Something<span class="string">&#x27;s wrong. Maybe you can find the solution here: %s https://hexo.io/docs/troubleshooting.html</span></span><br></pre></td></tr></table></figure>
<h2 id="配置">配置</h2>
<ol type="1">
<li><a href="https://www.jianshu.com/p/e17711e44e00">Hexo使用攻略-添加分类及标签 - 简书 (jianshu.com)</a></li>
<li><a href="https://blog.csdn.net/xinyflove/article/details/108791970">Hexo博客添加搜索功能_PeakXin的博客-CSDN博客_hexo搜索功能</a></li>
<li>hexo显示pdf
<ul>
<li><strong><a href="https://blog.csdn.net/weixin_37726222/article/details/123071678">【有用】hexo post中pdf文件的插入_时间里的河的博客-CSDN博客_hexo 插入pdf</a></strong></li>
<li><strong><a href="https://blog.csdn.net/weixin_45926582/article/details/107559639?spm=1001.2101.3001.6650.2&amp;utm_medium=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-2-107559639-blog-115603908.pc_relevant_multi_platform_whitelistv3&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-2-107559639-blog-115603908.pc_relevant_multi_platform_whitelistv3&amp;utm_relevant_index=5">hexo如何分类分标签进行展示与pdf、图片_月球转转转的博客-CSDN博客</a></strong></li>
</ul></li>
<li>hexo上传图片
<ul>
<li><strong><a href="https://blog.csdn.net/weixin_44783934/article/details/107798324?spm=1001.2101.3001.6650.1&amp;utm_medium=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-1-107798324-blog-104450037.t0_edu_mix&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-1-107798324-blog-104450037.t0_edu_mix&amp;utm_relevant_index=2">解决PicGo+GitHub搭建个人图床上传失败问题_wnhyang的博客-CSDN博客</a></strong></li>
<li><mark>PicGo上传失败，改用PicX</mark> <strong><a href="https://picx.xpoet.cn/#/upload">图片上传 | PicX 图床神器 (xpoet.cn)</a></strong></li>
<li><a href="https://blog.csdn.net/qq_38140292/article/details/118885686?">【Typora】github-与PicGO搭建图床_指尖听戏的博客-CSDN博客</a></li>
<li><a href="https://blog.csdn.net/qq_38140292/article/details/119076411">【hexo】基础教程-二-文章新增图片上传_指尖听戏的博客-CSDN博客_hexo怎么传照片</a></li>
</ul></li>
<li><a href="https://www.mingdao.me/Hexo/hexo-link-post/">Hexo如何增加站内文章链接 | 明道学苑 (mingdao.me)</a></li>
<li>生成归档页，显示全部。<a href="https://sobaigu.com/hexo-archives-show-all-in-one-page.html">参考</a></li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 设置首页分页之前默认就有，这里就不额外加了</span></span><br><span class="line"><span class="comment"># index_generator:</span></span><br><span class="line"><span class="comment">#   per_page: 5</span></span><br><span class="line"></span><br><span class="line">archive_generator:</span><br><span class="line">  per_page: 40  <span class="comment">#值为0表示不分页，按需填写</span></span><br><span class="line">  yearly: <span class="literal">true</span>  <span class="comment">#是否按年生成归档</span></span><br><span class="line">  monthly: <span class="literal">false</span>  <span class="comment">#为了加快生成速度，按月归档就不要了</span></span><br><span class="line"></span><br><span class="line">tag_generator:</span><br><span class="line">  per_page: 40  <span class="comment">#值为0表示不分页，按需填写</span></span><br></pre></td></tr></table></figure>
<h2 id="主题">主题</h2>
<ol type="1">
<li>Fulid
<ul>
<li><a href="https://github.com/fluid-dev/hexo-theme-fluid">fluid-dev/hexo-theme-fluid: 一款 Material Design 风格的 Hexo 主题 / An elegant Material-Design theme for Hexo (github.com)</a></li>
<li><a href="https://hexo.fluid-dev.com/docs/start/#主题简介">开始使用 | Hexo Fluid 用户手册 (fluid-dev.com)</a></li>
<li><a href="https://hexo.fluid-dev.com/docs/guide/#slogan-打字机">配置指南 | Hexo Fluid 用户手册 (fluid-dev.com)</a></li>
<li></li>
</ul></li>
<li>keep主题
<ul>
<li><a href="https://xpoet.cn/">XPoet's Blog</a></li>
<li><a href="https://xpoet.cn/2020/04/Keep-主题使用指南/">Keep 主题使用指南 | XPoet's Blog</a></li>
<li><a href="https://keep-docs.xpoet.cn/usage-tutorial/advanced.html">进阶使用 | Keep 主题使用指南 (xpoet.cn)</a></li>
</ul></li>
</ol>
<p>Obsidian 的使用</p>
<ol type="1">
<li><a href="https://zhuanlan.zhihu.com/p/487604071">200 多个 Obsidian 插件 - 知乎 (zhihu.com)</a></li>
<li><a href="https://xmq.plus/posts/7c30.html">Obsidian优化记录 | 肆零肆 (xmq.plus)</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/373888121#:~:text=obsidian%E7%9A%84CSS%E5%AD%98%E6%94%BE%E4%BD%8D%E7%BD%AE%E5%9C%A8%E7%AC%94%E8%AE%B0%E5%BA%93%E6%96%87%E4%BB%B6%E5%A4%B9%E4%B8%8B.obsidian%20%E7%9A%84%20themes%20%E5%92%8C%20snippets,%E8%BF%99%E4%B8%A4%E4%B8%AA%E6%96%87%E4%BB%B6%E5%A4%B9%E3%80%82%20thems%20%E4%B8%BB%E8%A6%81%E6%94%BE%E7%BD%AE%E4%B8%BB%E9%A2%98CSS%E6%96%87%E4%BB%B6%EF%BC%8C%E8%80%8C%20snippets%20%E4%B8%BB%E8%A6%81%E6%94%BE%E7%BD%AECSS%E7%89%87%E6%AE%B5%E3%80%82">Obsidian自定义样式修改教程 - 知乎 (zhihu.com)</a></li>
<li></li>
</ol>
]]></content>
      <categories>
        <category>随笔与个人文集</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>第315封信《硅谷来信》丨比穷更可怕的是什么</title>
    <url>/2022/10/30/%E9%9A%8F%E7%AC%94%E4%B8%8E%E4%B8%AA%E4%BA%BA%E6%96%87%E9%9B%86/%E7%AC%AC315%E5%B0%81%E4%BF%A1%E4%B8%A8%E6%AF%94%E7%A9%B7%E6%9B%B4%E5%8F%AF%E6%80%95%E7%9A%84%E6%98%AF%E4%BB%80%E4%B9%88/</url>
    <content><![CDATA[<figure>
<img src="https://cdn.staticaly.com/gh/peirsist/blog_img@master/第315封信丨比穷更可怕的是什么.6fpa2n37z3c.jpg" alt="第315封信丨比穷更可怕的是什么"><figcaption aria-hidden="true">第315封信丨比穷更可怕的是什么</figcaption>
</figure>
<p><strong>读者，你好！</strong></p>
<p>一位读者留言说，她的朋友讲，过去穷怕了，因此现在行为有点乖张，请她见谅。虽然她所说的朋友现在不仅不穷，而且拥有多套住房，以中国的房价来衡量，还颇为富有，但是过去的习惯一点也没有改变。</p>
<p>她说的这种现象似乎并不少见，今天总有人讲，小时候穷，一辈子穷，被很多人用来形容逆袭的艰难。<strong>小时候穷确实会带来很多不良的后果，比如缺乏安全感</strong>，一旦有了权力会用非常赤裸裸的手段贪污。台湾的陈水扁就是一个很好的例证。</p>
<p>再比如<strong>容易人穷志短，缺乏远见卓识，以至于走不出原有生活的圈子</strong>，比如美国贫民区家庭的孩子大多如此。又或者受到太多人的冷眼，后来一旦得势，心肠会变得非常冷。电视剧《人民的名义》中那个公安厅长祁同伟就有点这个劲儿。</p>
<p>但是，对于“小时候穷，一辈子穷”这种讲法我并不是很认同，<strong>因为我周围很多人小时候都过的是穷日子、苦日子，长大后身上不仅没有上述毛病，倒是反而因为吃过苦，更有动力努力向上，也懂得珍惜所获得的每一分，每一点，甚至在发了财之后，懂得回报社会，对周围朋友也相当慷慨。</strong></p>
<p>相反，我也看到不少从小锦衣玉食养出来的孩子，除了追求更多的物质享受外，没有什么值得称颂的。如果一些人将来家道中落了，那个日子可以说是相当难过。很多人都奇怪以曹雪芹的才华为什么混得如此惨兮兮的，在历史上雍正皇帝对他们家其实不算太苛刻。</p>
<p>后来我遇到一位身世和曹雪芹类似的长辈文人，就很能体会曹雪芹为什么落得那样的结果了。解放前上海南京路上很多大楼都是他们家的，后来被查抄没收了，生活的落差可想而知，虽然这位长辈才华横溢，但是一辈子仕途平平，过得一般，用别人的话讲，他不谙世事。</p>
<p>想到他们，我就理解了为什么茨威格要自杀，读读他的<strong>《昨日的世界》</strong>就能理解他过去所拥有的自由美好的世界一旦失去，那是一种怎样的绝望。简单地讲，由俭入奢容易，反过来则千难万难。</p>
<p>因此，我的观点是，<strong>小时候穷固然有很多不足，但是和后来的发展关系不是那么大</strong>。如果能重新选择是先穷还是后穷，我想大部分中国人是选择前者，因为先穷毕竟还有希望。相比之下，今天很多欧美人是选择后者，先过两天好日子再说，哪管将来生活怎么样呢！</p>
<p>不过，很多人指出的穷人所带的很多毛病确实存在，那么小时候穷和将来的发展到底有没有关系呢？从统计的结果看，毫无疑问有关系，但是<strong>有时统计的结果并不构成因果关系</strong>。</p>
<p>这就如同在近代之前的德国人一致认为女性比男性更适合酿制啤酒一样，虽然在统计上完全正确，因为事实如此，但真实的原因却是在家里做面包的总是女性，因此她们身上携带酵母。是酵母决定了啤酒的味道好，而不是酿制者的性别。了解了这个因果关系后，男性同样能酿制出上好的啤酒。</p>
<p>类似地，如果我们能够找到穷所导致的影响一个人一生发展的根本原因，那么即便小时候穷，将来也未必没有机会。相反，即便小时候富有，也要杜绝很多坏毛病，否则会成为穷到只剩下钱的地步。</p>
<p><strong>后来我发现，活得诸事不顺的人都有三个共同的问题。</strong></p>
<p><strong><font color="red">首先是缺乏见识。</font></strong>没有见识，视野就被局限了。你可能有这样的体会，和某些人讲道理永远讲不通，这并非那些人故意要和你作对，而是他们实在没有见识，大家的认知水平根本不在一个台阶上。</p>
<p>《庄子》说，“夏天的虫子不可能谈论冰，是因为受到时间的限制（它们活不到冬天）。乡曲之人，无法和他论道，因为他们受制于不高的教育程度”，就是这个道理。关于见识，我在第167封来信《对话庄子（1）：谈谈见识》中已经提到了，就不再赘述了。这里只提醒一点，对于在见识上不长进的人，少和他们来往，更不要和他们争论，因为道理讲不通，徒费口舌。</p>
<p><strong><font color="red">其次是缺乏爱。</font></strong>我们常说<strong>某某太小家子气，成不了大事。小家子气，其实就是缺乏爱的表现。</strong></p>
<p>一些人讲，因为小时候穷，被人瞧不起，于是以后没有安全感，所以对钱特别贪恋。这个解释未必说得通，贪欲其实除了圣人，谁都或多或少有一点。穷人也有不贪的，富人也有极为贪婪的。很多人小时候因为家里穷，父母没有条件太关爱他们，而在学校和社会上又常常遭人冷眼，同样地缺乏关爱。</p>
<p>这就造成了他们<strong>不懂得关爱别人，不懂得分享的结果</strong>。对于一些人来讲，小时候其实家里不穷，但是没有培养孩子关爱他人的习惯，以至于他们长大以后非常小家子气，这在个别的独生子女身上特别明显。</p>
<p>一位自身条件很好的女生有一次讲了她的一个困惑。她交往了几个条件很好的男朋友都吹了，对方给她的评价就是不懂得如何爱别人，开始她以为是对方在分手时恶语相向，也没有在意，到第二次的时候听到同样的话时就有点害怕了，于是她试图去爱，但是做不好。</p>
<p>后来她想可能因为是独生女，从小就没有把好东西分享给大家的习惯，而周围人对她又都是有求必应。她所讲的事情已经过去好几年了，我之所以还记得这件事是因为它引起了我对独生子女问题的思考。</p>
<p>在我看来，<strong>独生子女带来的社会问题，并非将来没有了劳动力，而是很多人没有了原有社会的家庭生活和亲戚关系。</strong>第一代独生子女感受不到兄弟姐妹的关心，到了第二代连堂表兄妹的关系也消失了。这才是可怕之处。<strong>缺乏爱的人难以大气，不大气的人做不成大事。</strong></p>
<p>很多人以为有了钱就有了一切，如果钱只花在自己享受上，并没有发挥它的最大效能，相反，如果能花在别人身上，投入到社会再生产中去，将会获得更高的回报。</p>
<p><strong><font color="red">最后，比贫穷更可怕的是缺乏规矩。</font></strong></p>
<p>缺乏规矩会踩到别人的脚趾而不自知，其结果是，轻则没有人愿意帮他们，重则大家会和他们作对，而这个世界上没有人帮助是不行的。当然，这些人也会感觉到别人对他们不友善，或者敬而远之，但是常常还不知道原因，于是便对别人，对社会产生一种戾气。</p>
<p>前一阵有这样一则新闻，讲一个八十岁的老太太往飞机发动机里撒了一把钱，说是祈福，这不仅造成了不小的经济损失，而且耽误了大家很多时间。在中国没有民事诉讼索赔，在一些国家，航空公司不仅可以起诉她索赔巨款，耽误了时间的乘客也可以要求赔偿时间损失，这可不是一个小事情。</p>
<p>你说这位老人一定有多坏吗？也未必，有人说是没有常识，其实也不是没有常识，而是没有规矩。类似地，更早一些时间，东方航空公司的一个乘客手欠放下了应急滑梯，这也是没有规矩的典型表现。</p>
<p>我们经常会听到“熊孩子”这三个字，熊孩子的特点就是缺乏规矩。小时候缺乏规矩，长大以后就没有守规矩的习惯，那么将来的麻烦就很大。</p>
<p>缺乏<strong>见识</strong>、缺乏<strong>爱</strong>、缺乏<strong>规矩</strong>，是比缺钱更可怕的。没有钱，有一辈子的机会能够获得，而缺乏前面这三样东西，后天再获得的难度就非常大了，而它们的缺乏其实和穷没有必然联系。</p>
<p>很多人在说，现在社会分层了，我们的孩子没有了机会，其实机会总是有的。<strong>缺钱可能会在短期内物质条件差一点，但是并不影响父母在见识、爱和规矩上培养好孩子</strong>，有了意识，做到这些事并不难。反之，家里有钱，孩子也不会一定就有见识，有爱心，守规矩。</p>
<p>因此，对家长和我们自己来讲，小时候穷都不是将来不能成功的理由。</p>
<p><strong>祝好运！</strong></p>
<p>2017年8月23日于硅谷</p>
]]></content>
      <categories>
        <category>随笔与个人文集</category>
      </categories>
  </entry>
  <entry>
    <title>脸上长痘痘怎么调理</title>
    <url>/2022/11/05/%E9%9A%8F%E7%AC%94%E4%B8%8E%E4%B8%AA%E4%BA%BA%E6%96%87%E9%9B%86/%E8%84%B8%E4%B8%8A%E9%95%BF%E7%97%98%E7%97%98%E6%80%8E%E4%B9%88%E8%B0%83%E7%90%86/</url>
    <content><![CDATA[<p><a href="https://zhuanlan.zhihu.com/p/69344626">脸上长痘痘怎么调理 - 知乎 (zhihu.com)</a></p>
<p><a href="https://www.xiaohongshu.com/discovery/item/60dd8e570000000001026b41?app_platform=android&app_version=7.63.1&share_from_user_hidden=true&type=normal&xhsshare=WeixinSession&appuid=6365eac5000000001f01afa7&apptime=1668493130">男生不同部位长痘原因⁉️祛痘建议✅ (xiaohongshu.com)</a><br><a href="https://www.xiaohongshu.com/discovery/item/635b875c000000001400f4a8?app_platform=android&app_version=7.63.1&share_from_user_hidden=true&type=normal&xhsshare=WeixinSession&appuid=6365eac5000000001f01afa7&apptime=1668493185">油痘肌干货✅不同位置痘痘⚠️进来对号入座 (xiaohongshu.com)</a></p>
<p>额头右侧长痘痘意味着你的肝脏积累了太多的毒素，生活不规律、压力太大会让肝脏的负荷超载，无法正常工作，容易引起心火和血液循环问题。 前额：代表心火旺、血液循环有问题，可能过于劳心伤神有关。 这时期的你脾气比较不好，就要多睡觉，多喝水，减少饮用酒精类饮品。 一、额头长痘痘多是因为压力大，这个压力很大部分就跟工作有关。 我们的工作压力一旦增加，心理就会莫名的烦躁，体内分泌也就过盛，一些油脂分泌物长期无法正常的被排出体外，额头就会首先反应出这种现状。 二、电脑的普遍使用，对于我们来说有好有坏。 一些长期面对电脑的人，皮肤就很难呼吸到新鲜的空气，再加上有的人喜欢留各种刘海，额头的皮肤闷在里面，新陈代谢功能就会减弱，所以说痘痘第一时间也会长在额头上</p>
<p><strong>不同部位长痘原因</strong><br><img src="https://cdn.staticaly.com/gh/peirsist/blog_img@master/8ef9913503a5b045dba14d1baa04cdf.2cxiqt6d8a80.jpg" alt="8ef9913503a5b045dba14d1baa04cdf"><br><img src="https://cdn.staticaly.com/gh/peirsist/blog_img@master/08fd3258226c1676037f1d9e1ed4307.55fdt4xnra80.jpg" alt="08fd3258226c1676037f1d9e1ed4307"><br><img src="https://cdn.staticaly.com/gh/peirsist/blog_img@master/c9fca4ee2a9916496f6b38b3b019eff.1c69grh876ao.jpg" alt="c9fca4ee2a9916496f6b38b3b019eff"><br><img src="https://cdn.staticaly.com/gh/peirsist/blog_img@master/31ab6cedda408a92ebceef5bf33791b.rswibtwt5z4.jpg" alt="31ab6cedda408a92ebceef5bf33791b"><br><img src="https://cdn.staticaly.com/gh/peirsist/blog_img@master/7cb63a9797fd865344eae9a18dded1f.49o0pdd9axu0.jpg" alt="7cb63a9797fd865344eae9a18dded1f"><br><img src="https://cdn.staticaly.com/gh/peirsist/blog_img@master/ef7600b2eed014ea8ae27756081071e.425u1be53tk0.jpg" alt="ef7600b2eed014ea8ae27756081071e"><br><img src="https://cdn.staticaly.com/gh/peirsist/blog_img@master/c53c4fd3914fa528a91d5da4971852f.5bpjzt9bw6k0.jpg" alt="c53c4fd3914fa528a91d5da4971852f"><br><img src="https://cdn.staticaly.com/gh/peirsist/blog_img@master/1d36f6587f37fae595e5ce727b13146.3809o8ljq8s0.jpg" alt="1d36f6587f37fae595e5ce727b13146"><br><img src="https://cdn.staticaly.com/gh/peirsist/blog_img@master/b093b2bfc085d3f8973dcca25c9cc02.4kv16fsg0a60.jpg" alt="b093b2bfc085d3f8973dcca25c9cc02"><br><img src="https://cdn.staticaly.com/gh/peirsist/blog_img@master/df77de72f36fdfb6a7295fe256b4bc7.73vwxl66n8s0.jpg" alt="df77de72f36fdfb6a7295fe256b4bc7"><br><img src="https://cdn.staticaly.com/gh/peirsist/blog_img@master/7173e9d2a16f0d45b293a94f8ae92be.3q0xm6i8nk0.jpg" alt="7173e9d2a16f0d45b293a94f8ae92be"></p>
]]></content>
      <categories>
        <category>随笔与个人文集</category>
      </categories>
      <tags>
        <tag>生活</tag>
      </tags>
  </entry>
  <entry>
    <title>要读博吗</title>
    <url>/2022/11/03/%E9%9A%8F%E7%AC%94%E4%B8%8E%E4%B8%AA%E4%BA%BA%E6%96%87%E9%9B%86/%E8%A6%81%E8%AF%BB%E5%8D%9A%E5%90%97/</url>
    <content><![CDATA[<ol type="1">
<li><a href="https://www.bilibili.com/video/BV1ge4y177dV/?spm_id_from=333.1007.tianma.2-1-3.click&amp;vd_source=83831fc0970a6c8704479f7cfc679937">不要盲目追求学历，读博士是什么体验</a></li>
<li><a href="https://www.zhihu.com/question/468564547/answer/1972180362?utm_campaign=shareopn&amp;utm_content=group3_Answer&amp;utm_medium=social&amp;utm_oi=910069747331248128&amp;utm_psn=1576492511123415040&amp;utm_source=wechat_session">网传 top2 高校某院士团队的博士生大面积延毕，实际情况如何？ - 知乎 (zhihu.com)</a></li>
<li><a href="https://mp.weixin.qq.com/s/pliljqn7yo1dxccmkgQDxQ">家境不好应不应该读博？ (qq.com)</a></li>
<li><a href="https://mp.weixin.qq.com/s/4WzwCfMhY5utJyDlrFOKZw">【学术相关】从长远来看读博的收益是巨大的，为什么读博的人却很少？ (qq.com)</a></li>
</ol>
<p>先陈述几个事实：</p>
<ol type="1">
<li>工作了之后个人的学习能力和学习机会一定会断崖式下降，唯一能够积累的是“经验”。（获得经验不属于学习，属于应用，是知识的输出）</li>
<li>高科技行业薪资往往倒挂严重，个人薪资的增长远远赶不上市场的变化，工作几年后可能入手还不如高点入市的新人，这几年 ai 行业尤其明显。</li>
<li>出去工作基本上都是在搬砖，本硕毕业出去90%的工作都是搬砖，剩下的10%的高价值创新性工作只留给领域内的顶级专家（一般都有博士学位）或高管。</li>
<li>高附加值岗位的竞争日益激烈，从最开始的c9本科间竞争，慢慢发展到c9研究生竞争（研究生一般都自带论文和项目经验，默认优于本科生），再到今天的全球名校毕业生竞争，高价值岗位的放出速度已经逐渐赶不上本硕的产出速度。</li>
<li><strong>读博士可能是你这辈子唯一的，有可能成为领域内顶级专家的机会</strong>，如果放弃了这个机会，就意味着你要在社会上摸爬滚打数十年，从底层的一颗螺丝钉做起，走无数的弯路，做无数个项目（真的好项目得运气好才能接触到），保持极高的情商才能到达这一步。</li>
</ol>
<p>陈述完上述五个事实以后，<strong>如果你不想搬砖，有意愿成为领域内的顶级专家，从事创新性工作，那么读博似乎是唯一的途径。</strong>（尽管并不是所有人都能做到，但其他的途径因为在工作后基本上没条件学习了，所以能成为顶级专家的概率几乎为0）</p>
<p>如果你并没有此等打算，那么你最好优秀（竞争的过其他高手），并且运气够好（最好撞上风口）。</p>
<p>如果家境贫寒急需用钱，博士也有基本工资，也有奖学金，只是这比硕士工作要少很多，不过也勉强够用。但记住博士的价值爆发来自于学位拿到之后，不来自于之前之中。</p>
<p>如果你想enjoy your life，那么国企或者闲职比较适合你，反正薪水都不是很高，也不996。</p>
<p>最后，以上都是基于利益的考虑，如果非要抠钱数的话可以参考一下，但真正是否读博士和以上的关系并不是最大的，有很多家境不好也拿了奖学金去读phd的，也有家境好的毕业了就去工作的。真正最重要的部分是你是否对研究感兴趣，不感兴趣的话就是给你奖学金怕是也不会去啊。</p>
<p><strong>工作5年，带你的人就是个比你多了2-3年工作经验的小破领导，读博5年，你跟的人起码是个技术总监</strong> <strong>级别的科学家，最后哪个收益大不言自明。</strong></p>
<p><strong>如果你有幸拜在大牛门下，那么恭喜你，带你的就是Top公司CTO级别的人，那你的前路绝对比工作出来要长远多了，最起码大牛这个资源是你用得上的，别的人要想获得同样的支持，你知道要花掉多少钱吗？</strong></p>
<p><strong>人啊，还是不要太短视，什么需要“早日工作养家糊口”根本就是短视的借口，山区出来拿tx顶薪的ai博士还历历在目，不浮躁的人最终有更好的归宿。</strong></p>
<p><strong>不要甘于落入局部最优解，人生是场长跑，你年轻时获得的资源才是决定你日后成败的关键。</strong></p>
<p>有的人可能不太理解“有机会”和“一定是”的差别。</p>
<p>在这里解释一下，有机会代表着有可能，但不是100%，一定是代表着绝对，100%的几率。</p>
<p>不管承认与否，想在一个领域内成为专家，phd确实是最好的机会，这就是现在的一个事实，并非抬举博士。如果你想通过搬砖搬成专家也不是不行，只不过你要花上10-20年，这其中一半的时间还要在养家糊口，买车买房，还房车贷，办公室政治等等一系列琐事上花费时间精力，然后你还要在这样的情况下抽出时间学习提高，这几乎没人能做得到吧，这可比读博士难了不止一倍。</p>
<p>有的人可能会提到所谓的“读博造成阶级回落”，我想申明一下，所谓的“阶级论”只是一群不上不下的小资/中产制造出来的一种贩卖焦虑的东西罢了。对于寒门学子来说，本身就是无产阶级，一年全家就几千的收入，置于社会底层，本身就没有回落的空间，一旦上了大学就是完成了阶级跨越。而且大多数寒门学子也没有像小资中产那么奢靡浮躁的“跨越到资产阶级”的需求。很多城市出身的中产把自己代入了无产阶级，然后用自己的经历告诉别人不该这样那样，殊不知先是自己的屁股坐歪了，得出来的结论自然也很歪很奇怪。</p>
<hr>
<p>博士招生名额非常有限。所以导致读博的人很少，这是根本原因。</p>
<p>但是不可否认的是，不同专业的读博兴趣是不一样的。像我所读的计算机这类热门工科专业，硕士毕业找工作难度并不大，出路多，薪资可观。我们班上三四十人，选择读博的我印象中好像有一个去的ucla，其他多数基本都选择就业。</p>
<p>选择读博的这个同学，读研期间就发了顶会，学术潜质比较好。自己对钻研学术的兴趣也高，申请国外博士的道路也顺理成章。</p>
<p>那么大多数同学为什么没考虑读博，我总结一些身边朋友的想法供大家参考。</p>
<ol type="1">
<li><p>对我们专业来说，想读博并不难。但读博之路真的艰辛，耗时又久，博士的毕业要求相比硕士高的程度是明显超过硕士之于本科的。况且，博士的实际收益也没有我们想象的高。博士毕业大多选择进高校任教。但高校教师待遇说实话不算太高。以我导为例，他说他过的很轻松，但是每个月到手就五六千块（现在可能涨了），其他奖金绩效之类的收入，是有一些。但是我导直言，『你们将来毕业去企业，工资是要吊打我们的。我虽然没什么本事，但带出来的学生就业都挺好的」。</p></li>
<li><p><strong>博士的实际就业面其实并不宽。</strong>虽然你可以选择向下兼容的岗位，但是用人单位却不一定敢用你，如果招了博士却给不出相应的待遇，那是要挨巴掌的。有些博士会选择引进到机关或机关下辖单位，但干的会比较别扭。首先<strong>博士年龄层是偏大的，其次科研水平较好</strong>，但是文人气息更重。一些短视的当地中层领导看到新进博士占用了本属于自己晋升的坑位，必然会对你使绊子。所以博士进机关及机关下辖事业单位，一般干的并不舒服。</p></li>
<li><p>个人以为，<strong>博士最好的就业去处依旧是教育系统（含高校与科研院所）</strong>。非升即走的 985211 待遇是相当高，但是也别只盯着那些学校。<strong>想要舒服你可以去直接给编的双非院校</strong>，乃至职业院校和中小学都是很不错的出路。</p></li>
<li><p>高中同学是国外某知名院校博士毕业，有过博后科研经历。回国后坦言国内好卷，目前在珠三角Q某知名院校，非升即走奋斗中。因为是某有钱院校，加上非升即走的高薪，所以目前年薪应该有个四五十万。希望他顺利卷上岸。在国内没 title 真的很难搞。</p></li>
</ol>
<p><strong>综合来说长远看来，读博的收益未必有很多人想象中的那么大，但是风险无疑是巨大的。</strong> 光是<strong>博士毕业这个压力就真的像大山一样压得你喘不过气来。</strong>前面我提到过，博士毕业的难度相比硕士毕业的难度，是远大于硕士毕业的难度之于本科毕业的难度。光是这一点就劝退多想读博的人了。<strong>想一下毕导大佬，如果博士能轻松毕业，那他会选择不毕业吗？</strong>虽然自媒体确实占用了时间，<strong>但如果不是博士的毕业压力过大，他总不可能放弃这个博士毕业证吧。</strong></p>
]]></content>
      <categories>
        <category>随笔与个人文集</category>
      </categories>
      <tags>
        <tag>人生规划</tag>
      </tags>
  </entry>
  <entry>
    <title>研究生规划</title>
    <url>/2022/05/19/%E9%9A%8F%E7%AC%94%E4%B8%8E%E4%B8%AA%E4%BA%BA%E6%96%87%E9%9B%86/%E9%9A%8F%E7%AC%942-%E7%A0%94%E7%A9%B6%E7%94%9F%E8%A7%84%E5%88%92/</url>
    <content><![CDATA[<h2 id="研究生（人生）目标"><a href="#研究生（人生）目标" class="headerlink" title="研究生（人生）目标"></a>研究生（人生）目标</h2><p>研究生需要达到的要求：</p>
<ol>
<li>专业上<ul>
<li>找到自己的方向，并使之成为擅长的领域</li>
<li>雅思，英语听说读写，可以正常交流</li>
</ul>
</li>
<li>生活上<ul>
<li>对生活有热情</li>
<li>常怀感恩之心和敬畏之心</li>
<li>遇事积极向上，不要有负面情绪。一切不好的东西总会过去的~</li>
</ul>
</li>
<li>个人<ul>
<li>沉稳、冷静</li>
<li>控制好自己的情绪，不要向身边的人，尤其是亲人、朋友发脾气</li>
<li></li>
</ul>
</li>
</ol>
<p><img src="https://cdn.staticaly.com/gh/peirsist/blog_img@master/Snipaste_2021-11-16_15-12-26.5kop4jg2ulw.webp" alt="Snipaste_2021-11-16_15-12-26"></p>
<p><img src="https://cdn.staticaly.com/gh/peirsist/blog_img@master/%E5%9F%B9%E5%85%BB%E7%9B%AE%E6%A0%87.4k2krbev3yq0.webp" alt="培养目标"><br><img src="https://cdn.staticaly.com/gh/peirsist/blog_img@master/%E7%BC%96%E7%A8%8B.7ldzhsn3bds0.webp" alt="编程"><br><img src="https://cdn.staticaly.com/gh/peirsist/blog_img@master/%E7%A0%94%E7%A9%B6%E7%94%9F%E8%A6%81%E6%B1%82.6212ok9ggcw0.webp" alt="研究生要求"><br><img src="https://cdn.staticaly.com/gh/peirsist/blog_img@master/%E5%8F%A3%E8%AF%AD%E7%9B%AE%E6%A0%87.2v56xg5nvc20.webp" alt="口语目标"><br><img src="https://cdn.staticaly.com/gh/peirsist/blog_img@master/%E7%A7%AF%E7%B4%AF%E9%A1%B9%E7%9B%AE.52nce0nwoe40.webp" alt="积累项目"></p>
<h2 id="研究生规划"><a href="#研究生规划" class="headerlink" title="研究生规划"></a><strong>研究生规划</strong></h2><p><code>2022</code>年<code>5</code>月<code>12</code>日   </p>
<p><a href="https://www.bilibili.com/video/BV1AB4y1m7yV?spm_id_from=333.880.my_history.page.click">【研0必看】985导师分享研究生期间学习规划，让你实现边玩边学！_哔哩哔哩_bilibili</a></p>
<p>做一个研究生规划，毕竟三年时间也是非常宝贵的，我既不想虚度时光，但也不想整天学的很累，按照自己的节奏来，所以早早地做一个规划吧，为研究生生涯画上一个完美的句号。</p>
<p>我是不打算读博了，但是呢，在国内读研究生都是以培养学术研究为目标的，再说研究方向和工作也可能不相关，所以科研任务（决定毕业）和找工作基本上是两条路。</p>
<ul>
<li>找工作不想找纯软件的工作，例如开发一个客户端什么的，对这个也不感兴趣，但是研究的是软件，<strong>研究生目标就是把编程能力提上去</strong></li>
<li>因为我学过电路，有硬件基础，因此还是很有优势的，未来可能会去硬件公司。</li>
<li><strong>先把软件学好，先专精一门之后，再扩展技能，是不错的选择</strong>，不然就会什么都了解一点点，什么都不会</li>
<li><strong>C++方面最好可以找一些相关的项目</strong>，赚点钱，才能有真正的提升，技能才不会丢</li>
</ul>
<p>目前呢，打算前两年还是好好做科研任务（<strong>前两年按照正规学术标准去规划</strong>），争取在前两年就可以写好毕业论文，毕竟毕业是头等大事，无论是否读博，都要把毕业论文好好完成，在保证能毕业的情况下，再谈其他的。</p>
<p>每半年分成一个部分，越早起步越好，然后开学前还有半年，打好基础，基础很重要（ <strong><font color="red"> 勿在浮沙筑高台 </font></strong> ）。</p>
<ul>
<li><p><strong><font color="red"> 安排好自己的生活，在学习的同时又能兼顾自己的兴趣爱好 </font></strong></p>
<ul>
<li>保证每日的任务量</li>
<li>但是不熬夜，11点之前可以睡着（当然这需要室友的配合，希望未来的室友不打游戏，可以早点睡觉）</li>
<li>有时间去玩，锻炼身体</li>
</ul>
<p> 看似简单，其实也不容易。</p>
</li>
<li><p><strong><font color="red"> 养成专注的习惯 </font></strong></p>
<p> 学习就是学习，学习的时候就不要看手机，每天专心学习<code>7-8</code>个小时，完全可以完成要求，也完全有时间去玩。</p>
</li>
<li><p><strong><font color="red"> 成熟稳重</font></strong> </p>
<ul>
<li>一个人出去旅游，出去玩</li>
<li>一个人在陌生的城市里立足</li>
</ul>
</li>
</ul>
<p><strong>尽快的独立起来，做事不要依靠任何人，可以独当一面，成熟稳重起来</strong></p>
<hr>
<ol>
<li><code>2022.5.12-2022.9</code> <strong><font color="red"> 研究生开学前 </font></strong><br>- <strong>打好编程基础。学习C++课程</strong><ul>
<li>目前基础语法学完了，总结一下，上传。</li>
<li>正在学<code>STL</code>，有<code>46</code>节课，一天<code>2-3</code>节</li>
<li><strong>一定要动手去写代码</strong></li>
<li><strong>计算机网络</strong></li>
<li><strong>计算机组成原理</strong> <a href="https://www.bilibili.com/video/BV1BE411D7ii?p=4">王道计算机考研 计算机组成原理_哔哩哔哩_bilibili</a></li>
<li>一共<code>97</code>节，<code>45</code>天，一天<code>2</code>节课就可以，</li>
<li><strong>复习很重要</strong>，第一天学过之后，第二天复习，那么后面会复习的越来越多，前面的以前可能有的学过，所以前面尽可能多看，后面重要的放慢进度。</li>
<li><strong>操作系统</strong></li>
<li><strong>英语学习。</strong>英语在面试，生活中用处还是非常大的，<strong>英语一定要坚持学</strong>。<ul>
<li>做六级，六级考的也不太高</li>
</ul>
</li>
<li><strong>确定自己的研究方向，看论文，记笔记</strong></li>
</ul>
</li>
</ol>
<hr>
<ol start="2">
<li><p><code>2022.9-2023.3</code><strong><font color="red">  研一上半年 </font></strong></p>
<ul>
<li>应该会有很多专业课程</li>
<li>看论文，对于研究背景什么的，平时就记录自己的想法，到时候写开题报告，论文的时候可以直接拿来用。不要让写论文、改论文这些事去耽误找工作的时间</li>
</ul>
</li>
<li><p>先写到这里吧，到时候再具体看情况，毕竟计划赶不上变化，但是一个大致的规划还是要有的~</p>
</li>
</ol>
<hr>
]]></content>
      <categories>
        <category>随笔与个人文集</category>
      </categories>
      <tags>
        <tag>人生规划</tag>
      </tags>
  </entry>
  <entry>
    <title>看李健视频的感悟</title>
    <url>/2022/02/21/%E9%9A%8F%E7%AC%94%E4%B8%8E%E4%B8%AA%E4%BA%BA%E6%96%87%E9%9B%86/%E6%9D%8E%E5%81%A5/</url>
    <content><![CDATA[<h2 id="看李健视频的感悟"><a href="#看李健视频的感悟" class="headerlink" title="看李健视频的感悟"></a>看李健视频的感悟</h2><p>关于生活</p>
<ul>
<li><a href="https://www.bilibili.com/video/BV1kU4y1P7Hi?spm_id_from=333.999.0.0">【李健】初入大学，这些视频缓解了我很大一部分焦虑|bilibili.</a></li>
<li><a href="https://www.bilibili.com/video/BV1Sx411s71x?spm_id_from=333.999.0.0">【看见李健四大高校健谈会】第一站 清华大学「看见青春-大时代背景下的个人生活」_2015.11.19 bilibili..</a></li>
<li><a href="https://www.bilibili.com/video/BV1sb411x7bb?spm_id_from=333.999.0.0">【李健】最值得一看的访谈——如何应对走红_bilibili.</a></li>
<li><a href="https://www.bilibili.com/video/BV1Bz4y1S7F7?spm_id_from=333.999.0.0">【李健】专访回顾（三）生活的理想是为了理想的生活 音乐不是我生活的全部__20130828 bilibili.</a></li>
<li><a href="https://www.bilibili.com/video/BV1KE41117km?spm_id_from=333.999.0.0">【李健】专访：优秀音乐家不需要突破（超清）bilibili.</a></li>
<li></li>
</ul>
<p><a href="https://www.bilibili.com/video/BV1Sx411s71x?spm_id_from=333.999.0.0">【看见李健四大高校健谈会】第一站 清华大学「看见青春-大时代背景下的个人生活」_2015.11.19 bilibili.</a></p>
<blockquote>
<p>[!TIP]</p>
<ol>
<li>人最重要的是<strong>拥有自己的生活，拥有自己的快乐</strong>。很多时候所谓事业要达到一个什么样的顶峰其实没有真正的意义。</li>
<li>一个人一定要拥有自己的爱好，拥有自己的快乐。很少有人能够从事自己热爱的工作，枯燥的生活正是被自己的爱好，生活的小恩小惠所化解掉了。</li>
</ol>
</blockquote>
]]></content>
      <categories>
        <category>随笔与个人文集</category>
      </categories>
  </entry>
  <entry>
    <title>职业规划</title>
    <url>/2022/05/17/%E9%9A%8F%E7%AC%94%E4%B8%8E%E4%B8%AA%E4%BA%BA%E6%96%87%E9%9B%86/%E9%9A%8F%E7%AC%941-%E5%85%B3%E4%BA%8E%E8%81%8C%E4%B8%9A%E8%A7%84%E5%88%92/</url>
    <content><![CDATA[<h2 id="职业规划"><a href="#职业规划" class="headerlink" title="职业规划"></a><strong>职业规划</strong></h2><p><code>2022.5.16</code>于家中</p>
<ul>
<li><a href="https://www.bilibili.com/video/BV1PY4y1e7VB?spm_id_from=333.999.0.0">给C++就业方向的应届毕业生的一些分析与建议，帮助大家少浪费时间，多花时间在有意义的事情上_哔哩哔哩_bilibili</a></li>
<li><a href="https://www.bilibili.com/video/BV1C541127i7?spm_id_from=333.999.0.0">快问快答丨入行&#x2F;转行IC选什么方向？学什么东西？要不要读研？_哔哩哔哩_bilibili</a></li>
<li><a href="https://mp.weixin.qq.com/s/v1wz3tN8PxTGnbMEPHnwFg">C++学习建议，重点看一下</a></li>
</ul>
<p>纯软件的职业不适合我，论编程开发，我比不过学软件的。但是，<strong>世上编程者大把，精通模电者寥寥。</strong>，会编程的人很多，可是又有几个人懂得硬件呢？</p>
<p>没事就问问自己， <strong><font size="5"><font color="red">自己的核心竞争力是什么？</font></font></strong> ，要学一些别人不会，你会的东西，这种东西没有你做不了，夹缝中求生存。</p>
<p>目前来看，很有优势，毕竟本科是学电路的，有硬件的知识，会软件的肯定没有几个人懂硬件，世上也不缺会编程的人。但是要切记 <strong><font size="5"><font color="red">先精通一门，再扩展技能</font></font></strong></p>
]]></content>
      <categories>
        <category>随笔与个人文集</category>
      </categories>
      <tags>
        <tag>人生规划</tag>
      </tags>
  </entry>
  <entry>
    <title>线性回归</title>
    <url>/2022/07/21/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/00Tra_ML/02.%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92/</url>
    <content><![CDATA[<h2 id="单变量线性回归">单变量线性回归</h2>
<p>梯度下降做的事就是找到一个值 <span class="math inline">\(\theta\)</span> 使得代价函数 <span class="math inline">\(J(\theta)\)</span> 最小</p>
<h2 id="多变量线性回归">多变量线性回归</h2>
<ul>
<li>通常用 <strong>大写、黑体</strong> 字母表示矩阵，用小写字母表示标量或向量。</li>
<li><strong>正斜体</strong> 总的原则是变量（矢量，张量）等用斜体；数字、确定符号、词汇缩缩、单位等用正体。参考 <a href="https://blog.csdn.net/wanjiac/article/details/106085105">科技论文书写规范之正斜体问题</a></li>
</ul>
<h3 id="符号说明">符号说明</h3>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">符号/变量</th>
<th style="text-align: center;">含义</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;"><span class="math inline">\(n\)</span></td>
<td style="text-align: center;">特征量的数目</td>
</tr>
<tr class="even">
<td style="text-align: center;"><span class="math inline">\(m\)</span></td>
<td style="text-align: center;">训练样本的数量</td>
</tr>
<tr class="odd">
<td style="text-align: center;"><span class="math inline">\(h\)</span></td>
<td style="text-align: center;">学习方法的解决方案或函数也称为假设</td>
</tr>
<tr class="even">
<td style="text-align: center;"><span class="math inline">\(\boldsymbol{x}^{\left(i \right)}\)</span></td>
<td style="text-align: center;">第<span class="math inline">\(i\)</span>个训练样本的输入特征值</td>
</tr>
<tr class="odd">
<td style="text-align: center;"><span class="math inline">\(\boldsymbol{x}^{\left(i \right)}_{j}\)</span></td>
<td style="text-align: center;">第<span class="math inline">\(i\)</span>个训练样本中第<span class="math inline">\(j\)</span>个特征量的值</td>
</tr>
</tbody>
</table>
<p><a href="https://imgtu.com/i/XgAtXD#pic_center"><img src="https://s1.ax1x.com/2022/06/11/XgAtXD.png" alt="XgAtXD.png" style="zoom:150%;"></a></p>
<table style="width:6%;">
<colgroup>
<col style="width: 5%">
</colgroup>
<thead>
<tr class="header">
<th><a href="https://imgtu.com/i/XgAa0H#pic_center"><img src="https://s1.ax1x.com/2022/06/11/XgAa0H.png" alt="XgAa0H.png" style="zoom:150%;"></a></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><a href="https://imgtu.com/i/XgAUne"><img src="https://s1.ax1x.com/2022/06/11/XgAUne.png" alt="XgAUne.png" style="zoom:150%;"></a></td>
</tr>
</tbody>
</table>
<p><a href="https://imgtu.com/i/XgAd7d"><img src="https://s1.ax1x.com/2022/06/11/XgAd7d.png" alt="XgAd7d.png" style="zoom:150%;"></a></p>
<p><code>python</code>计算代价函数的代码 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">conputeCost</span> (x, y, theta):</span><br><span class="line">    inner = np.power(((x * theta.T) – y), <span class="number">2</span>)</span><br><span class="line">    <span class="keyword">return</span> np.<span class="built_in">sum</span>(inner) / (<span class="number">2</span> * <span class="built_in">len</span>(x))</span><br></pre></td></tr></table></figure> 通过图像，<span class="math inline">\(y\)</span> 轴是代价函数的最小值 <span class="math inline">\(\mathrm{min}J(\theta)\)</span> ，<span class="math inline">\(x\)</span>轴是迭代次数。如果随着迭代次数的增加，代价函数越来越小，就说明 <strong><code>梯度下降</code></strong> 在正常工作。</p>
<h3 id="梯度下降-vs.-正规方程">梯度下降 vs. 正规方程</h3>
<table>
<colgroup>
<col style="width: 50%">
<col style="width: 50%">
</colgroup>
<thead>
<tr class="header">
<th style="text-align: center;">梯度下降</th>
<th style="text-align: center;">正规方程</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">需要选择学习率</td>
<td style="text-align: center;">不需要</td>
</tr>
<tr class="even">
<td style="text-align: center;">需要多次迭代</td>
<td style="text-align: center;">一次运算就得出结果</td>
</tr>
<tr class="odd">
<td style="text-align: center;">当特征数量大的时候比较适用</td>
<td style="text-align: center;">计算 <span class="math inline">\((\boldsymbol{X^TX})^{-1}\)</span> 如果特征数量很大，则运算的速度就会很慢，矩阵逆运算的时间复杂度是 <span class="math inline">\(\mathrm{O}(n^3)\)</span>,通常来说 <code>n&lt;10000</code> 还是可以接受的。</td>
</tr>
<tr class="even">
<td style="text-align: center;">适用于各种模型</td>
<td style="text-align: center;">只适用与线性模型</td>
</tr>
</tbody>
</table>
<h2 id="向量化">向量化</h2>
<p>使用程序计算这样一个线性回归假设函数：<span class="math inline">\(h_{\theta}(x)=\sum^n_{j=0} \theta_j x_j\)</span>，可以写成向量的形式： <span class="math display">\[h_{\theta}(x)=\sum^n_{j=0} \theta_j x_j = \boldsymbol{ \theta^T x}\]</span> 非向量化实现 <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">double</span> prediction = <span class="number">0.0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j&lt;=n; j++)</span><br><span class="line">    prediction += theta[j] * x[j];</span><br></pre></td></tr></table></figure></p>
<p>向量化实现，使用 <code>C++</code> 数值线性代数库，更简单、更高效的代码 <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">double</span> prediction = theta.transpose( ) * x;</span><br></pre></td></tr></table></figure></p>
<ol type="1">
<li><a href="https://blog.csdn.net/u010976453/article/details/54381248">机器学习中的线性代数之矩阵求导</a></li>
<li><a href="https://blog.csdn.net/u014628146/article/details/90105826">矩阵转置基本性质</a></li>
<li><a href="https://blog.csdn.net/CxC2333/article/details/108740970">常见的二范数是什么意思？有什么用?</a></li>
</ol>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
  </entry>
  <entry>
    <title>RL介绍</title>
    <url>/2022/10/15/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/03RL/02RL%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<h2 id="强化学习-reinforcement-learning"><strong>强化学习 Reinforcement Learning</strong></h2>
<p>声明：以下课件来源于 <strong><em>北京邮电大学人工智能学院鲁鹏老师</em></strong></p>
<p><a href="https://imgse.com/i/xQ3EJx"><img src="https://s1.ax1x.com/2022/10/03/xQ3EJx.png" alt="xQ3EJx.png"></a></p>
<h3 id="机器学习分支">机器学习分支</h3>
<p><a href="https://imgse.com/i/xQ3MeH"><img src="https://s1.ax1x.com/2022/10/03/xQ3MeH.png" alt="xQ3MeH.png"></a> <a href="https://imgse.com/i/xQ3AF1"><img src="https://s1.ax1x.com/2022/10/03/xQ3AF1.png" alt="xQ3AF1.png"></a></p>
<h3 id="强化学习特点">强化学习特点</h3>
<p><a href="https://imgse.com/i/xQ3PeJ"><img src="https://s1.ax1x.com/2022/10/03/xQ3PeJ.png" alt="xQ3PeJ.png"></a></p>
<h3 id="reward"><strong>2. Reward</strong></h3>
<p><a href="https://imgse.com/i/xQ3FoR"><img src="https://s1.ax1x.com/2022/10/03/xQ3FoR.png" alt="xQ3FoR.png"></a> <a href="https://imgse.com/i/xQ3iw9"><img src="https://s1.ax1x.com/2022/10/03/xQ3iw9.png" alt="xQ3iw9.png"></a> <a href="https://imgse.com/i/xQ3VW6"><img src="https://s1.ax1x.com/2022/10/03/xQ3VW6.png" alt="xQ3VW6.png"></a> <a href="https://imgse.com/i/xQ3eSK"><img src="https://s1.ax1x.com/2022/10/03/xQ3eSK.png" alt="xQ3eSK.png"></a> <a href="https://imgse.com/i/xQ3mQO"><img src="https://s1.ax1x.com/2022/10/03/xQ3mQO.png" alt="xQ3mQO.png"></a> <a href="https://imgse.com/i/xQ3nyD"><img src="https://s1.ax1x.com/2022/10/03/xQ3nyD.png" alt="xQ3nyD.png"></a> <a href="https://imgse.com/i/xQ3uOe"><img src="https://s1.ax1x.com/2022/10/03/xQ3uOe.png" alt="xQ3uOe.png"></a> <a href="https://imgse.com/i/xQ3Qwd"><img src="https://s1.ax1x.com/2022/10/03/xQ3Qwd.png" alt="xQ3Qwd.png"></a> <a href="https://imgse.com/i/xQ3lTA"><img src="https://s1.ax1x.com/2022/10/03/xQ3lTA.png" alt="xQ3lTA.png"></a> <a href="https://imgse.com/i/xQ38Yt"><img src="https://s1.ax1x.com/2022/10/03/xQ38Yt.png" alt="xQ38Yt.png"></a> <a href="https://imgse.com/i/xQ3YSf"><img src="https://s1.ax1x.com/2022/10/03/xQ3YSf.png" alt="xQ3YSf.png"></a> <a href="https://imgse.com/i/xQ33FI"><img src="https://s1.ax1x.com/2022/10/03/xQ33FI.png" alt="xQ33FI.png"></a> <a href="https://imgse.com/i/xQ3GfP"><img src="https://s1.ax1x.com/2022/10/03/xQ3GfP.png" alt="xQ3GfP.png"></a> <a href="https://imgse.com/i/xQ3N6S"><img src="https://s1.ax1x.com/2022/10/03/xQ3N6S.png" alt="xQ3N6S.png"></a></p>
<p><a href="https://imgse.com/i/xQ3tl8"><img src="https://s1.ax1x.com/2022/10/03/xQ3tl8.png" alt="xQ3tl8.png"></a> <a href="https://imgse.com/i/xQ3UOg"><img src="https://s1.ax1x.com/2022/10/03/xQ3UOg.png" alt="xQ3UOg.png"></a></p>
<p><a href="https://imgse.com/i/xQ3sf0"><img src="https://s1.ax1x.com/2022/10/03/xQ3sf0.png" alt="xQ3sf0.png"></a> <a href="https://imgse.com/i/xQ30Ts"><img src="https://s1.ax1x.com/2022/10/03/xQ30Ts.png" alt="xQ30Ts.png"></a> <a href="https://imgse.com/i/xQ3rYq"><img src="https://s1.ax1x.com/2022/10/03/xQ3rYq.png" alt="xQ3rYq.png"></a> <a href="https://imgse.com/i/xQ3Dkn"><img src="https://s1.ax1x.com/2022/10/03/xQ3Dkn.png" alt="xQ3Dkn.png"></a> <a href="https://imgse.com/i/xQ3clT"><img src="https://s1.ax1x.com/2022/10/03/xQ3clT.png" alt="xQ3clT.png"></a> <a href="https://imgse.com/i/xQ32XF"><img src="https://s1.ax1x.com/2022/10/03/xQ32XF.png" alt="xQ32XF.png"></a> <a href="https://imgse.com/i/xQ3g6U"><img src="https://s1.ax1x.com/2022/10/03/xQ3g6U.png" alt="xQ3g6U.png"></a> <a href="https://imgse.com/i/xQ3Wm4"><img src="https://s1.ax1x.com/2022/10/03/xQ3Wm4.png" alt="xQ3Wm4.png"></a> <a href="https://imgse.com/i/xQ3h79"><img src="https://s1.ax1x.com/2022/10/03/xQ3h79.png" alt="xQ3h79.png"></a> <a href="https://imgse.com/i/xQ35kR"><img src="https://s1.ax1x.com/2022/10/03/xQ35kR.png" alt="xQ35kR.png"></a></p>
<p><a href="https://imgse.com/i/xlsQZn"><img src="https://s1.ax1x.com/2022/10/05/xlsQZn.png" alt="xlsQZn.png"></a> <a href="https://imgse.com/i/xlslaq"><img src="https://s1.ax1x.com/2022/10/05/xlslaq.png" alt="xlslaq.png"></a> <a href="https://imgse.com/i/xls1I0"><img src="https://s1.ax1x.com/2022/10/05/xls1I0.png" alt="xls1I0.png"></a> <a href="https://imgse.com/i/xlsGGT"><img src="https://s1.ax1x.com/2022/10/05/xlsGGT.png" alt="xlsGGT.png"></a> <a href="https://imgse.com/i/xls8iV"><img src="https://s1.ax1x.com/2022/10/05/xls8iV.png" alt="xls8iV.png"></a> <a href="https://imgse.com/i/xlsJRU"><img src="https://s1.ax1x.com/2022/10/05/xlsJRU.png" alt="xlsJRU.png"></a> <a href="https://imgse.com/i/xlsYzF"><img src="https://s1.ax1x.com/2022/10/05/xlsYzF.png" alt="xlsYzF.png"></a> <a href="https://imgse.com/i/xlsUsJ"><img src="https://s1.ax1x.com/2022/10/05/xlsUsJ.png" alt="xlsUsJ.png"></a> <a href="https://imgse.com/i/xlsNM4"><img src="https://s1.ax1x.com/2022/10/05/xlsNM4.png" alt="xlsNM4.png"></a> <a href="https://imgse.com/i/xlsaL9"><img src="https://s1.ax1x.com/2022/10/05/xlsaL9.png" alt="xlsaL9.png"></a> <a href="https://imgse.com/i/xlswZR"><img src="https://s1.ax1x.com/2022/10/05/xlswZR.png" alt="xlswZR.png"></a> <a href="https://imgse.com/i/xls0d1"><img src="https://s1.ax1x.com/2022/10/05/xls0d1.png" alt="xls0d1.png"></a> <a href="https://imgse.com/i/xlsBIx"><img src="https://s1.ax1x.com/2022/10/05/xlsBIx.png" alt="xlsBIx.png"></a></p>
]]></content>
      <categories>
        <category>强化学习</category>
      </categories>
  </entry>
  <entry>
    <title>CNN</title>
    <url>/2022/10/16/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/05DL/CNN/</url>
    <content><![CDATA[<h2 id="cnn">CNN</h2>
<p>如果用全连接神经网络处理大尺寸图像具有三个明显的缺点：</p>
<p>（1）首先将图像展开为向量会丢失空间信息； （2）其次参数过多效率低下，训练困难； （3）同时大量的参数也很快会导致网络过拟合。</p>
<p>而使用卷积神经网络可以很好地解决上面的三个问题。</p>
<p>与常规神经网络不同，卷积神经网络的各层中的神经元是 <code>3</code> 维排列的：宽度、高度和深度。其中的宽度和高度是很好理解的，因为本身卷积就是一个二维模板，但是在卷积神经网络中的深度指的是 <strong>激活数据体</strong> 的第三个维度，而不是整个网络的深度，<strong>整个网络的深度指的是网络的层数。</strong></p>
<p>举个例子来理解什么是宽度，高度和深度，假如使用CIFAR-10中的图像是作为卷积神经网络的输入，该 <strong>输入数据体</strong> 的维度是32x32x3（宽度，高度和深度）。<strong>我们将看到，层中的神经元将只与前一层中的一小块区域连接，而不是采取全连接方式。</strong> 对于用来分类CIFAR-10中的图像的卷积网络，其最后的输出层的维度是1x1x10，因为在卷积神经网络结构的最后部分将会把全尺寸的图像压缩为包含分类评分的一个向量，<strong>向量是在深度方向排列的</strong>。</p>
<p>卷积神经网络利用输入是图片的特点，把神经元设计成三个维度 ： <code>width, height, depth (height * width * channel</code> ) (注意这个 <code>depth</code> 不是神经网络的深度，而是用来描述神经元的) 。比如输入的图片大小是 <code>32 × 32 × 3 (rgb)</code>，那么输入神经元就也具有 <code>32×32×3</code> 的维度。下面是图解</p>
<p><img src="https://img-blog.csdn.net/20160404000318630"></p>
<p><a href="https://imgse.com/i/xG2vMq"><img src="https://s1.ax1x.com/2022/10/08/xG2vMq.png" alt="xG2vMq.png"></a></p>
<p>我的理解是卷积核就相当于神经元，但这个神经元是局部连接的，就是说一个神经元/卷积核只接受卷积核尺寸大小的数据输入，对输入的数据通过卷积核内的权重和偏置进行一次卷积运算，得到一个输出值，通过多次移动便得到了一层激活层的输出。权值共享的意思也就是这个神经元/卷积核在移动中用的是同一组权重和偏置</p>
<h3 id="卷积神经网络能干什么">卷积神经网络能干什么</h3>
<p><a href="https://imgse.com/i/xGRpZT"><img src="https://s1.ax1x.com/2022/10/08/xGRpZT.png" alt="xGRpZT.png"></a> <a href="https://imgse.com/i/xGRii4"><img src="https://s1.ax1x.com/2022/10/08/xGRii4.png" alt="xGRii4.png"></a> <a href="https://imgse.com/i/xG2zLV"><img src="https://s1.ax1x.com/2022/10/08/xG2zLV.png" alt="xG2zLV.png"></a> <a href="https://imgse.com/i/xG2xs0"><img src="https://s1.ax1x.com/2022/10/08/xG2xs0.png" alt="xG2xs0.png"></a> <a href="https://imgse.com/i/xGRkW9"><img src="https://s1.ax1x.com/2022/10/08/xGRkW9.png" alt="xGRkW9.png"></a></p>
<h2 id="卷积神经网络架构">卷积神经网络架构</h2>
<p><a href="https://imgse.com/i/xGR9dU"><img src="https://s1.ax1x.com/2022/10/08/xGR9dU.png" alt="xGR9dU.png"></a> <a href="https://imgse.com/i/xGRCoF"><img src="https://s1.ax1x.com/2022/10/08/xGRCoF.png" alt="xGRCoF.png"></a> <a href="https://imgse.com/i/xGRFJJ"><img src="https://s1.ax1x.com/2022/10/08/xGRFJJ.png" alt="xGRFJJ.png"></a> <a href="https://imgse.com/i/xGRAzR"><img src="https://s1.ax1x.com/2022/10/08/xGRAzR.png" alt="xGRAzR.png"></a> <a href="https://imgse.com/i/xGRVQ1"><img src="https://s1.ax1x.com/2022/10/08/xGRVQ1.png" alt="xGRVQ1.png"></a></p>
<ul>
<li>红→蓝，<code>6</code> 是代表 <code>6</code> 个卷积核，每个卷积核是 <code>5×5×3</code>，得到的 <code>28×28×6</code></li>
<li>蓝→绿， <code>10</code> 是代表 <code>10</code> 个卷积核，每个卷积核是 <code>5×5×6</code></li>
</ul>
<p><a href="https://imgse.com/i/xGRQFe"><img src="https://s1.ax1x.com/2022/10/08/xGRQFe.png" alt="xGRQFe.png"></a></p>
<h3 id="卷积">卷积</h3>
<ul>
<li>卷积核可以拥有多个</li>
<li>每个子区域使用相同的卷积核 <strong>（卷积参数共享）</strong></li>
</ul>
<p><a href="https://imgse.com/i/xGRNef"><img src="https://s1.ax1x.com/2022/10/08/xGRNef.png" alt="xGRNef.png"></a> <a href="https://imgse.com/i/xGRZsx"><img src="https://s1.ax1x.com/2022/10/08/xGRZsx.png" alt="xGRZsx.png"></a></p>
<p><a href="https://imgse.com/i/xGRneK"><img src="https://s1.ax1x.com/2022/10/08/xGRneK.png" alt="xGRneK.png"></a></p>
<p><a href="https://imgse.com/i/xGRudO"><img src="https://s1.ax1x.com/2022/10/08/xGRudO.png" alt="xGRudO.png"></a></p>
<p><a href="https://imgse.com/i/xGR1Wd"><img src="https://s1.ax1x.com/2022/10/08/xGR1Wd.png" alt="xGR1Wd.png"></a></p>
<h3 id="卷积层参数">卷积层参数</h3>
<p><a href="https://imgse.com/i/xGRKoD"><img src="https://s1.ax1x.com/2022/10/08/xGRKoD.png" alt="xGRKoD.png"></a></p>
<p><strong>1. 滑动窗口步长</strong> <a href="https://imgse.com/i/xGReL6"><img src="https://s1.ax1x.com/2022/10/08/xGReL6.png" alt="xGReL6.png"></a></p>
<p><strong>2. 卷积核尺寸</strong> - 一般<code>3*3</code>，尺寸越大，特征提取越粗糙，尺寸越小，特征提取越细腻。</p>
<p><strong>3. 边缘填充 padding</strong></p>
<ul>
<li>越往边界的点，能被利用的次数越少；越往中间的点，能被利用的次数越多。<code>padding</code> 一定程度上弥补了边界信息缺失的问题，加上一圈 <code>0</code> ，能够使得边缘特征充分的被利用。</li>
</ul>
<p><a href="https://imgse.com/i/xGRQFe"><img src="https://s1.ax1x.com/2022/10/08/xGRQFe.png" alt="xGRQFe.png"></a> <a href="https://imgse.com/i/xGRlJH"><img src="https://s1.ax1x.com/2022/10/08/xGRlJH.png" alt="xGRlJH.png"></a></p>
<h3 id="pooling">pooling</h3>
<p><a href="https://imgse.com/i/xGR8SA"><img src="https://s1.ax1x.com/2022/10/08/xGR8SA.png" alt="xGR8SA.png"></a></p>
<ul>
<li>特征图个数不会变，只是去变长和宽。<code>pooling</code> 不涉及任何矩阵的计算</li>
<li>最大 <code>pooling</code>，在神经网络中，一般认为值越大，特征越明显</li>
</ul>
<p><a href="https://imgse.com/i/xGRGQI"><img src="https://s1.ax1x.com/2022/10/08/xGRGQI.png" alt="xGRGQI.png"></a></p>
<p><a href="https://imgse.com/i/xGRJyt"><img src="https://s1.ax1x.com/2022/10/08/xGRJyt.png" alt="xGRJyt.png"></a></p>
<h3 id="经典卷积神经网络">经典卷积神经网络</h3>
<ul>
<li><strong>带参数计算</strong> 的才能被叫做 <strong>层</strong></li>
<li>深度学习，用更深的网络结构去提取原始图像中的特征</li>
<li>分类还是回归，取决于损失函数和层如何连接</li>
</ul>
<p><a href="https://imgse.com/i/xGRaTS"><img src="https://s1.ax1x.com/2022/10/08/xGRaTS.png" alt="xGRaTS.png"></a></p>
<p><a href="https://imgse.com/i/xGRUw8"><img src="https://s1.ax1x.com/2022/10/08/xGRUw8.png" alt="xGRUw8.png"></a> <a href="https://imgse.com/i/xGRYOP"><img src="https://s1.ax1x.com/2022/10/08/xGRYOP.png" alt="xGRYOP.png"></a> <a href="https://imgse.com/i/xGRwFg"><img src="https://s1.ax1x.com/2022/10/08/xGRwFg.png" alt="xGRwFg.png"></a></p>
<h3 id="感受野">感受野</h3>
<p><a href="https://imgse.com/i/xGR0YQ"><img src="https://s1.ax1x.com/2022/10/08/xGR0YQ.png" alt="xGR0YQ.png"></a> <a href="https://imgse.com/i/xGRBWj"><img src="https://s1.ax1x.com/2022/10/08/xGRBWj.png" alt="xGRBWj.png"></a></p>
]]></content>
      <categories>
        <category>深度学习</category>
      </categories>
      <tags>
        <tag>CNN</tag>
      </tags>
  </entry>
  <entry>
    <title>线性回归.md</title>
    <url>/2022/10/20/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/2.LinearRegression/</url>
    <content><![CDATA[<h1 id="线性回归">线性回归</h1>
<p>假设数据集为： <span class="math display">\[
\mathcal{D}=\{(x_1, y_1),(x_2, y_2),\cdots,(x_N, y_N)\}
\]</span> 后面我们记： <span class="math display">\[
X=(x_1,x_2,\cdots,x_N)^T,Y=(y_1,y_2,\cdots,y_N)^T
\]</span> 线性回归假设： <span class="math display">\[
f(w)=w^Tx
\]</span></p>
<h2 id="最小二乘法">最小二乘法</h2>
<p>对这个问题，采用二范数定义的平方误差来定义损失函数： <span class="math display">\[
L(w)=\sum\limits_{i=1}^N||w^Tx_i-y_i||^2_2
\]</span> 展开得到： <span class="math display">\[
\begin{align}
L(w)&amp;=(w^Tx_1-y_1,\cdots,w^Tx_N-y_N)\cdot (w^Tx_1-y_1,\cdots,w^Tx_N-y_N)^T\nonumber\\
&amp;=(w^TX^T-Y^T)\cdot (Xw-Y)=w^TX^TXw-Y^TXw-w^TX^TY+Y^TY\nonumber\\
&amp;=w^TX^TXw-2w^TX^TY+Y^TY
\end{align}
\]</span> 最小化这个值的 $ $ ： <span class="math display">\[
\begin{align}
\hat{w}=\mathop{argmin}\limits_wL(w)&amp;\longrightarrow\frac{\partial}{\partial w}L(w)=0\nonumber\\
&amp;\longrightarrow2X^TX\hat{w}-2X^TY=0\nonumber\\
&amp;\longrightarrow \hat{w}=(X^TX)^{-1}X^TY=X^+Y
\end{align}
\]</span> 这个式子中 <span class="math inline">\((X^TX)^{-1}X^T\)</span> 又被称为伪逆。对于行满秩或者列满秩的 <span class="math inline">\(X\)</span>，可以直接求解，但是对于非满秩的样本集合，需要使用奇异值分解（SVD）的方法，对 <span class="math inline">\(X\)</span> 求奇异值分解，得到 <span class="math display">\[
X=U\Sigma V^T
\]</span> 于是： <span class="math display">\[
X^+=V\Sigma^{-1}U^T
\]</span> 在几何上，最小二乘法相当于模型（这里就是直线）和试验值的距离的平方求和，假设我们的试验样本张成一个 <span class="math inline">\(p\)</span> 维空间（满秩的情况）：<span class="math inline">\(X=Span(x_1,\cdots,x_N)\)</span>，而模型可以写成 <span class="math inline">\(f(w)=X\beta\)</span>，也就是 <span class="math inline">\(x_1,\cdots,x_N\)</span> 的某种组合，而最小二乘法就是说希望 <span class="math inline">\(Y\)</span> 和这个模型距离越小越好，于是它们的差应该与这个张成的空间垂直： <span class="math display">\[
X^T\cdot(Y-X\beta)=0\longrightarrow\beta=(X^TX)^{-1}X^TY
\]</span></p>
<h2 id="噪声为高斯分布的-mle">噪声为高斯分布的 MLE</h2>
<p>对于一维的情况，记 <span class="math inline">\(y=w^Tx+\epsilon,\epsilon\sim\mathcal{N}(0,\sigma^2)\)</span>，那么 <span class="math inline">\(y\sim\mathcal{N}(w^Tx,\sigma^2)\)</span>。代入极大似然估计中： <span class="math display">\[
\begin{align}
L(w)=\log p(Y|X,w)&amp;=\log\prod\limits_{i=1}^Np(y_i|x_i,w)\nonumber\\
&amp;=\sum\limits_{i=1}^N\log(\frac{1}{\sqrt{2\pi\sigma}}e^{-\frac{(y_i-w^Tx_i)^2}{2\sigma^2}})\\
\mathop{argmax}\limits_wL(w)&amp;=\mathop{argmin}\limits_w\sum\limits_{i=1^N}(y_i-w^Tx_i)^2
\end{align}
\]</span> 这个表达式和最小二乘估计得到的结果一样。</p>
<h2 id="权重先验也为高斯分布的-map">权重先验也为高斯分布的 MAP</h2>
<p>取先验分布 <span class="math inline">\(w\sim\mathcal{N}(0,\sigma_0^2)\)</span>。于是：  <span class="math display">\[
\begin{align}
\hat{w}=\mathop{argmax}\limits_wp(w|Y)&amp;=\mathop{argmax}\limits_wp(Y|w)p(w)\nonumber\\
&amp;=\mathop{argmax}\limits_w\log p(Y|w)p(w)\nonumber\\
&amp;=\mathop{argmax}\limits_w(\log p(Y|w)+\log p(w))\nonumber\\
&amp;=\mathop{argmin}\limits_w[(y-w^Tx)^2+\frac{\sigma^2}{\sigma_0^2}w^Tw]
\end{align}
\]</span> 这里省略了 <span class="math inline">\(X\)</span>，<span class="math inline">\(p(Y)\)</span>和 <span class="math inline">\(w\)</span> 没有关系，同时也利用了上面高斯分布的 MLE的结果。</p>
<p>我们将会看到，超参数 <span class="math inline">\(\sigma_0\)</span>的存在和下面会介绍的 Ridge 正则项可以对应，同样的如果将先验分布取为 Laplace 分布，那么就会得到和 L1 正则类似的结果。</p>
<h2 id="正则化">正则化</h2>
<p>在实际应用时，如果样本容量不远远大于样本的特征维度，很可能造成过拟合，对这种情况，我们有下面三个解决方式：</p>
<ol type="1">
<li>加数据</li>
<li>特征选择（降低特征维度）如 PCA 算法。</li>
<li>正则化</li>
</ol>
<p>正则化一般是在损失函数（如上面介绍的最小二乘损失）上加入正则化项（表示模型的复杂度对模型的惩罚），下面我们介绍一般情况下的两种正则化框架。 <span class="math display">\[
\begin{align}
L1&amp;:\mathop{argmin}\limits_wL(w)+\lambda||w||_1,\lambda\gt0\\
L2&amp;:\mathop{argmin}\limits_wL(w)+\lambda||w||^2_2,\lambda \gt 0
\end{align}
\]</span> 下面对最小二乘误差分别分析这两者的区别。</p>
<h3 id="l1-lasso">L1 Lasso</h3>
<p>L1正则化可以引起稀疏解。</p>
<p>从最小化损失的角度看，由于 L1 项求导在0附近的左右导数都不是0，因此更容易取到0解。</p>
<p>从另一个方面看，L1 正则化相当于： <span class="math display">\[
\mathop{argmin}\limits_wL(w)\\
s.t. ||w||_1\lt C
\]</span> 我们已经看到平方误差损失函数在 <span class="math inline">\(w\)</span> 空间是一个椭球，因此上式求解就是椭球和 <span class="math inline">\(||w||_1=C\)</span>的切点，因此更容易相切在坐标轴上。</p>
<h3 id="l2-ridge">L2 Ridge</h3>
<p><span class="math display">\[
\begin{align}
\hat{w}=\mathop{argmin}\limits_wL(w)+\lambda w^Tw&amp;\longrightarrow\frac{\partial}{\partial w}L(w)+2\lambda w=0\nonumber\\
&amp;\longrightarrow2X^TX\hat{w}-2X^TY+2\lambda \hat w=0\nonumber\\
&amp;\longrightarrow \hat{w}=(X^TX+\lambda \mathbb{I})^{-1}X^TY
\end{align}
\]</span></p>
<p>可以看到，这个正则化参数和前面的 MAP 结果不谋而合。利用2范数进行正则化不仅可以是模型选择 <span class="math inline">\(w\)</span> 较小的参数，同时也避免 $ X^TX$不可逆的问题。</p>
<h2 id="小结">小结</h2>
<p>线性回归模型是最简单的模型，但是麻雀虽小，五脏俱全，在这里，我们利用最小二乘误差得到了闭式解。同时也发现，在噪声为高斯分布的时候，MLE 的解等价于最小二乘误差，而增加了正则项后，最小二乘误差加上 L2 正则项等价于高斯噪声先验下的 MAP解，加上 L1 正则项后，等价于 Laplace 噪声先验。</p>
<p>传统的机器学习方法或多或少都有线性回归模型的影子：</p>
<ol type="1">
<li>线性模型往往不能很好地拟合数据，因此有三种方案克服这一劣势：
<ol type="1">
<li>对特征的维数进行变换，例如多项式回归模型就是在线性特征的基础上加入高次项。</li>
<li>在线性方程后面加入一个非线性变换，即引入一个非线性的激活函数，典型的有线性分类模型如感知机。</li>
<li>对于一致的线性系数，我们进行多次变换，这样同一个特征不仅仅被单个系数影响，例如多层感知机（深度前馈网络）。</li>
</ol></li>
<li>线性回归在整个样本空间都是线性的，我们修改这个限制，在不同区域引入不同的线性或非线性，例如线性样条回归和决策树模型。</li>
<li>线性回归中使用了所有的样本，但是对数据预先进行加工学习的效果可能更好（所谓的维数灾难，高维度数据更难学习），例如 PCA 算法和流形学习。</li>
</ol>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
  </entry>
  <entry>
    <title>Intro_Math.md</title>
    <url>/2022/10/20/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/1.Intro_Math/</url>
    <content><![CDATA[<h1 id="introduction">Introduction</h1>
<p>对概率的诠释有两大学派，一种是频率派另一种是贝叶斯派。后面我们对观测集采用下面记号： <span class="math display">\[
X_{N\times p}=(x_{1},x_{2},\cdots,x_{N})^{T},x_{i}=(x_{i1},x_{i2},\cdots,x_{ip})^{T}
\]</span> 这个记号表示有 <span class="math inline">\(N\)</span> 个样本，每个样本都是 <span class="math inline">\(p\)</span> 维向量。其中每个观测都是由 <span class="math inline">\(p(x|\theta)\)</span> 生成的。</p>
<h2 id="频率派的观点">频率派的观点</h2>
<p><span class="math inline">\(p(x|\theta)\)</span>中的 <span class="math inline">\(\theta\)</span> 是一个常量。对于 <span class="math inline">\(N\)</span> 个观测来说观测集的概率为 <span class="math inline">\(p(X|\theta)\mathop{=}\limits _{iid}\prod\limits _{i=1}^{N}p(x_{i}|\theta))\)</span> 。为了求 <span class="math inline">\(\theta\)</span> 的大小，我们采用最大对数似然MLE的方法：</p>
<p><span class="math display">\[
\theta_{MLE}=\mathop{argmax}\limits _{\theta}\log p(X|\theta)\mathop{=}\limits _{iid}\mathop{argmax}\limits _{\theta}\sum\limits _{i=1}^{N}\log p(x_{i}|\theta)
\]</span></p>
<h2 id="贝叶斯派的观点">贝叶斯派的观点</h2>
<p>贝叶斯派认为 <span class="math inline">\(p(x|\theta)\)</span> 中的 <span class="math inline">\(\theta\)</span> 不是一个常量。这个 <span class="math inline">\(\theta\)</span> 满足一个预设的先验的分布 <span class="math inline">\(\theta\sim p(\theta)\)</span> 。于是根据贝叶斯定理依赖观测集参数的后验可以写成：</p>
<p><span class="math display">\[
p(\theta|X)=\frac{p(X|\theta)\cdot p(\theta)}{p(X)}=\frac{p(X|\theta)\cdot p(\theta)}{\int\limits _{\theta}p(X|\theta)\cdot p(\theta)d\theta}
\]</span> 为了求 <span class="math inline">\(\theta\)</span> 的值，我们要最大化这个参数后验MAP：</p>
<p><span class="math display">\[
\theta_{MAP}=\mathop{argmax}\limits _{\theta}p(\theta|X)=\mathop{argmax}\limits _{\theta}p(X|\theta)\cdot p(\theta)
\]</span> 其中第二个等号是由于分母和 <span class="math inline">\(\theta\)</span> 没有关系。求解这个 <span class="math inline">\(\theta\)</span> 值后计算<span class="math inline">\(\frac{p(X|\theta)\cdot p(\theta)}{\int\limits _{\theta}p(X|\theta)\cdot p(\theta)d\theta}\)</span> ，就得到了参数的后验概率。其中 <span class="math inline">\(p(X|\theta)\)</span> 叫似然，是我们的模型分布。得到了参数的后验分布后，我们可以将这个分布用于预测贝叶斯预测： <span class="math display">\[
p(x_{new}|X)=\int\limits _{\theta}p(x_{new}|\theta)\cdot p(\theta|X)d\theta
\]</span> 其中积分中的被乘数是模型，乘数是后验分布。</p>
<h2 id="小结">小结</h2>
<p>频率派和贝叶斯派分别给出了一系列的机器学习算法。频率派的观点导出了一系列的统计机器学习算法而贝叶斯派导出了概率图理论。在应用频率派的 MLE 方法时最优化理论占有重要地位。而贝叶斯派的算法无论是后验概率的建模还是应用这个后验进行推断时积分占有重要地位。因此采样积分方法如 MCMC 有很多应用。</p>
<h1 id="mathbasics">MathBasics</h1>
<h2 id="高斯分布">高斯分布</h2>
<h3 id="一维情况-mle">一维情况 MLE</h3>
<p>高斯分布在机器学习中占有举足轻重的作用。在 MLE 方法中：</p>
<p><span class="math display">\[
\theta=(\mu,\Sigma)=(\mu,\sigma^{2}),\theta_{MLE}=\mathop{argmax}\limits _{\theta}\log p(X|\theta)\mathop{=}\limits _{iid}\mathop{argmax}\limits _{\theta}\sum\limits _{i=1}^{N}\log p(x_{i}|\theta)
\]</span> 一般地，高斯分布的概率密度函数PDF写为：</p>
<p><span class="math display">\[
p(x|\mu,\Sigma)=\frac{1}{(2\pi)^{p/2}|\Sigma|^{1/2}}e^{-\frac{1}{2}(x-\mu)^{T}\Sigma^{-1}(x-\mu)}
\]</span> 带入 MLE 中我们考虑一维的情况</p>
<p><span class="math display">\[
\log p(X|\theta)=\sum\limits _{i=1}^{N}\log p(x_{i}|\theta)=\sum\limits _{i=1}^{N}\log\frac{1}{\sqrt{2\pi}\sigma}\exp(-(x_{i}-\mu)^{2}/2\sigma^{2})
\]</span> 首先对 <span class="math inline">\(\mu\)</span> 的极值可以得到 ： <span class="math display">\[
\mu_{MLE}=\mathop{argmax}\limits _{\mu}\log p(X|\theta)=\mathop{argmax}\limits _{\mu}\sum\limits _{i=1}^{N}(x_{i}-\mu)^{2}
\]</span> 于是： <span class="math display">\[
\frac{\partial}{\partial\mu}\sum\limits _{i=1}^{N}(x_{i}-\mu)^{2}=0\longrightarrow\mu_{MLE}=\frac{1}{N}\sum\limits _{i=1}^{N}x_{i}
\]</span> 其次对 <span class="math inline">\(\theta\)</span> 中的另一个参数 <span class="math inline">\(\sigma\)</span> ，有： <span class="math display">\[
\begin{align}
\sigma_{MLE}=\mathop{argmax}\limits _{\sigma}\log p(X|\theta)&amp;=\mathop{argmax}\limits _{\sigma}\sum\limits _{i=1}^{N}[-\log\sigma-\frac{1}{2\sigma^{2}}(x_{i}-\mu)^{2}]\nonumber\\
&amp;=\mathop{argmin}\limits _{\sigma}\sum\limits _{i=1}^{N}[\log\sigma+\frac{1}{2\sigma^{2}}(x_{i}-\mu)^{2}]
\end{align}
\]</span> 于是： <span class="math display">\[
\frac{\partial}{\partial\sigma}\sum\limits _{i=1}^{N}[\log\sigma+\frac{1}{2\sigma^{2}}(x_{i}-\mu)^{2}]=0\longrightarrow\sigma_{MLE}^{2}=\frac{1}{N}\sum\limits _{i=1}^{N}(x_{i}-\mu)^{2}
\]</span> 值得注意的是，上面的推导中，首先对 <span class="math inline">\(\mu\)</span> 求 MLE， 然后利用这个结果求 <span class="math inline">\(\sigma_{MLE}\)</span> ，因此可以预期的是对数据集求期望时 <span class="math inline">\(\mathbb{E}_{\mathcal{D}}[\mu_{MLE}]\)</span> 是无偏差的： <span class="math display">\[
\mathbb{E}_{\mathcal{D}}[\mu_{MLE}]=\mathbb{E}_{\mathcal{D}}[\frac{1}{N}\sum\limits _{i=1}^{N}x_{i}]=\frac{1}{N}\sum\limits _{i=1}^{N}\mathbb{E}_{\mathcal{D}}[x_{i}]=\mu
\]</span> 但是当对 <span class="math inline">\(\sigma_{MLE}\)</span> 求 期望的时候由于使用了单个数据集的 <span class="math inline">\(\mu_{MLE}\)</span>，因此对所有数据集求期望的时候我们会发现 <span class="math inline">\(\sigma_{MLE}\)</span> 是 有偏的：</p>
<p><span class="math display">\[
\begin{align}
\mathbb{E}_{\mathcal{D}}[\sigma_{MLE}^{2}]&amp;=\mathbb{E}_{\mathcal{D}}[\frac{1}{N}\sum\limits _{i=1}^{N}(x_{i}-\mu_{MLE})^{2}]=\mathbb{E}_{\mathcal{D}}[\frac{1}{N}\sum\limits _{i=1}^{N}(x_{i}^{2}-2x_{i}\mu_{MLE}+\mu_{MLE}^{2})\nonumber
\\&amp;=\mathbb{E}_{\mathcal{D}}[\frac{1}{N}\sum\limits _{i=1}^{N}x_{i}^{2}-\mu_{MLE}^{2}]=\mathbb{E}_{\mathcal{D}}[\frac{1}{N}\sum\limits _{i=1}^{N}x_{i}^{2}-\mu^{2}+\mu^{2}-\mu_{MLE}^{2}]\nonumber\\
&amp;= \mathbb{E}_{\mathcal{D}}[\frac{1}{N}\sum\limits _{i=1}^{N}x_{i}^{2}-\mu^{2}]-\mathbb{E}_{\mathcal{D}}[\mu_{MLE}^{2}-\mu^{2}]=\sigma^{2}-(\mathbb{E}_{\mathcal{D}}[\mu_{MLE}^{2}]-\mu^{2})\nonumber\\&amp;=\sigma^{2}-(\mathbb{E}_{\mathcal{D}}[\mu_{MLE}^{2}]-\mathbb{E}_{\mathcal{D}}^{2}[\mu_{MLE}])=\sigma^{2}-Var[\mu_{MLE}]\nonumber\\&amp;=\sigma^{2}-Var[\frac{1}{N}\sum\limits _{i=1}^{N}x_{i}]=\sigma^{2}-\frac{1}{N^{2}}\sum\limits _{i=1}^{N}Var[x_{i}]=\frac{N-1}{N}\sigma^{2}
\end{align}
\]</span> 所以： <span class="math display">\[
\hat{\sigma}^{2}=\frac{1}{N-1}\sum\limits _{i=1}^{N}(x_{i}-\mu)^{2}
\]</span></p>
<h3 id="多维情况">多维情况</h3>
<p>多维高斯分布表达式为： <span class="math display">\[
p(x|\mu,\Sigma)=\frac{1}{(2\pi)^{p/2}|\Sigma|^{1/2}}e^{-\frac{1}{2}(x-\mu)^{T}\Sigma^{-1}(x-\mu)}
\]</span> 其中 <span class="math inline">\(x,\mu\in\mathbb{R}^{p},\Sigma\in\mathbb{R}^{p\times p}\)</span> ，<span class="math inline">\(\Sigma\)</span> 为协方差矩阵，一般而言也是半正定矩阵。这里我们只考虑正定矩阵。首先我们处理指数上的数字，指数上的数字可以记为 <span class="math inline">\(x\)</span> 和 <span class="math inline">\(\mu\)</span> 之间的马氏距离。对于对称的协方差矩阵可进行特征值分解，<span class="math inline">\(\Sigma=U\Lambda U^{T}=(u_{1},u_{2},\cdots,u_{p})diag(\lambda_{i})(u_{1},u_{2},\cdots,u_{p})^{T}=\sum\limits _{i=1}^{p}u_{i}\lambda_{i}u_{i}^{T}\)</span> ，于是：</p>
<p><span class="math display">\[
\Sigma^{-1}=\sum\limits _{i=1}^{p}u_{i}\frac{1}{\lambda_{i}}u_{i}^{T}
\]</span></p>
<p><span class="math display">\[
\Delta=(x-\mu)^{T}\Sigma^{-1}(x-\mu)=\sum\limits _{i=1}^{p}(x-\mu)^{T}u_{i}\frac{1}{\lambda_{i}}u_{i}^{T}(x-\mu)=\sum\limits _{i=1}^{p}\frac{y_{i}^{2}}{\lambda_{i}}
\]</span></p>
<p>我们注意到 <span class="math inline">\(y_{i}\)</span> 是 <span class="math inline">\(x-\mu\)</span> 在特征向量 <span class="math inline">\(u_{i}\)</span> 上的投影长度，因此上式子就是 <span class="math inline">\(\Delta\)</span> 取不同值时的同心椭圆。</p>
<p>下面我们看多维高斯模型在实际应用时的两个问题</p>
<ol type="1">
<li><p>参数 <span class="math inline">\(\Sigma,\mu\)</span> 的自由度为 <span class="math inline">\(O(p^{2})\)</span> 对于维度很高的数据其自由度太高。解决方案：高自由度的来源是 <span class="math inline">\(\Sigma\)</span> 有 <span class="math inline">\(\frac{p(p+1)}{2}\)</span> 个自由参数，可以假设其是对角矩阵，甚至在各向同性假设中假设其对角线上的元素都相同。前一种的算法有 Factor Analysis，后一种有概率 PCA(p-PCA) 。</p></li>
<li><p>第二个问题是单个高斯分布是单峰的，对有多个峰的数据分布不能得到好的结果。解决方案：高斯混合GMM 模型。</p></li>
</ol>
<p>下面对多维高斯分布的常用定理进行介绍。</p>
<p>我们记 <span class="math inline">\(x=(x_1, x_2,\cdots,x_p)^T=(x_{a,m\times 1}, x_{b,n\times1})^T,\mu=(\mu_{a,m\times1}, \mu_{b,n\times1}),\Sigma=\begin{pmatrix}\Sigma_{aa}&amp;\Sigma_{ab}\\\Sigma_{ba}&amp;\Sigma_{bb}\end{pmatrix}\)</span>，已知 <span class="math inline">\(x\sim\mathcal{N}(\mu,\Sigma)\)</span>。</p>
<p>首先是一个高斯分布的定理：</p>
<blockquote>
<p>定理：已知 <span class="math inline">\(x\sim\mathcal{N}(\mu,\Sigma), y\sim Ax+b\)</span>，那么 <span class="math inline">\(y\sim\mathcal{N}(A\mu+b, A\Sigma A^T)\)</span>。</p>
<p>证明：<span class="math inline">\(\mathbb{E}[y]=\mathbb{E}[Ax+b]=A\mathbb{E}[x]+b=A\mu+b\)</span>，<span class="math inline">\(Var[y]=Var[Ax+b]=Var[Ax]=A\cdot Var[x]\cdot A^T\)</span>。</p>
</blockquote>
<p>下面利用这个定理得到 <span class="math inline">\(p(x_a),p(x_b),p(x_a|x_b),p(x_b|x_a)\)</span> 这四个量。</p>
<ol type="1">
<li><p><span class="math inline">\(x_a=\begin{pmatrix}\mathbb{I}_{m\times m}&amp;\mathbb{O}_{m\times n})\end{pmatrix}\begin{pmatrix}x_a\\x_b\end{pmatrix}\)</span>，代入定理中得到： <span class="math display">\[
\mathbb{E}[x_a]=\begin{pmatrix}\mathbb{I}&amp;\mathbb{O}\end{pmatrix}\begin{pmatrix}\mu_a\\\mu_b\end{pmatrix}=\mu_a\\
Var[x_a]=\begin{pmatrix}\mathbb{I}&amp;\mathbb{O}\end{pmatrix}\begin{pmatrix}\Sigma_{aa}&amp;\Sigma_{ab}\\\Sigma_{ba}&amp;\Sigma_{bb}\end{pmatrix}\begin{pmatrix}\mathbb{I}\\\mathbb{O}\end{pmatrix}=\Sigma_{aa}
\]</span> 所以 <span class="math inline">\(x_a\sim\mathcal{N}(\mu_a,\Sigma_{aa})\)</span>。</p></li>
<li><p>同样的，<span class="math inline">\(x_b\sim\mathcal{N}(\mu_b,\Sigma_{bb})\)</span>。</p></li>
<li><p>对于两个条件概率，我们引入三个量： <span class="math display">\[
x_{b\cdot a}=x_b-\Sigma_{ba}\Sigma_{aa}^{-1}x_a\\
\mu_{b\cdot a}=\mu_b-\Sigma_{ba}\Sigma_{aa}^{-1}\mu_a\\
\Sigma_{bb\cdot a}=\Sigma_{bb}-\Sigma_{ba}\Sigma_{aa}^{-1}\Sigma_{ab}
\]</span> 特别的，最后一个式子叫做 <span class="math inline">\(\Sigma_{bb}\)</span> 的 Schur Complementary。可以看到： <span class="math display">\[
x_{b\cdot a}=\begin{pmatrix}-\Sigma_{ba}\Sigma_{aa}^{-1}&amp;\mathbb{I}_{n\times n}\end{pmatrix}\begin{pmatrix}x_a\\x_b\end{pmatrix}
\]</span> 所以： <span class="math display">\[
\mathbb{E}[x_{b\cdot a}]=\begin{pmatrix}-\Sigma_{ba}\Sigma_{aa}^{-1}&amp;\mathbb{I}_{n\times n}\end{pmatrix}\begin{pmatrix}\mu_a\\\mu_b\end{pmatrix}=\mu_{b\cdot a}\\
Var[x_{b\cdot a}]=\begin{pmatrix}-\Sigma_{ba}\Sigma_{aa}^{-1}&amp;\mathbb{I}_{n\times n}\end{pmatrix}\begin{pmatrix}\Sigma_{aa}&amp;\Sigma_{ab}\\\Sigma_{ba}&amp;\Sigma_{bb}\end{pmatrix}\begin{pmatrix}-\Sigma_{aa}^{-1}\Sigma_{ba}^T\\\mathbb{I}_{n\times n}\end{pmatrix}=\Sigma_{bb\cdot a}
\]</span> 利用这三个量可以得到 <span class="math inline">\(x_b=x_{b\cdot a}+\Sigma_{ba}\Sigma_{aa}^{-1}x_a\)</span>。因此： <span class="math display">\[
\mathbb{E}[x_b|x_a]=\mu_{b\cdot a}+\Sigma_{ba}\Sigma_{aa}^{-1}x_a
\]</span></p>
<p><span class="math display">\[
Var[x_b|x_a]=\Sigma_{bb\cdot a}
\]</span></p>
<p>这里同样用到了定理。</p></li>
<li><p>同样： <span class="math display">\[
x_{a\cdot b}=x_a-\Sigma_{ab}\Sigma_{bb}^{-1}x_b\\
\mu_{a\cdot b}=\mu_a-\Sigma_{ab}\Sigma_{bb}^{-1}\mu_b\\
\Sigma_{aa\cdot b}=\Sigma_{aa}-\Sigma_{ab}\Sigma_{bb}^{-1}\Sigma_{ba}
\]</span> 所以： <span class="math display">\[
\mathbb{E}[x_a|x_b]=\mu_{a\cdot b}+\Sigma_{ab}\Sigma_{bb}^{-1}x_b
\]</span></p>
<p><span class="math display">\[
Var[x_a|x_b]=\Sigma_{aa\cdot b}
\]</span></p></li>
</ol>
<p>下面利用上边四个量，求解线性模型：</p>
<blockquote>
<p>已知：<span class="math inline">\(p(x)=\mathcal{N}(\mu,\Lambda^{-1}),p(y|x)=\mathcal{N}(Ax+b,L^{-1})\)</span>，求解：<span class="math inline">\(p(y),p(x|y)\)</span>。</p>
<p>解：令 <span class="math inline">\(y=Ax+b+\epsilon,\epsilon\sim\mathcal{N}(0,L^{-1})\)</span>，所以 <span class="math inline">\(\mathbb{E}[y]=\mathbb{E}[Ax+b+\epsilon]=A\mu+b\)</span>，<span class="math inline">\(Var[y]=A \Lambda^{-1}A^T+L^{-1}\)</span>，因此： <span class="math display">\[
  p(y)=\mathcal{N}(A\mu+b,L^{-1}+A\Lambda^{-1}A^T)
  \]</span> 引入 <span class="math inline">\(z=\begin{pmatrix}x\\y\end{pmatrix}\)</span>，我们可以得到 <span class="math inline">\(Cov[x,y]=\mathbb{E}[(x-\mathbb{E}[x])(y-\mathbb{E}[y])^T]\)</span>。对于这个协方差可以直接计算： <span class="math display">\[
  \begin{align}
  Cov(x,y)&amp;=\mathbb{E}[(x-\mu)(Ax-A\mu+\epsilon)^T]=\mathbb{E}[(x-\mu)(x-\mu)^TA^T]=Var[x]A^T=\Lambda^{-1}A^T
  \end{align}
  \]</span> 注意到协方差矩阵的对称性，所以 <span class="math inline">\(p(z)=\mathcal{N}\begin{pmatrix}\mu\\A\mu+b\end{pmatrix},\begin{pmatrix}\Lambda^{-1}&amp;\Lambda^{-1}A^T\\A\Lambda^{-1}&amp;L^{-1}+A\Lambda^{-1}A^T\end{pmatrix})\)</span>。根据之前的公式，我们可以得到： <span class="math display">\[
  \mathbb{E}[x|y]=\mu+\Lambda^{-1}A^T(L^{-1}+A\Lambda^{-1}A^T)^{-1}(y-A\mu-b)
  \]</span></p>
<p><span class="math display">\[
  Var[x|y]=\Lambda^{-1}-\Lambda^{-1}A^T(L^{-1}+A\Lambda^{-1}A^T)^{-1}A\Lambda^{-1}
  \]</span></p>
</blockquote>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
  </entry>
  <entry>
    <title>工艺流程</title>
    <url>/2022/11/08/%E6%99%B6%E4%BD%93%E7%AE%A1/%E5%B7%A5%E8%89%BA%E6%B5%81%E7%A8%8B/</url>
    <content><![CDATA[<ol type="1">
<li><a href="https://zhuanlan.zhihu.com/p/487910080">揭秘芯片制造：八个步骤，数百个工艺 - 知乎 (zhihu.com)</a></li>
<li><a href="https://www.thepaper.cn/newsDetail_forward_13166836">芯片制造的10个关键步骤_澎湃号·政务_澎湃新闻-The Paper</a></li>
<li><a href="https://blog.csdn.net/b18821622297/article/details/120061624">CMOS芯片制造全工艺流程（后端基础第一篇）_IC后端小白的博客-CSDN博客_cmos芯片</a></li>
<li></li>
</ol>
]]></content>
      <categories>
        <category>硬件</category>
      </categories>
  </entry>
  <entry>
    <title>Back Propagation</title>
    <url>/2022/10/21/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/BP/</url>
    <content><![CDATA[

	<div class="row">
    <embed src="BP.pdf" width="100%" height="550" type="application/pdf">
	</div>



<!-- 

	<div class="row">
    <embed src="https://cloud.tsinghua.edu.cn/f/952edbd1e02d409cbd01/" width="100%" height="550" type="application/pdf">
	</div>



<p>--&gt;</p>
<!-- <iframe src="BP.pdf" width="800px" height="800px" frameborder="0" scrolling="no"></iframe> -->
<h2 id="梯度下降">梯度下降</h2>
<ol type="1">
<li><a href="https://blog.csdn.net/qq_41800366/article/details/86583789">梯度下降算法原理讲解——机器学习_zhangpaopao0609的博客-CSDN博客_梯度下降</a></li>
</ol>
<p><a href="https://so.csdn.net/so/search?q=梯度下降&amp;spm=1001.2101.3001.7020">梯度下降</a>（gradient descent）在机器学习中应用十分的广泛，不论是在线性回归还是Logistic回归中，它的主要目的是通过迭代找到目标函数的最小值，或者收敛到最小值。</p>
<h3 id="思想">思想</h3>
<p><strong>梯度下降法的基本思想可以类比为一个下山的过程。</strong> 假设这样一个场景：一个人被困在山上，需要从山上下来(找到山的最低点，也就是山谷)。但此时山上的浓雾很大，导致可视度很低；因此，下山的路径就无法确定，必须利用自己周围的信息一步一步地找到下山的路。这个时候，便可利用梯度下降算法来帮助自己下山。怎么做呢，<strong>首先以他当前的所处的位置为基准，寻找这个位置最陡峭的地方，然后朝着下降方向走一步，然后又继续以当前位置为基准，再找最陡峭的地方，再走直到最后到达最低处；同理上山也是如此，只是这时候就变成梯度上升算法了。</strong></p>
<p>梯度下降的基本过程就和下山的场景很类似。</p>
<p>首先，我们有一个可微分的函数。这个函数就代表着一座山。我们的目标就是找到这个函数的最小值，也就是山底。根据之前的场景假设，最快的下山的方式就是找到当前位置最陡峭的方向，然后沿着此方向向下走，对应到函数中，就是找到给定点的梯度 ，然后朝着梯度相反的方向，就能让函数值下降的最快！<strong>因为梯度的方向就是函数之变化最快的方向。</strong></p>
<h3 id="数学表示">数学表示</h3>
<p><span class="math display">\[Θ^1=Θ^0+α▽J(Θ)→ evaluated at Θ^0\]</span></p>
<p><img src="https://img-blog.csdnimg.cn/20190121203434245.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxODAwMzY2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom:67%;"></p>
<p>此公式的意义是：<span class="math inline">\(J\)</span>是关于<span class="math inline">\(Θ\)</span>的一个函数，我们当前所处的位置为<span class="math inline">\(Θ^0\)</span>点，要从这个点走到J的最小值点，也就是山底。首先我们先确定前进的方向，也就是梯度的反向，然后走一段距离的步长，也就是<span class="math inline">\(α\)</span>，走完这个段步长，就到达了<span class="math inline">\(Θ^1\)</span>这个点！</p>
<p><strong><mark>α</mark></strong></p>
<p><strong>α</strong> 在梯度下降算法中被称作为<strong>学习率</strong>或者<strong>步长</strong>，意味着我们可以通过α来控制每一步走的距离，<strong><u>其实就是不要走太快，错过了最低点。同时也要保证不要走的太慢，导致太阳下山了，还没有走到山下。</u></strong> 所以α的选择在梯度下降法中往往是很重要的！α不能太大也不能太小，太小的话，可能导致迟迟走不到最低点，太大的话，会导致错过最低点！</p>
<p><strong><mark>梯度要乘以一个负号</mark></strong></p>
<p>梯度前加一个负号，就意味着朝着梯度相反的方向前进！我们在前文提到，<strong>梯度的方向实际就是函数在此点上升最快的方向</strong>！而我们需要朝着下降最快的方向走，自然就是负的梯度的方向，所以此处需要加上负号；那么如果时上坡，也就是梯度上升算法，当然就不需要添加负号了。</p>
<p><img src="https://cdn.staticaly.com/gh/peirsist/blog_img@master/bp算法.webp" style="zoom:150%;"></p>
<p>第 <span class="math inline">\(l\)</span> 层的误差项可以通过第 <span class="math inline">\(l + 1\)</span> 层的误差项计算得到，这就是误差的反向传播（BackPropagation，BP）。反向传播算法的含义是：第 <span class="math inline">\(l\)</span> 层的一个神经元的误差项（或敏感性）是所有与该神经元相连的第 <span class="math inline">\(l + 1\)</span> 层的神经元的误差项的权重和．然后，再乘上该神经元激活函数的梯度</p>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
  </entry>
  <entry>
    <title>留学申请</title>
    <url>/2022/11/08/%E9%9A%8F%E7%AC%94%E4%B8%8E%E4%B8%AA%E4%BA%BA%E6%96%87%E9%9B%86/%E7%95%99%E5%AD%A6%E7%94%B3%E8%AF%B7/</url>
    <content><![CDATA[<ol type="1">
<li><a href="https://www.bilibili.com/video/BV1Ae411G7qp/?spm_id_from=333.337.search-card.all.click&amp;vd_source=83831fc0970a6c8704479f7cfc679937">别当留学申请大怨种了！半diy英国申请经验_哔哩哔哩_bilibili</a></li>
<li><a href="https://www.bilibili.com/video/BV1J94y1Q7f5/?spm_id_from=333.337.search-card.all.click&amp;vd_source=83831fc0970a6c8704479f7cfc679937">香港博士申请最全攻略｜看这一篇就够了_哔哩哔哩_bilibili</a></li>
<li></li>
</ol>
]]></content>
      <categories>
        <category>随笔与个人文集</category>
      </categories>
  </entry>
  <entry>
    <title>区块链</title>
    <url>/2022/11/09/%E8%AE%BA%E6%96%87/%E5%8C%BA%E5%9D%97%E9%93%BE/</url>
    <content><![CDATA[<ol type="1">
<li><a href="https://www.bilibili.com/video/BV1K54y167W2/?spm_id_from=333.337.search-card.all.click&amp;vd_source=83831fc0970a6c8704479f7cfc679937">区块链相关论文汇报（四）_哔哩哔哩_bilibili</a></li>
<li><a href="https://www.bilibili.com/video/BV1Tf4y1q7cd/?spm_id_from=333.337.search-card.all.click&amp;vd_source=83831fc0970a6c8704479f7cfc679937">区块链相关论文汇报（一）_哔哩哔哩_bilibili</a></li>
<li><a href="https://www.bilibili.com/video/BV1J7411Z7T9/?spm_id_from=333.337.search-card.all.click&amp;vd_source=83831fc0970a6c8704479f7cfc679937">【不看后悔系列】6分钟，用人话讲清楚区块链！_哔哩哔哩_bilibili</a></li>
<li><a href="https://www.bilibili.com/video/BV1454y177Mc/?p=1&amp;share_medium=iphone&amp;share_plat=ios&amp;share_session_id=F9C0ADE2-EB02-482F-BAEF-AFD62A4A8467&amp;share_source=COPY&amp;share_tag=s_i&amp;timestamp=1627873047&amp;unique_k=VSiumn&amp;vd_source=83831fc0970a6c8704479f7cfc679937">看完这个视频，你会比99.999%的人懂区块链_哔哩哔哩_bilibili</a></li>
<li><a href="https://www.bilibili.com/video/BV1or4y1w7HZ/?vd_source=83831fc0970a6c8704479f7cfc679937">2019-ICDE-GEM2-Tree A Gas-Efficient Structure for Authenticated Range Queries in_哔哩哔哩_bilibili</a></li>
<li><a href="https://blog.csdn.net/sinat_35639885/article/details/103575956">区块链论文阅读（二）GEM2 -Tree: A Gas-Efficient Structure for Authenticated Range Queries in Blockchain_无情备课机的博客-CSDN博客</a></li>
<li></li>
</ol>
<h1 id="区块链">区块链</h1>
<h2 id="定义">定义</h2>
<p>区块链的概念最初源于中本聪于 2008 年提出的比特币[39]。其并非凭空出现的新技术，而是由<strong>密码学技术</strong>、<strong>P2P 技术</strong>以及<strong>时间戳技术</strong>等现有技术整合而成。作为比特币的底层存储技术，区块链至今已经历<strong>三个阶段的发展</strong>。</p>
<ol type="1">
<li>最初是用于记录比特币等数字货币交易的数据结构[40]。</li>
<li>之后以<strong>智能合约</strong>开发利用为核心应用于金融领域，典型代表便是<strong>以太坊</strong>。</li>
<li>如今正逐步扩展到社会各行各业，旨在将<strong>去中心化思想应用到各类现实场景</strong>，尤其在物联网方面的应用被寄予厚望。</li>
</ol>
<p>简单来说，区块链本质上是一种分布式数据库。由于是全网节点联合维护数据，因此<strong>去中心化的结构使系统能够更好的抵抗各种恶意攻击</strong>。同时，数据被打包成区块后按照时间顺序前后链接使得其事务具备了可追溯性，而在区块头内加入前一区块的哈希值则极大增加了数据被恶意篡改的难度。</p>
<p>根据应用场景的不同，区块链被分为公有链，私有链和联盟链三种类型。这三种区块链系统的差异主要体现在<strong>中心化程度</strong>以及对节点入网的限制上。</p>
<p><strong>公有链</strong>是最为典型的区块链，系统中所有人均有记账权，记账的节点还能获得一定的物质激励，数据完全公开透明，故其去中心化的程度最高，典型的应用项目就是以太坊[41]。但由于节点数量多且身份未知，因此系统的交易速度一般不高，且存在恶意节点进行攻击的风险。同时，记账激励以及节点间因争夺记账权导致的算力竞争也增加了交易的成本。</p>
<p>相比之下，私有链较为封闭，一般由单独的个体或组织进行维护。</p>
<p>联盟链则一般面向多个特定机构，仅允许得到授权的节点加入。记账节点为提前指定，由这些记账节点轮流或共同决定区块。</p>
<p>可以看出，私有链及联盟链由于节点数量少且均经过身份认证，因此它们的交易速度更快、交易成本极低甚至为零、系统也更加安全。但与此同时，它们的去中心化程度也稍弱，更偏向于弱中心化或多中心化。故在区块链的选择上应根据实际场景的特点及需要适当权衡。目前，联盟链的发展前景更被看好，其在产品溯源、金融交易以及信息安全等领域已被大量应用[42-46]。</p>
<p>💦每个节点之间的信息联系是点对点的，也就是 P2P 的网络路由模式<br>
☁其次节点都有自己的账本，也就是分布式账本<br>
☀每个节点都有打包账目的权利，而具体是由谁来充当账本的打包者，则是由共识机制选出，并且账目打包者可以获取手续费和系统奖励，并且因为分布式账本和时间连接的缘故，账本是难以篡改的:-O</p>
<p>区块链就是大家共同维护的一个账本，并且这个账本具有不可随意篡改，公开透明，账目可靠和去中内心化的特点</p>
<p>区块链就是一个去中心化的数据库</p>
<p>👇关于区块链你应该知道👇<br>
1. <strong>区块</strong>：多条账目的打包<br>
2. <strong>链</strong>：将两个相邻的日子的账本联系起来<br>
3. <strong>区块链</strong>：大家共同维护一个账本，并且这个账本具有不可被随意篡改、公开透明、账目可靠和去中心化的特点<br>
区块链的网络路由方式，用户对用户，每个人既是信息的接收者，同时也是信息的传播者</p>
<h1 id="数字签名">数字签名</h1>
<ol type="1">
<li>每个账户里都有私钥</li>
<li>私钥生成公钥，公钥生成地址</li>
<li>想操作地址必须通过私钥对操作的哈希值签名</li>
<li>如果公钥能破译签名，证明消息来自私钥拥有者</li>
<li>如果收到消息的哈希值等于破译的签名，证明消息没改</li>
</ol>
<h1 id="区块">区块</h1>
<p>每一个区块头里还有上一个区块的哈希值，哈希值就是区块的指纹，只要区块的内容被篡改，指纹就会变。因为只要在区块链上某一个区块的哈希值变了，那么这个区块之后的所有区块的哈希值也会变，通过哈希值一个个区块就被串联起来，像个链条，所以被成为区块链。</p>
<hr>
<p>区块链通过一笔交易来更新数据</p>
<p><strong>认证</strong>是证明你是谁的过程。例如，通过提供正确的用户名/密码，对用户的身份进行身份验证。</p>
<p><strong>授权</strong>则是在认证后根据权限策略，决定你可以做的什么。</p>
<h1 id="数据完整性">数据完整性</h1>
<ol type="1">
<li><a href="https://www.zhihu.com/question/52820270">区块链中的数据内容如何保证正确？ - 知乎 (zhihu.com)</a></li>
<li><a href="https://www.zhihu.com/question/542414549">区块链上的数据是怎样保证完整性的？ - 知乎 (zhihu.com)</a></li>
<li></li>
</ol>
<h1 id="merkle-tree">Merkle Tree</h1>
<ol type="1">
<li><a href="https://blog.csdn.net/wo541075754/article/details/54632929">Merkle Tree（默克尔树）算法解析_程序新视界的博客-CSDN博客_merkle tree</a></li>
<li><a href="https://blog.csdn.net/sinat_35639885/article/details/103654749?spm=1001.2101.3001.6661.1&amp;utm_medium=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1-103654749-blog-103575956.pc_relevant_multi_platform_whitelistv3&amp;depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1-103654749-blog-103575956.pc_relevant_multi_platform_whitelistv3&amp;utm_relevant_index=1">（知识点补充二）merkle树和MB-Tree_无情备课机的博客-CSDN博客</a></li>
<li><a href="https://www.bilibili.com/video/BV1xY4y1j7xw/?spm_id_from=333.337.search-card.all.click&amp;vd_source=83831fc0970a6c8704479f7cfc679937">区块链去中心化的底层原理 - Merkle Tree_哔哩哔哩_bilibili</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/176979849">走近区块链（二）：区块链的数据结构 - 知乎 (zhihu.com)</a></li>
<li><a href="https://blog.csdn.net/TuxedoLinux/article/details/86764142">区块链的数据结构_TuxedoLinux的博客-CSDN博客_区块链是数据结构吗</a></li>
<li></li>
</ol>
<h1 id="smart-contract">Smart Contract</h1>
<ol type="1">
<li><a href="https://zhuanlan.zhihu.com/p/45362543">区块链：一文读懂智能合约 - 知乎 (zhihu.com)</a></li>
<li></li>
</ol>
<h1 id="以太坊">以太坊</h1>
<ol type="1">
<li><a href="https://zhuanlan.zhihu.com/p/390884462">以太坊（ETH）到底是什么？ - 知乎 (zhihu.com)</a></li>
<li><a href="https://www.bilibili.com/video/BV1d24y1Z7GB/?spm_id_from=333.337.search-card.all.click&amp;vd_source=83831fc0970a6c8704479f7cfc679937">什么是以太坊？什么是智能合约与DAPP?_哔哩哔哩_bilibili</a></li>
<li></li>
</ol>
<p>单纯小白一枚<br>
既然人人都有账本，人人都信息是发送者，又是去中心化，那谁来判断谁的信息是真是假？只能靠51%吗？<br>
区块是开放的还是封闭的？新成员准入有没有什么限制和门槛，有没有可能伪造 101 个带假账本的人进入只有 100 个人的小岛</p>
<p>你可以理解为每一个区块每一个账本的哈希是独一无二的是不同的，你如果做假账哈希就会发生变化，你下一个区块就不认你了。所以说才会有百分之 51 以上才能篡改的说法，你除非整个区块链百分之 51 以上都被你控制了，你才能去篡改</p>
<p>资本家就是靠信息不对称骗人的啊……说白了就是忽悠人，科技无罪，有罪的是资本和使用的人</p>
]]></content>
      <categories>
        <category>论文</category>
      </categories>
  </entry>
  <entry>
    <title>如何找要读的paper</title>
    <url>/2022/11/10/%E8%AE%BA%E6%96%87/%E5%A6%82%E4%BD%95%E6%89%BE%E8%A6%81%E8%AF%BB%E7%9A%84paper/</url>
    <content><![CDATA[<h1 id="有关论文阅读"><a href="#有关论文阅读" class="headerlink" title="有关论文阅读"></a>有关论文阅读</h1><h2 id="0-前言"><a href="#0-前言" class="headerlink" title="0. 前言"></a>0. 前言</h2><p>准备区块链的时候发现了这篇文章，虽然是区块链的，但内容方法应该是通用的。来源 <a href="https://github.com/lulinglingcufe/Blockchain-Top-Paper-Seminar/">link</a></p>
<p>陈建海老师上学期《计算机科学基础》大作业要求班上的同学翻译了一些区块链相关的国外顶级会议的论文。从中挑选了一些较好的翻译，如果大家有需要的话可以看一下。翻译与原文在 <code>翻译论文</code> 目录下。</p>
<p>下面简单介绍一下查找论文的方法。</p>
<h2 id="1-跟区块链相关的学术文献"><a href="#1-跟区块链相关的学术文献" class="headerlink" title="1. 跟区块链相关的学术文献"></a>1. 跟区块链相关的学术文献</h2><p><a href="https://github.com/decrypto-org/blockchain-papers">blockchain-papers</a></p>
<p>github 上其他人整理的区块链相关学术文献。</p>
<h2 id="2-中国计算机学会（CCF）推荐国际学术会议和期刊目录"><a href="#2-中国计算机学会（CCF）推荐国际学术会议和期刊目录" class="headerlink" title="2. 中国计算机学会（CCF）推荐国际学术会议和期刊目录"></a>2. 中国计算机学会（CCF）推荐国际学术会议和期刊目录</h2><p><a href="https://www.ccf.org.cn/">https://www.ccf.org.cn/</a></p>
<p><a href="https://www.ccf.org.cn/Academic_Evaluation/By_category/">https://www.ccf.org.cn/Academic_Evaluation/By_category/</a></p>
<p>以 ABC 等级的形式划分了国外的学术期刊和会议，是浙大现在科研成果认定的评价标准之一。</p>
<h2 id="3-CCF-推荐国际学术会议-网络与信息安全）"><a href="#3-CCF-推荐国际学术会议-网络与信息安全）" class="headerlink" title="3. CCF 推荐国际学术会议 (网络与信息安全）"></a>3. CCF 推荐国际学术会议 (网络与信息安全）</h2><p><a href="https://www.ccf.org.cn/Academic_Evaluation/NIS/">https://www.ccf.org.cn/Academic_Evaluation/NIS/</a></p>
<p>网络安全方向 A 类的几个顶级会议：<code>CCS</code>、CRYPTO、EUROCRYPT、S&amp;P、USENIX Security 上有关区块链的文章都值得关注。代表了国际上的相关研究的较高学术水平，值得学习。</p>
<h3 id="3-1-以-USENIX-Security-会议为例"><a href="#3-1-以-USENIX-Security-会议为例" class="headerlink" title="3.1 以 USENIX Security 会议为例"></a>3.1 以 USENIX Security 会议为例</h3><p><a href="http://dblp.uni-trier.de/db/conf/uss/">http://dblp.uni-trier.de/db/conf/uss/</a></p>
<p>从 CCF 的推荐网址可以链接到该网址。其下有历年 USENIX Security 会议的论文资源。</p>
<h3 id="3-2-以-USENIX-Security-Symposium-2015-为例"><a href="#3-2-以-USENIX-Security-Symposium-2015-为例" class="headerlink" title="3.2 以  USENIX Security Symposium 2015 为例"></a>3.2 以  USENIX Security Symposium 2015 为例</h3><p>找到 2015 年下的 USENIX 相关会议： 24th USENIX Security Symposium, USENIX Security 15, Washington, D.C., USA, August 12-14, 2015. USENIX Association 2015 <a href="https://dblp.uni-trier.de/db/conf/uss/uss2015.html">dblp: USENIX Security Symposium 2015 (uni-trier.de)</a></p>
<p>点击 contents 链接到：<a href="http://dblp.uni-trier.de/db/conf/uss/uss2015.html">http://dblp.uni-trier.de/db/conf/uss/uss2015.html</a></p>
<p>该网址下有 2015 年 USENIX Security 会议的论文资源。</p>
<p>会议分不同的专题，每个专题下有一些文章。可以根据关键字：blockchain 或 bitcoin 等搜索论文。</p>
<h3 id="3-3-会议还会有自己的网站"><a href="#3-3-会议还会有自己的网站" class="headerlink" title="3.3 会议还会有自己的网站"></a>3.3 会议还会有自己的网站</h3><p><a href="https://www.usenix.org/conference/usenixsecurity15/technical-sessions/presentation/heilman">https://www.usenix.org/conference/usenixsecurity15/technical-sessions/presentation/heilman</a></p>
<ul>
<li>一些会议网站上有会议视频、演讲 slides 的资源链接。一般在 YouTube 上搜索会议名称+年份，有会议演讲视频的集合。</li>
<li>在一些科研工作者的个人主页上也可以下载到 slides，或者也可以选择发 email 向他们要相关材料。</li>
<li>在我们每周的组会上，也可以自己做 slides 讲论文，只要能够讲清楚就可以了。</li>
</ul>
<h2 id="4-文献搜索"><a href="#4-文献搜索" class="headerlink" title="4. 文献搜索"></a>4. 文献搜索</h2><h3 id="4-1-谷歌学术"><a href="#4-1-谷歌学术" class="headerlink" title="4.1 谷歌学术"></a>4.1 谷歌学术</h3><p><a href="https://scholar.google.com/">https://scholar.google.com/</a></p>
<h3 id="4-2-科研团队主页"><a href="#4-2-科研团队主页" class="headerlink" title="4.2 科研团队主页"></a>4.2 科研团队主页</h3><p>在看文献的过程中很自然地会关注到一些积累比较深厚的团队或者科研人员，感兴趣的话可以持续关注他们的主页。</p>
<p>Loi Luu: <a href="http://www.comp.nus.edu.sg/~loiluu/">http://www.comp.nus.edu.sg/~loiluu/</a></p>
<p>Andrew Miller: <a href="http://soc1024.ece.illinois.edu/">http://soc1024.ece.illinois.edu/</a></p>
<p><strong>Advice：当前 SRTP 的同学们如果觉得顶级会议的论文比较难，可以先自己搜索区块链相关文献进行阅读，然后再与大家分享也是很好的。</strong></p>
]]></content>
      <categories>
        <category>论文</category>
      </categories>
  </entry>
  <entry>
    <title>如何科研</title>
    <url>/2022/11/10/%E8%AE%BA%E6%96%87/%E5%A6%82%E4%BD%95%E7%A7%91%E7%A0%94/</url>
    <content><![CDATA[<p>学术圈那就那样，靠人脉，跟娱乐圈一样乱，却有人乐此不疲，前仆后继。 <img src="https://cdn.staticaly.com/gh/peirsist/blog_img@master/Snipaste_2022-11-02_19-49-47.3nkby7sunre0.png" alt="Snipaste_2022-11-02_19-49-47"></p>
<hr>
<p><strong>正文</strong></p>
<ol type="1">
<li><a href="https://www.bilibili.com/video/BV1BD4y1t73e/?spm_id_from=333.999.0.0&amp;vd_source=83831fc0970a6c8704479f7cfc679937">博士科研心得分享【适合研一新生0基础科研入门，纯干货】文献阅读与管理SCI写作技巧_哔哩哔哩_bilibili</a></li>
<li><a href="https://www.bilibili.com/video/BV14t4y1u75s/?spm_id_from=333.999.0.0&amp;vd_source=83831fc0970a6c8704479f7cfc679937">科研论文写作简介_哔哩哔哩_bilibili</a></li>
<li><a href="https://www.bilibili.com/video/BV1HK411S7EH/?spm_id_from=333.999.0.0&amp;vd_source=83831fc0970a6c8704479f7cfc679937">【双语字幕】杨振宁年轻时全英语授课视频，挑战一下你能听懂多少？_哔哩哔哩_bilibili</a></li>
</ol>
<p>记笔记还是不要用 markdown 了，总结可以用 markdown，但是比较慢，还是 word，挺好的。</p>
<h1 id="读文献">读文献</h1>
<ol type="1">
<li><p>文献查阅与管理</p>
<ol type="1">
<li><p>如何快速找到与研究方向相关文章 ？</p>
<ul>
<li><p>查文献：<a href="https://www.sciencedirect.com/">ScienceDirect.com</a></p></li>
<li><p>查作者：<a href="https://www.scopus.com/search/form.uri?display=basic#basic">Scopus</a></p></li>
</ul></li>
<li><p>如何快速了解国内外发展现状 ？</p></li>
<li><p>找到后，怎么高效阅读 ？ 逐词句阅读？ 逐词句阅读？ 逐词句阅读阅读顺序 ？</p></li>
<li><p>读完之后，好像懂了也没看懂没看懂 ？</p></li>
<li><p>读过的文章，用时候（写论、综述） ） 读过的文章，用时候（写论、综述找不到 ？</p></li>
</ol></li>
</ol>
<h1 id="科研软件学习">科研软件学习</h1>
<ol type="1">
<li>软件安装与学习</li>
</ol>
<h1 id="写论文">写论文</h1>
<ol type="1">
<li>科研绘图</li>
<li>论文构思与写作</li>
<li>论文排版</li>
</ol>
<p><img src="https://cdn.staticaly.com/gh/peirsist/blog_img@master/郑楠-组会-科研心得体会分享-2022-10-28_页面_02.4d93t83knrg0.png" alt="郑楠-组会-科研心得体会分享-2022-10-28_页面_02"> <img src="https://cdn.staticaly.com/gh/peirsist/blog_img@master/郑楠-组会-科研心得体会分享-2022-10-28_页面_03.31ww2lrtty40.png" alt="郑楠-组会-科研心得体会分享-2022-10-28_页面_03"> <img src="https://cdn.staticaly.com/gh/peirsist/blog_img@master/郑楠-组会-科研心得体会分享-2022-10-28_页面_04.180w5dk7ighs.png" alt="郑楠-组会-科研心得体会分享-2022-10-28_页面_04"> <img src="https://cdn.staticaly.com/gh/peirsist/blog_img@master/郑楠-组会-科研心得体会分享-2022-10-28_页面_05.3xzvg9utkxe0.png" alt="郑楠-组会-科研心得体会分享-2022-10-28_页面_05"> <img src="https://cdn.staticaly.com/gh/peirsist/blog_img@master/郑楠-组会-科研心得体会分享-2022-10-28_页面_06.6ulmnucv7co0.png" alt="郑楠-组会-科研心得体会分享-2022-10-28_页面_06"> <img src="https://cdn.staticaly.com/gh/peirsist/blog_img@master/郑楠-组会-科研心得体会分享-2022-10-28_页面_07.5083s5fn4fk0.png" alt="郑楠-组会-科研心得体会分享-2022-10-28_页面_07"> <img src="https://cdn.staticaly.com/gh/peirsist/blog_img@master/郑楠-组会-科研心得体会分享-2022-10-28_页面_08.1tke8m2cko4g.png" alt="郑楠-组会-科研心得体会分享-2022-10-28_页面_08"> <img src="https://cdn.staticaly.com/gh/peirsist/blog_img@master/郑楠-组会-科研心得体会分享-2022-10-28_页面_09.6h62mbt9tu80.png" alt="郑楠-组会-科研心得体会分享-2022-10-28_页面_09"> <img src="https://cdn.staticaly.com/gh/peirsist/blog_img@master/郑楠-组会-科研心得体会分享-2022-10-28_页面_10.1kfq0lremu00.png" alt="郑楠-组会-科研心得体会分享-2022-10-28_页面_10"> <img src="https://cdn.staticaly.com/gh/peirsist/blog_img@master/郑楠-组会-科研心得体会分享-2022-10-28_页面_11.6gshg8kcdfg0.png" alt="郑楠-组会-科研心得体会分享-2022-10-28_页面_11"> <img src="https://cdn.staticaly.com/gh/peirsist/blog_img@master/郑楠-组会-科研心得体会分享-2022-10-28_页面_12.589ho11jt6c0.png" alt="郑楠-组会-科研心得体会分享-2022-10-28_页面_12"> <img src="https://cdn.staticaly.com/gh/peirsist/blog_img@master/郑楠-组会-科研心得体会分享-2022-10-28_页面_13.2eyhdc227qdc.png" alt="郑楠-组会-科研心得体会分享-2022-10-28_页面_13"> <img src="https://cdn.staticaly.com/gh/peirsist/blog_img@master/郑楠-组会-科研心得体会分享-2022-10-28_页面_14.4l699wfnm9e0.png" alt="郑楠-组会-科研心得体会分享-2022-10-28_页面_14"> <img src="https://cdn.staticaly.com/gh/peirsist/blog_img@master/郑楠-组会-科研心得体会分享-2022-10-28_页面_15.1j36h70zgn40.png" alt="郑楠-组会-科研心得体会分享-2022-10-28_页面_15"> <img src="https://cdn.staticaly.com/gh/peirsist/blog_img@master/郑楠-组会-科研心得体会分享-2022-10-28_页面_16.75zqcs7o2lg0.png" alt="郑楠-组会-科研心得体会分享-2022-10-28_页面_16"> <img src="https://cdn.staticaly.com/gh/peirsist/blog_img@master/郑楠-组会-科研心得体会分享-2022-10-28_页面_17.14orlyxm6fc0.png" alt="郑楠-组会-科研心得体会分享-2022-10-28_页面_17"> <img src="https://cdn.staticaly.com/gh/peirsist/blog_img@master/郑楠-组会-科研心得体会分享-2022-10-28_页面_18.1u1x72ryc40w.png" alt="郑楠-组会-科研心得体会分享-2022-10-28_页面_18"> <strong>积累句式</strong> <img src="https://cdn.staticaly.com/gh/peirsist/blog_img@master/Snipaste_2022-11-12_10-16-25.56dcqcxhzw00.png" alt="Snipaste_2022-11-12_10-16-25"></p>
<h1 id="如何-ppt-汇报">如何 PPT 汇报</h1>
<p>参考 <img src="https://cdn.staticaly.com/gh/peirsist/blog_img@master/4f50cf955cfe3228744d78c3a9c9ade.q6pl7hcas8w.jpg" alt="4f50cf955cfe3228744d78c3a9c9ade"> <img src="https://cdn.staticaly.com/gh/peirsist/blog_img@master/8513a448f4c9f21973fc4a62e9400b7.16laq336lh4w.jpg" alt="8513a448f4c9f21973fc4a62e9400b7"> <img src="https://cdn.staticaly.com/gh/peirsist/blog_img@master/318dd51fee72de51b76eb67ec68f139.2rofsfdvwa00.jpg" alt="318dd51fee72de51b76eb67ec68f139"> <img src="https://cdn.staticaly.com/gh/peirsist/blog_img@master/59e34b7148164445aa66dff1ff823f8.3qcymz7wx2s0.jpg" alt="59e34b7148164445aa66dff1ff823f8"> <img src="https://cdn.staticaly.com/gh/peirsist/blog_img@master/1f38c7b2a0d18f06f6f90a02f0f2fcd.3idjnaccdz00.jpg" alt="1f38c7b2a0d18f06f6f90a02f0f2fcd"></p>
]]></content>
      <categories>
        <category>论文</category>
      </categories>
  </entry>
  <entry>
    <title>句式积累</title>
    <url>/2022/11/12/%E8%AE%BA%E6%96%87/1%E5%8F%A5%E5%BC%8F%E7%A7%AF%E7%B4%AF/</url>
    <content><![CDATA[
]]></content>
      <categories>
        <category>论文</category>
      </categories>
  </entry>
  <entry>
    <title>论文结构大纲</title>
    <url>/2022/11/12/%E8%AE%BA%E6%96%87/0%E8%AE%BA%E6%96%87%E7%BB%93%E6%9E%84%E5%A4%A7%E7%BA%B2/</url>
    <content><![CDATA[
]]></content>
      <categories>
        <category>论文</category>
      </categories>
  </entry>
  <entry>
    <title>安装软件记录</title>
    <url>/2022/11/11/02%E5%AE%89%E8%A3%85%E8%BD%AF%E4%BB%B6/%E5%AE%89%E8%A3%85%E8%BD%AF%E4%BB%B6%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<h1 id="安装idm">安装IDM</h1>
<ol type="1">
<li><a href="http://www.downza.cn/soft/239667.html">IDM下载器中文破解版_IDM下载器中文破解版下载-下载之家 (downza.cn)</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/430535305">IDM序列号 - 知乎 (zhihu.com)</a>
<ol type="1">
<li>输入序列号前记得关闭网络，之后会有一个弹错，直接叉掉或取消或关闭，然后一直快速点击，直到它没有响应，最后关闭程序，亲测有效。</li>
</ol></li>
</ol>
<h1 id="安装-zotero-插件">安装 zotero 插件</h1>
<ol type="1">
<li><a href="https://zotero-chinese.gitee.io/zotero-plugins/#/">Zotero中文社区 (gitee.io)</a></li>
</ol>
]]></content>
      <tags>
        <tag>安装软件</tag>
      </tags>
  </entry>
  <entry>
    <title>词汇积累</title>
    <url>/2022/11/12/%E8%AE%BA%E6%96%87/3%E8%AF%8D%E6%B1%87%E7%A7%AF%E7%B4%AF/</url>
    <content><![CDATA[<p>naive</p>
]]></content>
      <categories>
        <category>论文</category>
      </categories>
  </entry>
  <entry>
    <title>研究生时间节点</title>
    <url>/2022/11/13/00%E7%A0%94%E7%A9%B6%E7%94%9F/About/</url>
    <content><![CDATA[<p>个人感悟记在 <strong><em>随笔与个人文集</em></strong> 中，但是这是不成体系的。因此用研究生这个分类主要进行总结，以便等自己毕业后，可以回顾自己干了什么。</p>
<h1 id="研一上">研一上</h1>
<p>主要上课，看文献，学好C++、计算机网络、机器学习</p>
]]></content>
      <categories>
        <category>研究生</category>
      </categories>
  </entry>
  <entry>
    <title>如何阅读文献及做笔记、写作</title>
    <url>/2022/10/20/%E8%AE%BA%E6%96%87/%E5%A6%82%E4%BD%95%E9%98%85%E8%AF%BB%E6%96%87%E7%8C%AE/</url>
    <content><![CDATA[<h1 id="如何写作">1 如何写作</h1>
<ol type="1">
<li><a href="https://www.zhihu.com/question/35071142">英文学术论文写作，有什么好书可以推荐? - 知乎 (zhihu.com)</a></li>
<li><a href="https://slc.berkeley.edu/writing-worksheets-and-other-writing-resources/online-writing-labs">Online Writing Labs | Student Learning Center (berkeley.edu)</a></li>
<li><a href="https://www.eflbooks.co.uk/samples/9789888390755.pdf">Hart_text.indb (eflbooks.co.uk)</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/141530063">有哪些介绍学术论文写作的书籍，值得一读 - 知乎 (zhihu.com)</a></li>
<li></li>
</ol>
<h1 id="如何记笔记">2 如何记笔记</h1>
<h2 id="自己的感悟">2.1 自己的感悟</h2>
<p>2022/11/16</p>
<p>笔记分 <strong><font color="red">三部分</font></strong>：</p>
<ol type="1">
<li><strong>论文原理</strong>
<ol type="1">
<li>用 LaTex 总结和 Markdown 记录方便复习，不要长篇大论翻译，后面复习一样抓不到重点，记笔记的目的是为了以后能够 <strong>以最快的速度</strong> 想起来内容。</li>
</ol></li>
<li><strong>背景部分</strong>，方便后续写作
<ol type="1">
<li>背景部分翻译记录，而且所有的背景要记在一个文件中，方便总结归纳，背景要先能写中文；再英文，写英文需要总结平时文献中的表达，也就是第三点。</li>
</ol></li>
<li><strong>英语表达</strong>，方便写作
<ol type="1">
<li><strong>句式</strong>多样性</li>
<li><strong>词汇</strong>多样性</li>
</ol></li>
</ol>
<p><strong>总结</strong></p>
<blockquote>
<p><strong><font color="red">1</font></strong> 是为想创新点，了解某一个领域服务的，<strong><font color="red">2, 3</font></strong> 是为后续自己写论文服务的，具体是如何用英语写，如何写背景部分。方案部分其实由 <strong><font color="red">1</font></strong> 解决了。</p>
</blockquote>
<h2 id="网上总结">2.2 网上总结</h2>
<blockquote>
<p><a href="https://blog.csdn.net/dujiahei/article/details/80880980">整理牛人看文献的方法_dujiahei的博客-CSDN博客</a></p>
</blockquote>
<p>我现在<strong>每天</strong>还保持读<strong>至少2-3篇</strong>的文献的习惯。读文献有不同的读法。但<strong><font color="red">最重要的自己总结概括这篇文献到底说了什么，否则就是白读</font></strong>，<strong>读的时候好像什么都明白，一合上就什么都不知道，这是读文献的大忌</strong>，既浪费时间，最重要的是，没有养成良好的习惯，导致以后不愿意读文献。</p>
<p>复印或打印的文献，直接用笔标记或批注。pdf 或 html 格式的文献，可以<strong>用编辑器标亮或改变文字颜色</strong>。<strong>这是避免时间浪费的又一重要手段</strong>。否则等于没看。</p>
<p>读英文原版文献有窍门的。我们每个单词都认识读完了却不知他在说什么，这是最大的问题。在阅读的时候一定要看到大量的关系连词，他们承上启下引领了全文。<strong>中国人喜欢罗列事实，给出一个观点然后就是大量的事实</strong>，这也是中文文献的特点，我们从小都在读这样的文章，很适应。<strong>西方人的文献注重逻辑和推理，从头到尾是非常严格的</strong>，就像 GRE 里面的阅读是一样的，进行的是大量重复、新旧观点的支持和反驳，有严格的提纲，尤其是好的杂志体现得越突出。<strong>读每一段落都要找到他的主题，往往是很容易的，大量的无用信息可以一带而过</strong>，节约你大量的宝贵时间和精力。</p>
<p><strong>扩充知识面的读法，重点读introduction</strong>，看人家提出的问题，以及目前的进展 类似的文章，每天读一两篇，一个月内就基本上对这个领域的某个方向有个大概的了解。读好的review也行，但这样人容易懒惰。</p>
<hr>
<p><strong>看文献要多多益善</strong>。我以前看到有的同学问看文献要看多少？我的回答是多多益善。<strong>试想一篇文献至少要有三两可取之处，看得多了你的水平自然就上来了</strong>。我自己从研一就开发新方向，没有什么人能帮助我，我靠的只有文献。<strong>我还记得我那半年每天至少 3－5 篇文献</strong>，后来略有小成。我师兄更牛－－每天三篇文献。现在他才博士二年级（硕士读了两年），很多方面超过了我们老板，要知道我们老板也是 973 首席！他现在体系是自己找的，这半年发了两篇 PRB（做物理的同学知道这个不是很容易的）、一篇 JPCM，其中 JPCM 被评为 06 年 100 篇最佳文章之一，供全世界免费下载一年。他告诉我这些成果很多都是看文献得来的，其中包括做东西的思路和写文章的英文表述等等。</p>
<p>阅读文献和专著是需要积累的，要坚持不懈，多研究和教学工作恐怕一生都要坚持阅读新文献和著作。读文献有个量变到质变的过程，阅读量大了，积累多了，需要总结的方面就多了。这样日久天长，通过知识的整合，知识框架会逐渐完善，自己肚子里的“货”就会感觉逐渐充实起来了，用和取的时候就会很自如。</p>
<p>从初学者到专家的转变，只要有心，只是一个时间问题。<strong>信息就是资源，知识就是信息的积累和过滤、整合</strong>。无论参加学术会议，还是讨论会，<strong>有些人说了很多，占用很多时间，但你会感觉没有多少新的信息或知识，但有些人一开口，话不多，你马上就会感觉到人家肚子里知识的储存量，激烈争论的氛围，会立即安静下来，听众会被吸引，这就是所谓的专家了</strong>。专家不是万金油。博士毕业后，都应该成为一个领域的专家。再磨练积累几年，就一定会是名副其实的专家了。</p>
<p>本人英语基础不好，没过六级，所以在硕士的时候基本上看的外文文献很少，现在想想很后悔，2 年的时间少学了很多东西。上了博士，自己给自己的定位也高一些了，开始打算硬着头皮咬着牙很不情愿的也要多看些外文文献，一开始看比较慢，有些很难理解，<strong>到现在大约仔细阅读了 100 篇外文文献，泛读了 100 篇外文文章，受益匪浅，现在基本不怎么看中文的了</strong>，确实也觉得外文的质量就是高（也有凑数的烂文章），现在自己写外文的也很顺手了。谈几点自己的体会。我是材料专业的。</p>
<hr>
<p><strong><font color="red">很重要！！！</font></strong></p>
<p>为了写文章的读法，读文章的时候，尤其是看 discussion 的时候，看到好的英文句型，最好有意识的记一下，看一下作者是谁，哪篇文章，哪个期刊，这样以后照猫画虎写的时候，效率高些。<strong>比自己在那里半天琢磨出一个句子强的多。当然，读的多，写的多，你需要记得句型就越少</strong>。其实很简单，有意识的去总结和记亿，就不容易忘记。</p>
<hr>
<p>某少以前跟我讲过一个故事。他的一个朋友因为很早以前就转入编剧行当，一直秉承摸着石头过河的学习方式，不得要领十几年。有一天他拿着一本罗伯特·麦基的《故事一一材质、结构、风格和银幕剧作的原理》给那人看。那人看了，相见恨晚，主要还是恨，他说我这十几年的经验，里面全都包括了，还有我没参透的，里面一句话，忽然间大彻大悟了，我要是没看见这本书，有些东西可能这辈子都悟不到。 显然苟子也经历过这种情况，因此《劝学》里那句话的意思其实是：<strong>想学一样东西，找专业书看一眼，比瞎琢磨好几天都强。</strong> 不登高山，不知天之高也。不临深溪，不知地之厚也。不闻先王之遗言，不知学问之大也。 君子性非异也，善假于物也！</p>
<p>接受过义务教育，学过几何的，应该都知道：公式与定理多有用，简直就是巨人的肩膀；没有公式与定理。，你得从头证，累死了，也不一定证得出来。 接受过大学教育，写过大学论文的，应该都知道：写一篇论文，读的文献厚度得是论文的若干倍；而那些文献背后，又是堆积如山的材料；如果没有相应文献，要你徒手开始写，累死了也不一定写得出来。 做过菜的都知道，有现成食材与调味料给你，你才能迅速地做一锅，比如说，咖咂鸡。。可是，如果鸡肉得自己去捉鸡杀了切开，蔬菜得自己浇水施肥种出来，咖咂粉。需要自己种植收获姜黄郁金胡椒再来磨粉，在饿死之前，很难做好一顿。 <strong>人类绝大多数的物质与精神的生产，都建立在前人的经验与基础上。</strong> <strong>善用前人留下的经验与工艺，比一个人的努力迅速多了。</strong></p>
<hr>
<h1 id="如何阅读文献">3 如何阅读文献</h1>
<h2 id="清华大学唐潇风">3.1 清华大学唐潇风</h2>
<p>2022-10-20在工程伦理的课程上说的</p>
<blockquote>
<p>清华大学唐潇风</p>
</blockquote>
<ol type="1">
<li><p>看标题，摘要，最值得抓取的、不明白的是什么。不适合刚开始读文献的学生。把每篇文献整理成三句话：</p>
<ul>
<li>为什么做</li>
<li>怎么做的</li>
<li>得到什么</li>
</ul>
<p>之所以能做到提炼成三句话，往往是对这个领域特别熟悉的，知道别人做过什么</p></li>
<li><p>精读 20 篇，每一句话。</p></li>
<li><p>信息抓取的角度，翻译是可以的，<strong>但写文章的时候，就要从头开始想怎么写</strong></p></li>
<li><p>为了写作，写作的角度，读原文，才能看到别人的语言是如何使用的。</p></li>
<li><p><strong>做到让自己经常写这件事不是那么容易</strong>，总是拖到最后，写个两三天，一两个礼拜。尽量把 <strong>负荷均摊化，每天写半小时，持续性的写。</strong></p></li>
</ol>
<hr>
<h2 id="一篇好的知乎回答">3.2 一篇好的知乎回答</h2>
<p><a href="https://zhuanlan.zhihu.com/p/136013652">文献应该怎么看？——科研萌新看过来（已经补充高清图） - 知乎 (zhihu.com)</a></p>
<h3 id="二看文献的顺序">3.2.1 二、看文献的顺序</h3>
<p>一开始的时候我是顺着来读的，当然我是那种读下一段的时候又忘了上一段。我试过很多的弯路，比如说把每一段都翻译，然后写下来。我发现后面特别的浪费时间，所以我就省去了这个部分。因为你会发现你把所有的精力和重点都放在去翻译这件事儿上，并没有去想着。这个是文章是如何写的？</p>
<p>所以后来我的顺序是这样的：我找文献的时候我会先看他<strong>标题</strong>，如果它的标题是我想要研究的课题，那我就会继续下一步。接着我会去看他<strong>结果的图</strong>，如果这些图是我专业方面的，或者说是大部分我看得懂的，那我就会偏好去找这些文章来读。继续看他的摘要，其实这个部分对我读不读这篇文章不会有太大的影响（因为他在一篇文章的开头，如果我读完整篇文章之后，我也不会记得他的摘要是写了什么？当然别的同学可能不是这么认为的，这仅仅是我个人的想法。）然后我会跳到<strong>结果和讨论</strong>部分开始读这篇文章。</p>
<p>有的人会很好奇，为什么不从引言开始来读？嗯，我觉得引言部分，不是太重要。我会把引言放到后面来读。因为我读完了结果之后，我会带着很多的问题，比如说他为什么要研究这个？他是如何找到的基因？等等问题，然后再返回去读<strong>引言</strong>的时候，你就会耳目一新，恍然大悟。这样也就是加深了你读文献的印象。当然在最后的时候你再去读一遍<strong>摘要</strong>，这个时候你就会明白摘要总结的很精辟啦！我的同学会从实验材料和方法开始读。这也不失为一种好的方法，这样你会更了解他的实验是如何操作的。</p>
<p>★★★★★★★★★以下是本次经验分享最精华的部分★★★★★★★★★★★</p>
<h3 id="三如何去看文章的results部分">3.2.2 <strong>三、如何去看文章的results部分？</strong></h3>
<p>（我呢，也害怕大家觉得前面是长篇大论，所以呢就在这儿着重标记一下，这个部分是我看文献最重要的技巧。）</p>
<p>这里我主要讲的是结果的部分我是怎么看的。首先给大家看一下我的样张部分。</p>
<p>（在这里，大家不要纠结iPad香不香的问题。无论是纸质的还是pad都可以做到下面的效果。我也一开始是用的纸质版，但是我的那些看过的文献都在实验室，我也没办法拍照下来给大家展示。毕竟疫情期间还请大家见谅！） <img src="https://pic4.zhimg.com/80/v2-22e2cf9fe34c43092e913136a44fd4c3_1440w.webp" alt="img"> <img src="https://pic3.zhimg.com/80/v2-74a961bc69b6b91f0d692c88fb72ed6a_1440w.webp" alt="img"></p>
<p>我比较喜欢把文献画的花里胡哨的，那是因为这样我能够看得更加的明确，哪些部分是讲什么的？大家可以参考我给的颜色示例。一般呢我会把不同部分用不同的颜色来标记。</p>
<p>★★文章的结果会有好几个，但是每个小结果写个套路都是一样的。接下来先介绍一下<strong>单个result</strong>一般是怎么样的？</p>
<ol type="1">
<li>首先，作者在写这个结果的时候，往往会先写他为什么要做这个实验，也就是绿色部分的目的，或者是作者提出了一个假设。</li>
<li>接着作者会在后面直接写他用什么实验来验证这个“目的”/假设。</li>
<li>然后坐着会详细描述一下他这个实验，比如说实验用的是什么材料或者是什么处理？</li>
<li>最后就是他得到了什么样的结果。</li>
<li>根据这个结果他猜测了什么东西？或者说他得到了什么结论？</li>
</ol>
<p>★★所以当你看单个结果的时候，你需要做到的就是，<strong>这个result讲了什么？为什么要这么做？他用什么实验来证明？以及他得到了什么样的结果和结论？</strong>一开始看的时候你肯定会很吃力，但是你一定要静下心来。慢慢看。心急是吃不了热豆腐的，所以，<strong>你要搞懂一句话之后再搞懂下一句话。</strong></p>
<p>★★这个时候涉及到的就是<strong>看图</strong>的本领。基本上每一个result都会有图和表。所以你在看结果的时候，只要他提到了这个图，你<strong>一定要把图和这句话对应上</strong>。一定要做到抛开result你都能知道它讲了什么。其实每幅图的下面都会有legend，就是图注。图注就是要抛开整篇文章，别人也能看懂这个图他说了什么。有的时候会在下面辅助的填上其他的信息。 <img src="https://pic3.zhimg.com/80/v2-95594e9ecbd7867a282a4321263090d6_1440w.webp" alt="img"></p>
<p>★★对于看图我还有一点经验要讲。<strong>要读懂图可以这么做：首先，这个图他给你最直观的结果是什么？第二，你能从这些结果总结到什么？</strong>具体的方法大家可以参考雅思的小作文是如何写的？在这里我就不赘述了。</p>
<p>★★讲完单个result，我们继续来说<strong>各个result他之间</strong>的一个关系。能把各个result连接起来的这个东西叫做<strong>逻辑</strong>。通常你会发现好的文章下一个结果往往是上一个结果的延续。比如我图示的这篇文章，它会在第一个结果最后写上他的猜测。第二个结果写作的一开始她就会说。他为了证明上一个猜测。所以他进行了下一个试验。每一个result之间都是存在一定的因果关系或者是并列关系。<strong>所以我建议大家再看每个result的时候，可以拿一张纸在旁边写上他的逻辑线</strong>。也可以用一个软件叫Xmind来总结。等到整篇文章读完的时候，你会恍然大悟。这个时候你不仅学到了如何做一个课题，同时你也学到了如何思维缜密的去写作。</p>
<p>关于讨论部分，我认为你可以参照结果部分的标注来学习。但是有的讨论部分他并没有写出每一个小标题，而是一整个部分都是段落。这个时候我觉得你可以去找它的中心句来学习。他主要会在开头或段落的最后一句进行总结。而其他的句子往往是他这些总结的证据。当然。你还可以从中找到未来这个课题的研究方向。你也可以就此课题方向来进行研究，也可以发散思维去找别的方向。</p>
<p>当然大家在看的时候一定要不断地去思考，而不是干巴巴的读完了就完事儿了。换句话来说，如果交给你相同的实验和材料，你应该是怎样去做这个问题？</p>
<h3 id="四怎样才算看懂了文章">3.2.3 四、怎样才算看懂了文章？</h3>
<p>这个问题很简单，就是你已经能够脱稿输出这篇文章。大家也知道学习这个东西就是要有输入和输出，读文献只是一个输入的过程，往往只有将文献给大家听的时候，你才会知道哪些地方是你不懂的。如果你一旦把这篇文章完整的逻辑和他讲了什么问题，给大家说明的时候，这个时候就是你看懂了这篇文章。这也就是每个课题组组会讲文献所要达到的目的。</p>
<p><strong>（进阶版）</strong>最后，我将我现在的老板，他教我看文献的方法总结了几个小点分享给大家。</p>
<ol type="1">
<li><strong>好文章的本质</strong>：核心的点也就一两个，抓住就可以贯穿全文，全文都是围绕这个点来讲的。</li>
<li><strong>理解核心点</strong>：每个核心点通常在introduction上就能体现，而好文章的图都是能说明具体问题的，需要具有看图就能看明白核心点的本事。</li>
<li><strong>理清整篇文献的思路：</strong>好的文章应该是每个结果都会有关联，理清一条线就能说明白。</li>
<li>重点在于<strong>如果自己来做这篇文章</strong>，下一步会怎么做，和原作者有什么不同，进一步找出自己/文章的不足和优点。</li>
<li><strong>读懂一篇文章胜过略读几十篇文章。不要求速读，要确保你读懂每一篇好文章，慢慢累积，你就能达到看结果都知道是如何做的实验。</strong> <img src="https://pic2.zhimg.com/80/v2-2fdafcfddbc7bf1a8fbe5d02622f71a5_1440w.webp" alt="img"> <img src="https://pic2.zhimg.com/80/v2-9cb64491b2986501dafa3b53c773000d_1440w.webp" alt="img"></li>
</ol>
]]></content>
      <categories>
        <category>论文</category>
      </categories>
      <tags>
        <tag>文献阅读</tag>
      </tags>
  </entry>
  <entry>
    <title>技巧记录</title>
    <url>/2022/11/13/%E8%BD%AF%E4%BB%B6%E4%BD%BF%E7%94%A8/%E6%8A%80%E5%B7%A7%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<h1 id="如何把图片拼在一起">如何把图片拼在一起？</h1>
<p><strong>总结：</strong> 1. 用 PPT，以 <code>jpg</code> 格式导出，推荐。 2. 或用 PPT，将文字和图片组合。</p>
<p><strong>2022/11/13, 周日，研一上写材料</strong></p>
<ol type="1">
<li><a href="https://www.zhihu.com/question/471983711">如何把多张图片无缝拼接在一起？ - 知乎 (zhihu.com)</a></li>
<li><a href="https://imagestool.com/webp2jpg-online/splicing.html#/splicing">视频字幕拼接工具 (imagestool.com)</a></li>
<li><a href="https://jingyan.baidu.com/article/63acb44a1a1f8a61fcc17e20.html">如何利用word将两张图片合并成一张图片-百度经验 (baidu.com)</a></li>
</ol>
<blockquote>
<p>今天发现图片拼接使用 PPT 就可以，PPT 画示意图绝对要胜过其他 90%的软件，写博客也可以用 PPT 画图，上传网站，同时锻炼画图能力，一图胜千言。像 <a href="https://levitate-qian.github.io/">Levitate_ | 倘若正有一朵白云闪耀，那就望云爬坡吧。 (levitate-qian.github.io)</a> 里面的文章一样。</p>
</blockquote>
<ol type="1">
<li><p>保证图片本身清晰，还要放到 word 里清晰，这就需要裁剪，一裁剪，图片本身内容多少不同，裁剪出来的大小就不同，为了拼接，拉伸就得变</p></li>
<li><p>题注大小本身是相同的，只是图片大小不同，看起来不同</p></li>
<li><p>要做到相同，那就得截图，但是拼接起来图片太多太大，截图就不清楚了</p></li>
<li><p><a href="https://zhuanlan.zhihu.com/p/112342316">Word小技巧：怎么批量快速导出Word中的图片？ - 知乎 (zhihu.com)</a></p></li>
<li><p><a href="https://zhidao.baidu.com/question/687707175516616924.html">word文档里的组合图怎么存成图片格式？_百度知道 (baidu.com)</a></p></li>
<li><p><a href="https://zhidao.baidu.com/question/428561983.html#:~:text=方法：%201、打开word文档，插入图片--右键，将%22文字环绕%22设置为%22紧密型环绕%22（除嵌入型）。,2、插入一个文本框，输入文字，同样将%22文字环绕%22设置为%22紧密型环绕%22。%203、点击%22文字%22和图片，右键%22组合%22即可。">word怎么把图片和他的说明文字绑定在一起_百度知道 (baidu.com)</a></p></li>
<li><p><a href="https://jingyan.baidu.com/article/37bce2be1df2d11002f3a21c.html">word中如何将文本框与图片组合到一起-百度经验 (baidu.com)</a></p></li>
</ol>
]]></content>
      <categories>
        <category>软件使用</category>
      </categories>
  </entry>
  <entry>
    <title>羽毛球fig</title>
    <url>/2022/11/13/%E7%BE%BD%E6%AF%9B%E7%90%83/%E7%BE%BD%E6%AF%9B%E7%90%83fig/</url>
    <content><![CDATA[<p><img src="https://cdn.staticaly.com/gh/peirsist/blog_img@master/Snipaste_2022-11-12_19-50-03.6mjy5500cec0.png" alt="Snipaste_2022-11-12_19-50-03"></p>
]]></content>
      <categories>
        <category>羽毛球</category>
      </categories>
      <tags>
        <tag>羽毛球</tag>
      </tags>
  </entry>
  <entry>
    <title>旅游</title>
    <url>/2022/10/24/%E9%9A%8F%E7%AC%94%E4%B8%8E%E4%B8%AA%E4%BA%BA%E6%96%87%E9%9B%86/1-0%E6%97%85%E6%B8%B8/</url>
    <content><![CDATA[<figure>
<img src="https://cdn.staticaly.com/gh/peirsist/blog_img@master/Snipaste_2022-11-13_12-07-58.437qqwwtyeq0.png" alt="Snipaste_2022-11-13_12-07-58"><figcaption aria-hidden="true">Snipaste_2022-11-13_12-07-58</figcaption>
</figure>
]]></content>
      <categories>
        <category>随笔与个人文集</category>
      </categories>
      <tags>
        <tag>旅游</tag>
      </tags>
  </entry>
  <entry>
    <title>LaTex字体</title>
    <url>/2022/11/14/%E8%BD%AF%E4%BB%B6%E4%BD%BF%E7%94%A8/LaTex%E5%AD%97%E4%BD%93/</url>
    <content><![CDATA[<ol>
<li><a href="https://blog.csdn.net/z_feng12489/article/details/90449495">LaTex支持中文的三种方式_TransientYear的博客-CSDN博客_latex 中文</a></li>
<li><a href="https://blog.csdn.net/HanLiangJ/article/details/121986350">Latex 使用自己安装的自定义字体 教程_HanLiangJ的博客-CSDN博客_latex自定义字体</a></li>
<li><a href="https://blog.csdn.net/xiazdong/article/details/8892070">【LaTeX入门】03、设置字体相关命令_xiazdong的博客-CSDN博客_selectfont</a></li>
<li><a href="https://blog.csdn.net/robert_chen1988/article/details/52746354">latex设置页面边距，页面大小，页边距，geometry宏包_心态与做事习惯决定人生高度的博客-CSDN博客_geometry latex</a></li>
<li><a href="https://blog.csdn.net/xovee/article/details/121595086">LaTeX 页面大小和页边距_Xovee的博客-CSDN博客_latex 页边距</a></li>
<li><a href="https://blog.csdn.net/qq_35091353/article/details/111403178">Latex中插入图片_还能坚持的博客-CSDN博客_latex插入图片</a></li>
<li><a href="https://blog.csdn.net/ProgramChangesWorld/article/details/51429138">LaTeX技巧001：ctex下使用其他中文字体_潘建成的博客-CSDN博客</a></li>
</ol>
<h1 id="1-使用中文并设置字体字号页边距"><a href="#1-使用中文并设置字体字号页边距" class="headerlink" title="1 使用中文并设置字体字号页边距"></a>1 使用中文并设置字体字号页边距</h1><h2 id="1-1-设置中文"><a href="#1-1-设置中文" class="headerlink" title="1.1 设置中文"></a>1.1 设置中文</h2><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\documentclass</span>[UTF8]&#123;article&#125;</span><br><span class="line"><span class="keyword">\usepackage</span>&#123;CTEX&#125;</span><br></pre></td></tr></table></figure>



<p>其中<code>\kaishu</code>、<code>\heiti</code>、<code>\fangsong</code>、<code>\lishu</code>、<code>\youyuan</code>、<code>\songti</code>是ctex已定义好的可以直接使用。</p>
<h2 id="1-2-字体字号"><a href="#1-2-字体字号" class="headerlink" title="1.2 字体字号"></a>1.2 字体字号</h2><p><img src="https://img-blog.csdnimg.cn/20200128004222504.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDAyNjAyNg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/20200128004221643.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDAyNjAyNg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>　</p>
<p><strong>字号行间距</strong></p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\newcommand</span>&#123;<span class="keyword">\yihao</span>&#125;&#123;<span class="keyword">\fontsize</span>&#123;26pt&#125;&#123;36pt&#125;<span class="keyword">\selectfont</span>&#125;           <span class="comment">% 一号, 1.4 倍行距</span></span><br><span class="line"><span class="keyword">\newcommand</span>&#123;<span class="keyword">\erhao</span>&#125;&#123;<span class="keyword">\fontsize</span>&#123;22pt&#125;&#123;28pt&#125;<span class="keyword">\selectfont</span>&#125;          <span class="comment">% 二号, 1.25倍行距</span></span><br><span class="line"><span class="keyword">\newcommand</span>&#123;<span class="keyword">\xiaoer</span>&#125;&#123;<span class="keyword">\fontsize</span>&#123;18pt&#125;&#123;18pt&#125;<span class="keyword">\selectfont</span>&#125;          <span class="comment">% 小二, 单倍行距</span></span><br><span class="line"><span class="keyword">\newcommand</span>&#123;<span class="keyword">\sanhao</span>&#125;&#123;<span class="keyword">\fontsize</span>&#123;16pt&#125;&#123;24pt&#125;<span class="keyword">\selectfont</span>&#125;        <span class="comment">% 三号, 1.5倍行距</span></span><br><span class="line"><span class="keyword">\newcommand</span>&#123;<span class="keyword">\xiaosan</span>&#125;&#123;<span class="keyword">\fontsize</span>&#123;15pt&#125;&#123;22pt&#125;<span class="keyword">\selectfont</span>&#125;        <span class="comment">% 小三, 1.5倍行距</span></span><br><span class="line"><span class="keyword">\newcommand</span>&#123;<span class="keyword">\sihao</span>&#125;&#123;<span class="keyword">\fontsize</span>&#123;14pt&#125;&#123;21pt&#125;<span class="keyword">\selectfont</span>&#125;            <span class="comment">% 四号, 1.5 倍行距</span></span><br><span class="line"><span class="keyword">\newcommand</span>&#123;<span class="keyword">\banxiaosi</span>&#125;&#123;<span class="keyword">\fontsize</span>&#123;13pt&#125;&#123;19.5pt&#125;<span class="keyword">\selectfont</span>&#125;    <span class="comment">% 半小四, 1.5倍行距</span></span><br><span class="line"><span class="keyword">\newcommand</span>&#123;<span class="keyword">\xiaosi</span>&#125;&#123;<span class="keyword">\fontsize</span>&#123;12pt&#125;&#123;18pt&#125;<span class="keyword">\selectfont</span>&#125;            <span class="comment">% 小四, 1.5倍行距</span></span><br><span class="line"><span class="keyword">\newcommand</span>&#123;<span class="keyword">\dawuhao</span>&#125;&#123;<span class="keyword">\fontsize</span>&#123;11pt&#125;&#123;11pt&#125;<span class="keyword">\selectfont</span>&#125;       <span class="comment">% 大五号, 单倍行距</span></span><br><span class="line"><span class="keyword">\newcommand</span>&#123;<span class="keyword">\wuhao</span>&#125;&#123;<span class="keyword">\fontsize</span>&#123;10.5pt&#125;&#123;15.75pt&#125;<span class="keyword">\selectfont</span>&#125;    <span class="comment">% 五号, 单倍行距</span></span><br></pre></td></tr></table></figure>

<p><code>\song\xiaosi </code>可以快速设置为“宋体，小四，1.5 倍行距”</p>
<h2 id="1-3-页边距"><a href="#1-3-页边距" class="headerlink" title="1.3 页边距"></a>1.3 页边距</h2><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\usepackage</span>&#123;geometry&#125;</span><br><span class="line"><span class="keyword">\geometry</span>&#123;a4paper,left=2cm,right=2cm,top=1cm,bottom=1cm&#125;</span><br></pre></td></tr></table></figure>



<h2 id="1-4-另起一页"><a href="#1-4-另起一页" class="headerlink" title="1.4 另起一页"></a>1.4 另起一页</h2><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\clearpage</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>软件使用</category>
      </categories>
      <tags>
        <tag>LaTex</tag>
      </tags>
  </entry>
  <entry>
    <title>推挑后场</title>
    <url>/2022/11/15/%E7%BE%BD%E6%AF%9B%E7%90%83/01-4%E6%8E%A8%E6%8C%91%E5%90%8E%E5%9C%BA/</url>
    <content><![CDATA[<h1 id="什么是挡远网抓推"><a href="#什么是挡远网抓推" class="headerlink" title="什么是挡远网抓推"></a>什么是挡远网抓推</h1><p><a href="https://zhuanlan.zhihu.com/p/104194224">浅谈羽毛球挡近网和挡远网及其优劣势 - 知乎 (zhihu.com)</a><br><a href="https://zhuanlan.zhihu.com/p/104380073">什么是挡远网抓推,如何破解 - 知乎 (zhihu.com)</a></p>
<p><a href="https://www.bilibili.com/video/BV1UX4y1G7Sf/?spm_id_from=333.1007.top_right_bar_window_history.content.click&vd_source=83831fc0970a6c8704479f7cfc679937">被林丹控底线控得“怀疑人生”【推挑技战术赏析】_哔哩哔哩_bilibili</a></p>
<p>🔱“丹强在体能好，防守好，这是基础层面。拿点低，后场除杀球外几乎击球点偏低偏后，推挑弧度适合且到位，控转身抓过渡利用好，这是战术层面。挡远网抓推利用如臻化境，这是技术层面。三种层面缺一不可，才造就了羽毛球历史上最强的王者。补充一点，我认为林丹的拿点低也是关键。正因为拿点低，所以给远网，同时放弃网前争夺，高点抢搓拿进攻机会，而是推挑控转身抓过渡，跑动自然而然就少了”</p>
<p>虽然看似说了一句废话，但是很有道理，让别人跑动多，自己就可以跑动少。<br><img src="https://cdn.staticaly.com/gh/peirsist/blog_img@master/Snipaste_2022-11-15_14-07-42.2mkb6xt72tm0.png" alt="Snipaste_2022-11-15_14-07-42"></p>
<p>本质还是核心 bug 级别，力量和速度都史强，进攻端和防守端的硬实力都太恐怖，进攻强对手不愿起高，林丹可以稳定在中前场控球形成恶性循环，防守强所以放心推挑，万一失控也能救回来。这和老李靠变态速度其实一样的。俩本质上还是身体素质领先其他人太多</p>
<p>防杀球正常人都是随便一个网前，而🥚直接就精准对角无法接受</p>
]]></content>
      <categories>
        <category>羽毛球</category>
      </categories>
      <tags>
        <tag>羽毛球</tag>
      </tags>
  </entry>
  <entry>
    <title>追剧</title>
    <url>/2022/11/15/%E9%9A%8F%E7%AC%94%E4%B8%8E%E4%B8%AA%E4%BA%BA%E6%96%87%E9%9B%86/%E8%BF%BD%E5%89%A7/</url>
    <content><![CDATA[<ol type="1">
<li>垫底辣妹</li>
<li><a href="https://www.bilibili.com/video/BV1y84y1v7JA/?spm_id_from=333.1007.tianma.3-4-8.click&amp;vd_source=83831fc0970a6c8704479f7cfc679937">【妖叔】一口气看完《人世间》：结合原著深度解读，感动无数观众的催泪神剧。_哔哩哔哩_bilibili</a></li>
<li></li>
</ol>
]]></content>
      <categories>
        <category>随笔与个人文集</category>
      </categories>
  </entry>
  <entry>
    <title>常用的好用软件记录</title>
    <url>/2022/11/16/%E8%BD%AF%E4%BB%B6%E4%BD%BF%E7%94%A8/%E5%B8%B8%E7%94%A8%E7%9A%84%E5%A5%BD%E7%94%A8%E8%BD%AF%E4%BB%B6%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<h1 id="编辑器">编辑器</h1>
<h2 id="sublime-text-3">Sublime Text 3</h2>
<ol type="1">
<li>优点启动非常快，配合 Sumatra PDF 用来写 LaTex，非常不错。</li>
<li>还可以用来写 markdown，看 Python 代码。</li>
<li>推荐 <code>ayu</code> 主题，如下图。 <img src="https://cdn.staticaly.com/gh/peirsist/blog_img@master/Snipaste_2022-11-16_17-39-18.5tkbtnaql1s0.png" alt="Snipaste_2022-11-16_17-39-18"></li>
</ol>
<h2 id="vs-code">VS Code</h2>
<ol type="1">
<li>推荐 Monoki 配色，因为这个配色可以看出哪个是 class，很方便。</li>
<li>VS code 用来看 C、C++ 代码很好。 <img src="https://cdn.staticaly.com/gh/peirsist/blog_img@master/Snipaste_2022-11-16_17-42-34.2vkujcto7i60.png" alt="Snipaste_2022-11-16_17-42-34"></li>
</ol>
<h1 id="pdf">PDF</h1>
<ol type="1">
<li>Wondershare PDFelement <img src="https://cdn.staticaly.com/gh/peirsist/blog_img@master/Snipaste_2022-11-16_17-44-43.4vwj5dt40ie0.png" alt="Snipaste_2022-11-16_17-44-43"></li>
</ol>
<h1 id="文献管理">文献管理</h1>
<p>以下三个都下载了，很习惯 zotero</p>
<ol type="1">
<li>zotero</li>
<li>EndNote</li>
<li>NoteExpress</li>
</ol>
]]></content>
      <categories>
        <category>软件使用</category>
      </categories>
  </entry>
  <entry>
    <title>研究生学到的</title>
    <url>/2022/11/18/00%E7%A0%94%E7%A9%B6%E7%94%9F/%E7%A0%94%E7%A9%B6%E7%94%9F%E5%AD%A6%E5%88%B0%E7%9A%84%E4%B8%9C%E8%A5%BF/</url>
    <content><![CDATA[<h1 id="教训">教训</h1>
<ol type="1">
<li><strong>永远不要什么人的话都相信，尤其在你没了解这个人的时候，自己要去了解形成自己的判断</strong>。谁都会说好听的，有的人全凭一张嘴，就会忽悠人，啥都不会。想想保研，完全就是被骗了。</li>
</ol>
<blockquote>
<p><strong>错误</strong> 1. 比如，说“实验室氛围是最好的”，你说最好就是最好的啊???，真是搞笑</p>
<p><strong>错误</strong> 2. 说“实验室不挑人”，你不想想为啥不挑人嘛，好的实验室会不挑人嘛？不挑人必有坑啊！There is no free lunch in the world.</p>
</blockquote>
<p>瓶颈期可太真实了，旧方向卷不过其他人，想开新方向还不愿意投入时间精力，动不动还忆往昔追忆 n 年前的辉煌。同时让几个学生去干不同的新方向，等学生给他汇报讲解新方向，一人走歪全体走歪无人纠错，退学的退学延毕的延毕。</p>
<ol start="2" type="1">
<li><strong>什么事不到最后一刻都说不准</strong>。比如保研的时候，提前和某一个老师说好，但不到最后填系统最后一刻，什么都可以变。（师兄读博、自己的教训）</li>
</ol>
]]></content>
      <categories>
        <category>研究生</category>
      </categories>
  </entry>
  <entry>
    <title>一些网址</title>
    <url>/2022/11/18/%E9%9A%8F%E7%AC%94%E4%B8%8E%E4%B8%AA%E4%BA%BA%E6%96%87%E9%9B%86/%E4%B8%80%E4%BA%9B%E7%BD%91%E5%9D%80/</url>
    <content><![CDATA[<ol type="1">
<li><a href="https://www.gpdf.net/">书行万里 – PDF电子书下载站 (gpdf.net)</a></li>
<li><a href="https://www.huibooks.com/506.html">毫无意义的工作 -pdf,txt,mobi,azw3,epub电子书免费下载 汇书网 (huibooks.com)</a></li>
</ol>
<h1 id="党-ppt-模板">党 PPT 模板</h1>
<ol type="1">
<li><a href="https://www.51pptmoban.com/zhuti/dangjianPPTmoban/">党建ppt模板,党建工作汇报ppt模板,党建思想汇报ppt模板,党课心得体会ppt模板 - 51PPT模板网 (51pptmoban.com)</a></li>
<li><a href="https://www.1ppt.com/moban/dangzheng/">党建PPT模板_党建工作汇报PPT模板_党政PPT模板下载 - 第一PPT (1ppt.com)</a></li>
</ol>
]]></content>
      <categories>
        <category>随笔与个人文集</category>
      </categories>
  </entry>
  <entry>
    <title>Beamer</title>
    <url>/2022/11/19/%E8%BD%AF%E4%BB%B6%E4%BD%BF%E7%94%A8/Beamer/</url>
    <content><![CDATA[<p>为了达到在每个章节前面显示目录的效果，基本的思想是：在每个章节开始的时候新建一个帧（frame），帧的内容是当前的章节。具体来说，使用的是如下代码。</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\AtBeginSection</span>[]</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">\begin</span>&#123;frame&#125;&#123;主要内容&#125;</span><br><span class="line">		<span class="keyword">\transfade</span><span class="comment">%淡入淡出效果</span></span><br><span class="line">		<span class="keyword">\tableofcontents</span>[sectionstyle=show/shaded,subsectionstyle=show/shaded/hide] <span class="comment">%这几个参数我也不知道该如何准确地解释，反正它们最终的效果是突出显示当前章节，而其它章节都进行了淡化处理</span></span><br><span class="line">		<span class="keyword">\addtocounter</span>&#123;framenumber&#125;&#123;-1&#125;  <span class="comment">%目录页不计算页码</span></span><br><span class="line">	<span class="keyword">\end</span>&#123;frame&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>软件使用</category>
      </categories>
      <tags>
        <tag>LaTex</tag>
      </tags>
  </entry>
  <entry>
    <title>如何学习</title>
    <url>/2022/11/19/%E9%9A%8F%E7%AC%94%E4%B8%8E%E4%B8%AA%E4%BA%BA%E6%96%87%E9%9B%86/%E5%A6%82%E4%BD%95%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<p>2022/11/19</p>
<p>今天看强化学习，只看一遍肯定会忘的，所以要总结一下，然后说出来，讲给别人听。（<strong><font color="red">说处理与不说出来自己想有很大区别，自己想你认为你理解了，其实说出来你就会发现你没理解</font></strong>）, 教授给他人是最好的学习方法。</p>
<p><img src="https://bkimg.cdn.bcebos.com/pic/b90e7bec54e736d193aa0f1f94504fc2d5626968?x-bce-process=image/watermark,image_d2F0ZXIvYmFpa2UxMTY=,g_7,xp_5,yp_5"></p>
]]></content>
      <categories>
        <category>随笔与个人文集</category>
      </categories>
      <tags>
        <tag>学习方法</tag>
      </tags>
  </entry>
  <entry>
    <title>报名网课-雅思阅读</title>
    <url>/2022/11/14/%E8%8B%B1%E8%AF%AD%E5%AD%A6%E4%B9%A0/%E7%BD%91%E8%AF%BE-%E9%9B%85%E6%80%9D%E9%98%85%E8%AF%BB/</url>
    <content><![CDATA[<p>报名网课时间：2022&#x2F;11&#x2F;14<br>口语、阅读、写作</p>
<blockquote>
<ol>
<li><a href="https://shop107369946.youzan.com/wscvis/course/detail/2ogxqa4c82vb6hj?kdt_id=107177778&fromColumn=2fqtle7vhmy2qil">雅思写作</a></li>
<li><a href="https://shop107369946.youzan.com/wscvis/course/detail/36d35wedcjbz6x9?kdt_id=107177778&fromColumn=1yj7r1wwq1t6a1t&pageType=KNOWLEDGE">雅思阅读</a></li>
<li><a href="https://shop107369946.youzan.com/wscvis/course/detail/2os0to4vre77mla?kdt_id=107177778&is_share=1">耕伟学长的【14天雅思口语加速营】 (youzan.com)</a></li>
<li><a href="https://www.bilibili.com/video/BV1UW4y1H7nc/?spm_id_from=333.1007.top_right_bar_window_history.content.click&vd_source=83831fc0970a6c8704479f7cfc679937">中英文语性语法的不同_哔哩哔哩_bilibili</a></li>
<li><a href="https://www.bilibili.com/video/BV1rb4y1b7Ke/?spm_id_from=333.788.top_right_bar_window_history.content.click&vd_source=83831fc0970a6c8704479f7cfc679937">【公开课】英文写作有诀窍 - 刘美君（完整版）_哔哩哔哩_bilibili</a></li>
</ol>
</blockquote>
<blockquote>
<p><strong><font color="red">精读文章，听只是第一步，关键听完之后还要把其中的生词整理出来，并且背诵下来，potentially time-consuming，可能比较花时间的。但是一定要坚持。在阅读中高效率地把单词拿下</font></strong></p>
</blockquote>
<blockquote>
<p><strong><font color="red">做题方法的感受以及单词量的积累</font></strong></p>
</blockquote>
<ol>
<li><a href="https://zhuanlan.zhihu.com/p/480602125">aim at、aim to do、aim for用法和区别（估计最全了） - 知乎 (zhihu.com)</a></li>
<li><a href="https://zhidao.baidu.com/question/750999831648674492.html?qbl=relate_question_0">leave sth behind 和leave behind sth有什么不同？_百度知道 (baidu.com)</a></li>
<li><a href="https://zhidao.baidu.com/question/16758530.html">问一下(off,along,on,around)+the coast 分别是什么意思？有什么区别？_百度知道 (baidu.com)</a></li>
</ol>
<p>off the coast、along the coast、on the coast、around the coast 的区别为：指代不同、用法不同、侧重点不同，意思如下：</p>
<p>一、指代不同</p>
<p>1、off the coast：在海岸外。</p>
<p>2、along the coast：沿海岸线。</p>
<p>3、on the coast：在海岸上。</p>
<p>4、around the coast：在海岸附近。</p>
<h1 id="1-2022-x2F-11-x2F-19晚开营"><a href="#1-2022-x2F-11-x2F-19晚开营" class="headerlink" title="1 2022&#x2F;11&#x2F;19晚开营"></a>1 2022&#x2F;11&#x2F;19晚开营</h1><p><strong>Group Notice</strong></p>
<p>各位备考雅思阅读的小伙伴好（应该很多都是老朋友了），我是耕伟~<br>欢迎加入【耕伟学长的 20+8 天雅思阅读加速营】。<br>阅读营即将开始，我跟大家说一说安排以及一些注意事项~<br>【一共有 10 个小点】，大家如果有任何问题可以我说完之后再一起提问哈~~</p>
<p><strong>1）关于【所用资料】</strong> </p>
<p>这一项最为重要，所以放在第一点说。<br>【阅读营讲义】我会等下发给大家电子版。 另外我们会用到《剑桥雅思真题集 15》、《剑桥雅思真题集 16》和《剑桥雅思真题集 17》作为练习资料，需要同学自己准备一下【纸质版书籍】（各大网上书店和线下书店都有卖）or 【电子版】（电子版涉及版权问题，我这边无法分享给大家哈）or 【新东方&#x2F;小站雅思的免费模考软件】 （注意我们需要的是《剑桥雅思真题集》，不是《剑桥雅思真题精讲》，不要买错了哈）</p>
<p><strong>2）关于进度</strong> </p>
<p>时间比较充裕的同学可以跟着我们【微信群的进度走】，每天的具体安排和【课程目录】中的【DayXX】一致。 <strong>每天【学视频+消化方法论+记忆单词】的时间大概在【2.5 小时】左右。</strong><br>考试迫在眉睫的同学可以自己适当往前赶，目前【所有录播课程】的权限都已经解锁。 阅读营之所以叫【20+8 天的阅读营】，是因为【前 20 天】是统一的进度，我们共同完成《剑雅 16》和《剑雅 15》，【后 8 天】是大家自行安排（建议考前进行），练习的是最新的那本《剑雅 17》。 （如果【时间特别特别紧（＜10 天）】的同学，也可以在学习了 Day1-4 之后，直接进入《剑雅 17》。其他同学还是建议循序渐进）</p>
<p><strong>3）关于每天的任务</strong> </p>
<p>有同学可能有疑问：课程都全部解锁了，这个营（群）用来干啥？<br>答案是：<strong>我会在这个群内，给大家布置每一天的【作业】，并把当天大家犯的一些共性的错总结出来，用于大家巩固当日所学。</strong><br>这一项很重要，可以让大家对视频内容的吸收效果提高到 120%，所以建议大家至少【每晚 21:00 】来群里看一下我发的信息，以免错过重要内容！！！！！</p>
<p><strong>4）关于提交作业+答疑</strong> </p>
<p>这个群我们主要用来【发通知】。 </p>
<p>【作业提交】部分，请大家加一下群里的【亮亮】（如下），他是我们阅读营的小助手，之后每天的作业是【提交给他】，也由他【发送福利资料】给大家。 除此之外的【所有问题】（【学术疑问】or【报班咨询】等），大家依然【找我】哈。简言之就是：【领资料】找亮亮，【学英语】找我~~ （另外，我特意嘱咐亮亮【在收作业时需要比我还严格】，所以大家一定保质保量完成作业哦~）</p>
<p><strong>5）关于群内秩序</strong> </p>
<p>大家有什么想要和大家讨论的雅思阅读的问题可以在群里发言，但也请注意不要发【无关信息】和【商业广告】。</p>
<p><strong>6）课程在哪里看？</strong> </p>
<p>在大家【购买课程】的这个链接里就可以看了。<br>【手机端】或【电脑端】的微信都可以观看，建议电脑端打开，大屏观看更舒适。</p>
<p><strong>7）关于【单词积累】</strong> </p>
<p>我相信，营里的很多同学都在之前欠下了或多或少的【单词债】，并且还没有时间补，而<strong>雅思阅读又是一个【单词量的测试】</strong>。所以，**<font color="red">我在阅读营中花大力气录制了【精读视频】，把每一篇文章的【字、词、句】都做了精讲，所以请【单词基础薄弱】的同学千万要认真对待【精读视频】。 </font>**</p>
<p><strong>虽然每一个视频动辄 30-40min，但你能积累起的单词数量也是惊人的。一定要趁着这次机会把单词拿下。我相信这也是大家在其他机构或者自学时无暇顾及的层面</strong>，因此我一定要拿出来重点说！！ </p>
<p>每一套题目的单词学习，我都为大家安排了三个步骤去逐步加深印象、最终拿下单词：**<font color="red">【精读视频学习单词】+【自己背诵单词】+【从亮亮那里领测试题检测单词】</font>**。除开这三个步骤， <strong><font color="red">也强烈建议大家根据自身情况安排单词的复习+检测。之前有同学阅读从 6.5→8，就是严格做好了这些事情。</font></strong> </p>
<p><strong>8）关于【做题方法论】</strong> </p>
<p>关于方法论（也就是所谓的阅读顺序+解题技巧），我说两点我觉得最重要的： </p>
<ol>
<li><strong>方法论是有用的</strong>，可以帮助【各种水平的同学】提升【至少 1 分】。如：5 分→6 分，7 分→8 分。 </li>
<li><strong>方法论没那么多，不要神化它</strong>。<strong>而且一定是在做题中去体会方法论</strong>。如果是在其他机构【已经学习了十几个小时方法论但还不会做题的同学】，大家一定会在阅读营中收获很大！基本上到【阅读营 50%】的时候，大家就能够和我一样去【预判出题点→同步阅读文章+做题→读完文章就做完题】，到时候大家会很爽！因此，希望大家多注意每天的【精讲视频】，里面都是这些技巧的实操！！！！！</li>
</ol>
<p><strong><font color="red">单词的重要性不仅会贯穿雅思阅读，也关乎雅思其他三科，还涉及到大家以后的求学与工作，所以趁这次机会最后冲一把吧！</font></strong></p>
<p><strong>9）关于【是否限时做题】</strong> </p>
<p>简单来说，【基础薄弱】的同学建议【阅读营的前 50%】都不用限时做题，重点是【好好体会方法论】；到后期再限时。 </p>
<p>基础比较好的同学可以【在一开始】就限时，但如果觉得水土不服，也可以立刻放缓脚步。再次强调，初期【好好体会方法论】才是重点。</p>
<p><strong>10）关于【语法基础】</strong> </p>
<p>大家【不需要单独去学习语法】。 </p>
<p>阅读营的【精读视频】我会讲到每句话的语法，能够解决大家的大部分语法疑惑。<br>但因为视频时长所限，一些语法点不能展开，大家这个时候可以结合【百度 or 知乎】去搜索对应语法点来补坑。 </p>
<p>如，我在视频里可能提到：这是一个【虚拟语气，是对将来的虚拟】，大家如果虚拟语气掌握得不好，就应该去【百度 or 知乎】搜索【虚拟语气使用方法】，补全整个小体系。</p>
<p><strong>最后，关于鼓励</strong> </p>
<p>请大家树立起一个认知：**<font color="red">雅思【阅读备考】是最需要踏踏实实、最艰辛的。</font>** </p>
<p>从今天起，请扫荡那些【不需要读懂文章也能做题】的幻想。这种想法也许会让大家【出于猎奇而快速开始学习】，却也一定会让我们在【真正做题时梦碎一地】。</p>
<p><strong><font color="red">所以，请放下速成的想法，开始跬步的积累。虽然走得会很慢，但会很安心，也会让大家今后的英语学习更光明正大、更胸有成竹。</font></strong> </p>
<p>同时，也请大家合理安排自己的时间，尤其是同时加入【写作营】和【口语营】的同学（每个营的付出时间分别是**<font color="red">【阅读 2.5 小时&#x2F;天，写作 2.5 小时&#x2F;天，口语 3.5 小时&#x2F;天】</font>**如果现在预估自己的时间不够的同学，也可以【今天之内】私信告诉我，把你的【阅读营】调整到下一期：12.1）</p>
<p>明天是【Day1】。 </p>
<p>具体任务如下： </p>
<ol>
<li>观看对应视频《Day1：雅思阅读总览》 </li>
<li>限时 60min 做完《剑桥雅思 16-Test1》的 3 篇阅读（一定要做，而且需要限时） 。目的是：了解目前分数</li>
</ol>
<p>⚫ 笔考同学：推荐使用纸质版本《剑桥雅思》（书后面有参考答案） </p>
<p>⚫ 机考同学：推荐使用免费的【新东方模考系统】（系统会自动评分） </p>
<p>新东方模考系统链接： <a href="https://ieltscat.xdf.cn/mock/detail/read/5304361">https://ieltscat.xdf.cn/mock/detail/read/5304361</a> 。</p>
<blockquote>
<p>第一次《剑 17-Test1 》5.5 分</p>
</blockquote>
<h1 id="2-2022-x2F-11-x2F-20"><a href="#2-2022-x2F-11-x2F-20" class="headerlink" title="2 2022&#x2F;11&#x2F;20"></a>2 2022&#x2F;11&#x2F;20</h1><p><strong>Group Notice</strong></p>
<p>大家晚上好，今天是阅读营【Day1】，今天的视频很短很简单，但今天的作业…… 可能是一个 daunting task，不知道大家完成得如何呢？【模考】得了几分呢？ </p>
<p>大家可以把自己的分数记下来，然后等到【阅读营过半】、【阅读营结束】时，再来对比那个时候的模考分数，看看自己有多大的提升（提升的前提是：<strong>每天坚持精读+分析题目哦</strong> ） </p>
<p>明天是【Day2】(2022&#x2F;11&#x2F;21)，我们将要开始正式的【阅读方法论】的学习。【方法论】不多，就分成【上、中、下】，分别会在明天、后天、大后天进行（再次验证了我说的：<strong>方法论不多，不要过度神化方法论</strong>）。 </p>
<p>明天学到的题型是雅思阅读【最常见 and 最简单】的两种：【判断题】、【填空题】。大家一定要认真听。<strong>这两种题型基本决定了大家【阅读第一篇文章的分数高低】</strong>。<br>大家着重需要注意两点： </p>
<ol>
<li>这两种题型的 <strong><font color="red">【关键词预读规则】</font></strong> （读文章前要不要预读题目？读多少？） </li>
<li>感受【题目答案】和【原文】的【同义改写】，<strong>体会【雅思官方】经常设置的<font color="red">【同义改写套路】</font>是什么。</strong></li>
</ol>
<p>明天的作业有 2： </p>
<ol>
<li>体会、消化【方法论】； </li>
<li>观看【剑雅 16-Test1-1】的【精读视频】，在文章中【批注生词】。然后把【拍照发给亮亮】，找他领取【福利资料】。</li>
</ol>
<p>给大家看一个我觉得比较满意的精读样例（这位同学我忘记是谁了。。。感谢你的图），大家的【精读批注详细程度】都请至少做到这种水平哈~</p>
<h1 id="3-2022-x2F-11-x2F-21"><a href="#3-2022-x2F-11-x2F-21" class="headerlink" title="3 2022&#x2F;11&#x2F;21"></a>3 2022&#x2F;11&#x2F;21</h1><p><strong>Group Notice</strong></p>
<p>大家晚上好，今天是【Day2】。今天我们学习了雅思阅读中可以说最重要、最基础的两个题型：【判断题】和【填空题】。 </p>
<h2 id="3-1-【判断题】和【填空题】"><a href="#3-1-【判断题】和【填空题】" class="headerlink" title="3.1 【判断题】和【填空题】"></a>3.1 【判断题】和【填空题】</h2><p>这两种题型的最核心破题关键是： </p>
<ol>
<li>**<font color="red">题目【内部】是【顺序出题】的</font>**。 </li>
<li>因为1），所以：我们在读文章前的【预读关键词环节】，<strong>只需要读【判断题的前2题】or【填空题的前2空】。</strong></li>
</ol>
<p>另外，雅思阅读的【第一篇文章】如果刚好由【判断题+填空题】组成，那么这两种题型对应的【原文的出题位置】也大几率是【判断题–原文的前50%】，【填空题–原文的后50%】，这个技巧大家先有一个印象，以后会随着做题越来越多，能有更深刻的感受。 </p>
<p>明天是【Day3】，是我们的【阅读方法论（中）】，会讲到另外两种重要的题型：【Heading题】和【多选题】，这两种题型可以说在【做题难度上陡增】，大家明天好好听听。 </p>
<p>明天的作业，依然需要大家完成【精读笔记的批注】，然后来找【亮亮】领取【附加资料】。大家加油！</p>
<h1 id="4-2022-x2F-11-x2F-22"><a href="#4-2022-x2F-11-x2F-22" class="headerlink" title="4 2022&#x2F;11&#x2F;22"></a>4 2022&#x2F;11&#x2F;22</h1><p><strong>Group Notice</strong><br>大家晚上好，今天是【Day3】。今天我们学习了雅思阅读中可以说【最难】的两个题型：【Heading题】和【多选题】。 </p>
<p>这两种题型的最核心破题关键是： </p>
<h2 id="4-1-【Heading题】"><a href="#4-1-【Heading题】" class="headerlink" title="4.1 【Heading题】"></a>4.1 【Heading题】</h2><p><strong>终极原则：考察的是阅读能力，只有真正读懂了段落+标题，才能选对</strong>。是【最没啥技巧可言】的题目类型。<br>可以用到的为数不多的技巧： </p>
<ol>
<li>画出每道题的关键词，画完之后可以【联想原文可能会怎么照应】 </li>
<li>画关键词时，注意一些虚词，如：单复数，a&#x2F;an之类的 </li>
<li>画出所有题目的关键词后，再整体读一遍【所有题目】，加深印象 </li>
<li>如果原文某一段涉及【其他更简单题型（如填空题）】，可以先去做那种题型以【以完善对本段落的理解】，然后再来做【Heading题】</li>
</ol>
<h2 id="4-2-【多选题】"><a href="#4-2-【多选题】" class="headerlink" title="4.2 【多选题】"></a>4.2 【多选题】</h2><ol>
<li>如果多选题的题干关键词是【全文中反复出现的】，那么需要【在阅读全文前】去预读多选题的【题干+所有选项】，然后开始读原文。 </li>
<li>原文每读完一个部分（如一个段落），就需要查看一下有没有涉及到某个选项。 </li>
<li>多选题的几个选项内部一般也是【顺序的】<br><strong>以上两种题型是雅思阅读中【几乎最难的题型】，既然没什么做题技巧，<font color="red">大家就更应该踏踏实实去【做精读】，提升【英语硬实力】。</font></strong></li>
</ol>
<p>明天是【Day4】，是我们的【阅读方法论（下）】，会讲到最后两种重要的题型：【单选题】和【人名信息匹配题】，难度也不低，大家明天好好听听。 </p>
<p>明天的作业，依然需要大家完成【精读笔记的批注】，然后找【亮亮】领取【附加资料】。大家加油！</p>
<h1 id="5-2022-x2F-11-x2F-23"><a href="#5-2022-x2F-11-x2F-23" class="headerlink" title="5 2022&#x2F;11&#x2F;23"></a>5 2022&#x2F;11&#x2F;23</h1><p><strong>Group Notice</strong><br>大家晚上好，今天是【Day4】。今天我们学习了雅思阅读的另外2个重要的题型：【单选题】和【人名信息匹配题】。<br>这两种题型的最核心破题关键是： </p>
<h2 id="5-1-【单选题】"><a href="#5-1-【单选题】" class="headerlink" title="5.1 【单选题】"></a>5.1 【单选题】</h2><ol>
<li>题干一般【会有明显的标志词】提醒我们这道题对应原文的什么地方，如【In the X paragraph】或是【特别容易定位】的词（人名、机构名、期刊名等）； </li>
<li>单选题内部也是【顺序出题】的。但需要注意，【不一定】是每一个段落都会出一道单选题，如：第1道单选题对应原文第一段，但第二道【不一定】对应第二段，可能对应第三段或是往后。 </li>
<li>既然比较容易知道【单选题对应原文的哪一段】，所以读原文前【不需要预读单选题选项】，可以等读完某一段后，再去直接做题。</li>
</ol>
<h2 id="5-2-【人名信息匹配题】"><a href="#5-2-【人名信息匹配题】" class="headerlink" title="5.2 【人名信息匹配题】"></a>5.2 【人名信息匹配题】</h2><ol>
<li>读原文前【不需要读每一个选项】，但需要熟悉【框格中的每一个人名】。 </li>
<li>在原文中【读到某一个人名的时候】，返回题目，读【所有选项】，看看有没有能做出来的题。 </li>
<li>需要注意，【框格中的每一个人名一定是“名+姓”这样的全程】，但原文中却不一定，可能是：【名+姓】，【姓】，【he&#x2F;she】，【the scientist、the reviewer之类的头衔】，必要时需要能够识别出是同一个人。</li>
</ol>
<blockquote>
<p><strong>看完精度视频后做题达到8分，可见雅思阅读考的就是</strong></p>
<ol>
<li><strong><font color="red">单词量和语法</font></strong></li>
<li><strong><font color="red">同义替换（本质还是单词量）</font></strong></li>
</ol>
</blockquote>
<p>从明天开始的【Day5+Day6】，我们就以【每两天为单位】，进入正式的【套题练习】阶段了~我来说一下具体的步骤： </p>
<ol>
<li>大家<strong>完成某套题目的3篇文章</strong>（可以限时，也可以不限时，前期建议【不限时】，而是充分去体会做题步骤） </li>
<li><strong>自己对答案、算分数</strong>（实力没有本质提升的前提下，分数上下波动1分或以内其实都是正常的，大家不用太在意） </li>
<li><strong>学习《原文精读视频》，做好【详细的精读笔记】</strong>（如果大家提交给【亮亮】的笔记太过简略（每篇文章的生词＜20词），他就没办法给大家相应的补充资料了） </li>
<li><strong>学习《题目精讲视频》</strong>。<strong>尤其注意【视频前部分的“根据题目预判出题点”】的讲解，这是基本上所有参考书、以及很多课上老师都不会讲的内容，但却对我们做题的效率+正确率大有帮助</strong>，**<font color="red">请大家一定重视！！！</font>**</li>
<li><strong>提交给亮亮【精读笔记（需要是3篇的笔记）】</strong>，领取【额外资料】，进行【单词背诵+测试】</li>
</ol>
<p>尤其需要注意，大家在做题的时候，一定有【题目是不确定的】，做的时候请记录一下，然后在后期学视频的时候专门研究下。<strong>尤其是那些【侥幸对了的题目】，都是些隐藏的地雷。</strong> </p>
<p>以上的内容，我们用【2天】去完成，至于这2天内具体如何分配时间和任务，就看大家自己了。我也会【每两天在群里发送一次通知】。 </p>
<p>万里长征的高强度阅读学习，明天开始！！！（这几天大家提交的精读笔记真的是张灯结彩、让人目眩神驰，给人很大的满足感和充实感！大家继续加油~~）</p>
<h1 id="6-2022-x2F-11-x2F-24-25-《剑雅-16-Test2》"><a href="#6-2022-x2F-11-x2F-24-25-《剑雅-16-Test2》" class="headerlink" title="6 2022&#x2F;11&#x2F;24-25 《剑雅 16-Test2》"></a>6 2022&#x2F;11&#x2F;24-25 《剑雅 16-Test2》</h1><p>大家晚上好，昨天和今天是【Day5+Day6】。这两天大家独立完成了一整套题目：【剑雅 16-Test2】。感觉如何呢？<br>需要跟大家强调以下几点： </p>
<p>1）前面几套题，【最好不要限时】，而是去【充分感受做题方法、步骤】。比如，某个题型到底【应不应该预读？预读的话读哪里？读多少？】等等。因为题型众多，所以前期大家可能还无法全部记下来，这个时候【可以翻翻讲义】，加深一下印象。多练几套题，这个步骤也就记下来了。 </p>
<p>2）大家要逐步去感受【通过预读题目来预判出题位置】的能力，前期这个步骤可能会有点慢、比较花时间，但只要熟练掌握，这一项是可以帮助大家【节约很多时间】+【找准出题位置、提高正确率】的做法，所以大家自己在做题的时候，就一定要做这个步骤。然后之后在【精讲视频】里面比对【我的思路】，寻找差异，逐步缩小这个差异。 </p>
<p>3）每天的【单词背诵】一定要重视。因为每天的【精读视频】干货量已经很大（并且可能会给予大家充分的满足感），可能会让大家听完精读视频、做完笔记就完事了。但需要注意，可能对于很多同学来说，【精读视频】里讲到的单词对大家来说都是【新单词】，而新单词从第一次听到记忆比较深刻是需要至少【3~4 次重复的】。 </p>
<p>所以，建议大家每天听完精读视频视频后，再至少做两个步骤：【自己背诵单词】+【用亮亮给的词汇表格测试单词】。如果有可能，【第二天】和【第三天】也最好再复习一下。 </p>
<p>明后天是【Day7+Day8】，我们需要完成的是《剑雅 16-Test3》，大家加油！</p>
<h1 id="7-2022-x2F-11-x2F-26-27-《剑雅-16-Test3》"><a href="#7-2022-x2F-11-x2F-26-27-《剑雅-16-Test3》" class="headerlink" title="7 2022&#x2F;11&#x2F;26-27 《剑雅 16-Test3》"></a>7 2022&#x2F;11&#x2F;26-27 《剑雅 16-Test3》</h1><p>Group Notice<br>大家晚上好，昨天和今天是【Day7+Day8】。这两天大家又完成了一整套题目：【剑雅 16-Test3】。感觉如何呢？ </p>
<p>需要跟大家强调一下： </p>
<p>大家现在已经完成了 9 篇文章了，也积累了不少单词了，一方面需要不断复习。另一方面，也请大家不要焦躁，一般来说：【做题技巧】的熟练在【一本剑桥雅思】结束之后，大家会比较有感觉；但【精读对英语硬实力的提升】会更需要时间的积累，差不多在 20 篇文章之后，大家才能有一些体会（前提是这 20 篇的单词都积累得很踏实） </p>
<p>明后天是【Day9+Day10】，我们需要完成的是《剑雅 16-Test4》，大家加油！</p>
<h1 id="8-2022-x2F-11-x2F-28-29-《剑雅-16-Test4》"><a href="#8-2022-x2F-11-x2F-28-29-《剑雅-16-Test4》" class="headerlink" title="8 2022&#x2F;11&#x2F;28 -29 《剑雅 16-Test4》"></a>8 2022&#x2F;11&#x2F;28 -29 《剑雅 16-Test4》</h1><p>Group Notice</p>
<p>大家晚上好，昨天和今天是【Day9+Day10】。这两天大家又完成了一整套题目：【剑雅 16-Test4】。 </p>
<p>到此为止，阅读营已经过半，大家对【方法论+单词】消化得如何了呢？ </p>
<p>到目前为止，【每一种题型】我们几乎都做过 4 次了，这 4 次希望大家达到的基本目标是：准确记得每一种题型对应的【基础破题方法】，如：是否应该提前预读题目？是的话，应该预读多少？ </p>
<p>到目前为止，我们通过【精读】积累起来的【单词量】已经有【1006 个】了，大家的掌握程度如何呢？一般来讲，当大家积累的单词量超过【2000 个】，英语阅读就能够感受到【质的不同】了。目前我们已经走了一半，大家需要继续加油。 </p>
<p>从 Day2 到今天，大家每天的【做题+精读+背单词】的节奏其实是很密、工作量也是很大的，所以明天，也就是【Day11】，我们安排的是【阶段性复习】，也算是一个小休息。任务有 2： </p>
<p>1）消化过去的错题、进一步熟悉方法论； </p>
<p>2）复习单词（如果是坚持打卡的同学，【亮亮学长】已经把《阅读营 Day11 补充资料【剑雅 16 单词测试】》这个文件发给大家了，大家可以利用它进行测试） </p>
<p>大家加油！</p>
<h1 id="9-2022-x2F-11-x2F-30-《单词复习》"><a href="#9-2022-x2F-11-x2F-30-《单词复习》" class="headerlink" title="9 2022&#x2F;11&#x2F;30 《单词复习》"></a>9 2022&#x2F;11&#x2F;30 《单词复习》</h1><p>Group Notice<br>大家晚上好，今天是【Day11】，是大家的复习时间。 </p>
<p>明天和后天是【Day12+Day13】，我们将开始新一轮的刷题征程。明后天需要完成的是【剑雅 15-Test1】。 </p>
<p>需要注意，接下来的一本剑桥雅思，除了常规的【做题方法】+【精读、单词积累】外，我们再给大家提出一个额外要求： </p>
<p>就是需要<strong>在【阅读文章前】，利用【题型+题干关键词】对每道大题的【出题位置】进行预判，也就是：大概预判文章的哪些段落会考哪些题。</strong> </p>
<p>如果能成功预判，这一做法可以极大地帮助大家【节约找答案时间+提升正确率】。另外，就我的调研，市面上讲到这一做法的课程不多，所以大家一定要利用阅读营的机会，通过接下来的文章的练手机会，去尽量培养这种能力。 </p>
<p>前期可能会比较慢，并且大家自己预判也不一定准确，这个时候需要结合我的【精讲视频的对应内容】进行分析，逐步朝我的预判思路靠近。 </p>
<p>大家加油！</p>
<h1 id="10-2022-x2F-12-x2F-01-02-《剑雅-15-Test1》"><a href="#10-2022-x2F-12-x2F-01-02-《剑雅-15-Test1》" class="headerlink" title="10 2022&#x2F;12&#x2F;01 -02 《剑雅 15-Test1》"></a>10 2022&#x2F;12&#x2F;01 -02 《剑雅 15-Test1》</h1><p>Group Notice</p>
<p>大家晚上好，昨天和今天是【Day12+Day13】。我们开始了新一本《剑桥雅思》的练习，我们这两天做的是：【剑雅 15-Test1】。 </p>
<p>集中说一个不少同学都在问的问题：平时练习的时候，到底是要【保证把所有题目做完（正确率可能会被牺牲）】，还是要【保证正确率（但题目可能做不完）】？ </p>
<p>对于这个问题，分两种情况讨论： </p>
<p>【情况一：备考时间大于 20 天】 </p>
<p>需要【保证正确率】，即使题目可能做不完。这个时候甚至可以延长练习的时间，争取把正确率最大化。 </p>
<p>这么做的目的是：放慢脚步，才能充分去体会【做题步骤】和【方法论】，这从长期看来是有利于分数提升的。就像学广播体操一样，先开始都是慢慢学动作，把每一个动作做到位，这样后期速度快起来，动作也还是准确的。 </p>
<p>而每一次练习之后，大家需要尤其注重【精读】中单词的积累，这个是可以帮助大家提升英语硬实力的，这个实力提升了，后期做题也会自然快起来。 </p>
<p>【情况二：备考时间不足 10 天】 </p>
<p>这个备考时间，是很难从根本上提升英语实力的，所以需要有更应试的策略。 </p>
<p>这个时候需要大家自己测试一下【哪种方法会带来更高的正确率】，是【细致地做好每一道题（但有些题来不及做）】？还是【做完所有题】？ </p>
<p>两种方法都试试，测出来哪一种方法会带来更高的正确率，那么在接下来的时间、以及考试中，都坚持这一做法。毕竟，最终我们追求的不是【做完的题目数量】，而是【作对的题目数量】。 </p>
<p>明天和后天是【Day14+Day15】，大家可以考虑一下我说的问题。继续加油！</p>
<h1 id="11-2022-x2F-12-x2F-03-04-《剑雅-15-Test2》"><a href="#11-2022-x2F-12-x2F-03-04-《剑雅-15-Test2》" class="headerlink" title="11 2022&#x2F;12&#x2F;03 -04 《剑雅 15-Test2》"></a>11 2022&#x2F;12&#x2F;03 -04 《剑雅 15-Test2》</h1><p>Group Notice</p>
<p>大家晚上好，昨天和今天是【Day14+Day15】。我们完成了【剑雅 15-Test2】。 </p>
<p>阅读营的集中训练已经迎来了中后期，大家回顾一下我们的两个核心任务，看看自己有什么感受呢： </p>
<p>【核心任务一】：【各种题型的破题方法】+【借助题型和关键词来预判原文的出题位置】 </p>
<p>【核心任务二】：通过精读去积累【单词+语法】，提升【英语基础硬实力】 </p>
<p>其中的【任务一】，我认为大家是相对来讲进行得比较好的，即使没有主动地去进行，但通过每天的做题练习，也在被动地进行。 </p>
<p>但【任务二】的进展，这个可能大家会疏忽。**<font color="red">所以我需要再强调一下重要性。之前说过的【反复、多次地背诵单词】，大家一定要铭记于心+付诸实践。之前我们有【6.5→8 分】的同学，就是充分践行了这一点。大家也不要松懈！</font>** </p>
<p>明后天是【Day16+Day17】，我们练习的是【剑雅 15-Test3】，大家加油！</p>
]]></content>
      <categories>
        <category>英语</category>
      </categories>
      <tags>
        <tag>雅思</tag>
      </tags>
  </entry>
  <entry>
    <title>【夜读】读书、运动、早睡，是性价比最高的投资</title>
    <url>/2022/11/27/%E9%9A%8F%E7%AC%94%E4%B8%8E%E4%B8%AA%E4%BA%BA%E6%96%87%E9%9B%86/%E3%80%90%E5%A4%9C%E8%AF%BB%E3%80%91%E8%AF%BB%E4%B9%A6%E3%80%81%E8%BF%90%E5%8A%A8%E3%80%81%E6%97%A9%E7%9D%A1%EF%BC%8C%E6%98%AF%E6%80%A7%E4%BB%B7%E6%AF%94%E6%9C%80%E9%AB%98%E7%9A%84%E6%8A%95%E8%B5%84/</url>
    <content><![CDATA[<p>​</p>
<h1 id="读书">读书</h1>
<p>读书，决定人生的高度。</p>
<p>　　 在书中，你可以见识到不同的人，也可以看到不同的生活，还可以得到不同的生命感悟。这些会一点一滴地滋养你、改变你，让你找到前行的方向。</p>
<p>　　许多时候，我们以为那些看过的书都成了过眼云烟，不复记忆，其实他们是潜在的。在气质里，在谈吐上，在胸襟的无涯，当然也可能显露在生活和文字里。</p>
<p>　　<strong>鸟欲高飞先振翅，人求上进先读书。</strong>你翻过的每一页书，都在默默塑造一个更好的你。</p>
<h1 id="运动">运动</h1>
<p>　　运动，决定人生的质量。</p>
<p>　　一项研究显示，<strong>长期缺乏运动，会使身体器官机能下降，各类疾病的发生率也随之上升</strong>。动起来，不仅可以<strong>增强你的免疫力，也会让你的身体充满弹性和活力。</strong></p>
<p>　　同时，<strong>运动也是一种很好的解压方式，一场酣畅淋漓的汗水之后，那些困扰你的负面情绪往往也能随之消散。</strong></p>
<p>　　<strong><font color="red">规律的运动是对自己健康的投资，唯有坚持不懈怠、不偷懒、不放弃，才能感受到身体和心态的积极变化。</font></strong></p>
<h1 id="睡眠">睡眠</h1>
<p>　　睡眠，决定人生的状态。</p>
<p>　　白天我们在快节奏中奔波忙碌，到了晚上，很多人因为工作压力、感情不顺等原因而辗转难眠。但长此以往你会发现，熬夜不但解决不了任何问题，反而会使精神状态大打折扣。</p>
<p>　　<strong><font color="red">每天早点睡，给身体留一点富裕的时间，给生活留一份从容的姿态</font></strong> 。 <strong>照顾好自己，才能以饱满的热情，去实现自己的梦想。</strong></p>
<p>　　你在哪里付出，就会在哪里收获。 <strong><font color="red">每天读书、运动、早睡早起，坚持一段时间后你就会发现，你早已超越了原来的自己。</font></strong></p>
]]></content>
      <categories>
        <category>随笔与个人文集</category>
      </categories>
      <tags>
        <tag>夜读</tag>
      </tags>
  </entry>
  <entry>
    <title>精确休息法</title>
    <url>/2022/11/27/%E9%9A%8F%E7%AC%94%E4%B8%8E%E4%B8%AA%E4%BA%BA%E6%96%87%E9%9B%86/%E7%B2%BE%E7%A1%AE%E4%BC%91%E6%81%AF%E6%B3%95/</url>
    <content><![CDATA[<p>今天咱们继续说丹尼尔·平克的《见机》。上次我们说到<strong>一天中的不同时间应该做不同的事情</strong>，比如<strong>下午就不太适合做需要集中注意力的事情</strong>。<strong>那如果你必须要在下午参加重要会议或者数学考试，怎么办呢？你应该先休息。</strong></p>
<p>我们在第一季讲《巅峰表现》那本书的时候，提出一个概念叫<strong>“战略休息”</strong>。今天咱们把这个概念再进一步，叫“<strong>精确休息</strong>”。</p>
<p>我先举个例子。十多年以前就有专家呼吁要让员工在工作日的下午小睡一会儿，精力更充沛，提高工作效率。我听说有的公司真的就实行了小睡的制度，专门开辟一个睡觉的地方，员工可以半躺着，把头遮起来，在不受打扰的状态下小睡一会儿。</p>
<p>可是公司很快就发现这个效果并不好！很多员工一睡就是一两个小时，好不容易醒过来，一下午都昏昏沉沉，哪有什么工作效率。</p>
<p>这就是对休息的控制不够精确。那<strong>精确的小睡应该是怎么睡呢？</strong></p>
<ol type="1">
<li><p>先喝杯咖啡，其中咖啡因的含量应该是 200 毫克；</p></li>
<li><p>手机设置 25 分钟定时；</p></li>
<li><p>开始睡；</p></li>
<li><p>25 分钟一到马上起来。</p></li>
</ol>
<p>下面咱们就说说精确<strong>休息的原理</strong>。</p>
<h2 id="为什么不要在下午看病">1.为什么不要在下午看病</h2>
<p>我们专栏讲过，去医院看病是个危险的事儿，美国每年死于医疗事故的人比死于交通事故的人还多。不过医疗事故并不是均匀地分布在一天之中 —— 医生犯的大部分错误，是发生在下午。</p>
<p>平克列举了一系列的研究结果。杜克大学医学中心对 9 万台手术统计发现，如果是早上 9 点做手术，麻醉师犯错的可能性是 1%；而到下午 4 点的时候，犯错的可能性就上升到了 4.2% —— 这是四倍的差距！当然麻醉师犯错不等于病人一定会受到伤害，如果单纯统计因为麻醉师犯错对病人造成直接伤害的概率，早上 8 点的是 0.3%，下午 3 点就提高到了 1%，也是三四倍的差距。</p>
<p>所以你知道把麻醉安全度提高四倍的最简单方法是什么吗？选择早上做手术。</p>
<p>还有一个是公众不太了解，但在医学界是非常头疼的问题，就是医生不爱洗手。因为医生不爱洗手而导致患者感染的情况非常多，但是医生们真的很难做到在所有该洗手的时候都洗手。</p>
<p>2015 年，有人干脆做了个特别厉害的研究。找 4000 个医护人员 —— 其中 1/3 是医生，2/3 是护士 —— 全部佩戴 RFID（无线射频识别器），随时监测他们有没有洗手。统计结果是一段时间下来，总共 1400 万个该洗手的场合中，医护人员做到洗手了的不到 50%。特别是，下午洗手的次数又比上午少了 38%。</p>
<p><strong>医疗并不是一个特别讲究创造性的职业。它更强调的是严格操作，按照程序走，高度集中注意力，才能不犯错</strong>。可是医生也是人，他们不可能每时每刻都保持着万分小心，上一期说的情绪和精力变化曲线也适用于医生。医生们在上午已经尽力了，到下午也容易犯错。</p>
<p>而有些事儿在下午干是要致命的。英国交通部门的统计发现，一天 24 小时中，最容易因为犯困而导致交通事故的，一个是凌晨 2 点到早上 6 点之间 —— 这本来就是应该睡觉的时候 —— 另一个就是下午 2 点到下午 4 点。</p>
<p>英国人甚至还找到了事故高峰的精确时间点：<strong>下午 2 点 55 分。</strong></p>
<p><strong>这个点儿不是工作的点儿，应该用来休息。</strong></p>
<h2 id="休息的方法">2.休息的方法</h2>
<p>咱们经常读书的话，你会发现有些事情是一本书一个说法。比如说减肥和营养学，今天这个专家这么说，可能明年就有本新书全面推翻他的说法。可是关于“休息”，我们精英日课第一季和第二季提到过的所有说法，都是比较一致的 —— 可能科学家们已经找到了休息的“统一理论”。</p>
<p>那我们不妨以《见机》这本书的说法为主，再来归纳一下上班时间的休息方法。</p>
<p><strong><font color="red">第一，要有定时的短休息，也就是所谓“break”</font></strong>。有的研究说最佳间隔时间是每工作 52 分钟休息 17 分钟，也就是 52 + 17。《巅峰表现》那本书里还提到有的研究说是 50 + 7，51 + 9 等等，所以没有必要搞得精确到分钟 —— 大体来说，差不多是工作不到一小时，就休息十来分钟。</p>
<p><strong><font color="red">第二，休息这几分钟的时间就不要再想工作的事儿了</font></strong>。要离开工作去<strong>做一些不消耗认知力的事儿</strong>。我们第一季讲过一期叫《科学休息法》，其中最关键的研究结果就是<strong>凡是看电影、看书、玩手机这种消耗精力的活动都不叫休息，它们只会让你更累。</strong></p>
<p><strong><font color="red">第三，动起来比不动好。</font></strong>哪怕出去散步五分钟，都有很好的效果。</p>
<p><strong><font color="red">第四，可以把这个短休息用于社交。找人随便聊聊天比独自一个人休息的效果好。</font></strong></p>
<p><strong><font color="red">第五，户外比室内好</font></strong>。最好找个有树的地方接触大自然。如果是在室内休息，可以通过窗户眺望一下远方的景色 —— 要是窗外没什么景色，据说看看电脑屏幕上大自然的图片也有效果。</p>
<p><strong><font color="red">这种 break 应该在一天的工作之中随时进行。而到了下午，特别是 2 点 55 这个最困的时候，你也许就需要小睡一会儿了。</font></strong></p>
<p>小睡的关键是一定不能超过 25 分钟。我们讲《巅峰表现》的时候也说过，一般的睡眠是有惯性的，睡着了不愿意醒，整个昏昏沉沉的时间很长 —— 但是 20 分钟之内的小睡就没有惯性。这方面的研究结果可以用下面这张图表示 ——</p>
<figure>
<img src="https://piccdn3.umiwi.com/img/201801/29/201801291739468092493874.jpg" alt="img"><figcaption aria-hidden="true">img</figcaption>
</figure>
<p>横坐标是从睡醒开始的时间，纵坐标是认知能力相对于睡觉之前的变化。两条虚线分别代表 1 小时以内和超过一小时的睡眠，我们看到醒过来以后认知能力先是下降的，得等过一段时间，睡眠的好处才体现出来，这显然就太影响工作了。</p>
<p>而图中的实线代表 20 分钟的小睡 —— 小睡没有睡眠惯性，醒过来马上就特别精神。所以平克建议设定 25 分钟定时，你用 5 分钟睡着，然后正好睡 20 分钟起来。</p>
<p>很多人用咖啡提神 —— 如果配合小睡的话，你应该在睡<em>之前</em>喝咖啡！这是因为咖啡因进入你的血液循环正好需要 25 分钟。你喝完咖啡马上睡，25 分钟之后醒过来咖啡因也开始发挥作用，认知能力是双重的提升。</p>
<p>喝点咖啡是可以的。我们讲《端粒效应》的时候说过，现在研究认为咖啡对身体无害 —— 而且咱们上周说了，根据<em>英国科学家</em> 的研究，每天最好喝三到四杯咖啡。</p>
<p>把这些综合起来，我看最理想的工作环境应该像幼儿园一样：有上课铃、有下课铃、课间休息就都出去玩，下午还有午睡时间。</p>
<h2 id="成本收益分析">3.成本收益分析</h2>
<p>我们前面说了，提高医疗安全最简单方法，就是选择早上做手术。可是病人这么多不可能都安排在早上啊，那你知道提高医疗安全第二简单的方法是什么吗？就是做手术之前让医生休息一会儿。</p>
<p>平克这本书提到，有个大医院专门给医生做了休息训练，让医生养成在重大手术之前休息片刻的习惯 —— 结果在这个医院做手术的病人死亡率，下降了 18%。</p>
<p>这就等于原本你手里应该一年死五个人，现在只死了四个 —— 而让你做的仅仅是每次手术前休息 20 分钟。</p>
<p>还有，我们上次说了，让小学生下午参加数学考试，就相当于一个学期少上了两周的课，对吧？但是，如果在考试之前有 20 到 25 分钟的休息时间，让孩子们去操场上玩耍一会儿，考试成绩就不但不会下降，反而还能提高。一个 25 分钟的玩耍时间，相当于一学年多上了三个星期的课。</p>
<p>这就是量化研究的力量，你不但知道休息重要，还知道重要到了什么程度。我们看到小睡的具体量化研究结果，但是平克提到，小睡 20 分钟，大概能带来 3 个小时的清醒时间。</p>
<p>那如此说来，休息时间，大概是你最值得花的时间。</p>
<h2 id="由此得到">| 由此得到</h2>
<ol type="1">
<li><p><strong>对需要集中注意力的工作来说，下午的工作时间太容易犯错了。特别是下午 2:55。</strong></p></li>
<li><p><strong>休息可以大大提高你的工作效率 —— 而休息的关键，在于精确。</strong></p></li>
</ol>
<p>在忙碌的现代社会，<strong>休息几乎都成了一个反直觉的行为。明明手里还有很多工作，而你为了完成这些工作，反而应该先停下、不工作。</strong></p>
<p><strong><font color="red">高手应该时刻关注自己的状态，总是确保在关键工作中做到精力充沛。</font></strong>而如果你能精确休息，精力充沛根本不是问题。</p>
]]></content>
      <categories>
        <category>随笔与个人文集</category>
      </categories>
      <tags>
        <tag>生活</tag>
      </tags>
  </entry>
  <entry>
    <title>《毫无意义的工作》</title>
    <url>/2022/11/29/%E9%9A%8F%E7%AC%94%E4%B8%8E%E4%B8%AA%E4%BA%BA%E6%96%87%E9%9B%86/2-1%E3%80%8A%E6%AF%AB%E6%97%A0%E6%84%8F%E4%B9%89%E7%9A%84%E5%B7%A5%E4%BD%9C%E3%80%8B/</url>
    <content><![CDATA[<p>凯恩斯曾在 20 世纪 30 年代预言：到 20 世纪末，科技水平将足够进步，人们每周的工作时长会缩短至 15 小时。但如今，人们在工作上花费了更多时间。</p>
<p>你的工作对世界做出贡献了吗？2013 年，大卫·格雷伯在《谈谈“狗屁工作”现象》一文中提出了这个尖锐的问题，在几周内收获了超过百万次的阅读点击，并被翻译成十几种语言。直到现在，它仍然是人们深切关注的议题。</p>
<p>是谁在创造这些毫无意义的工作？它是如何降低效率，阻碍个人价值的实现，加剧不公平的？在这本书中，作者以犀利的笔触，将自己的观察、研究与反思悉数呈现，剖析了困扰世人的当代社会病灶。</p>
<p>梁永安、严飞作序，陈嘉映、项飙、刘擎、罗家德、冯仑联袂推荐。 <img src="https://ts1.cn.mm.bing.net/th/id/R-C.8e671a43fe9d3873aa86a1f9077bf297?rik=Oi8jIMDxzCtQqQ&amp;riu=http%3a%2f%2fwenhui.whb.cn%2fu%2fcms%2fwww%2f202207%2f17095641bgpx.jpg&amp;ehk=gpYks9kS6RFkOhgqVrx3w39mczTY6pqtu41MsclMDrE%3d&amp;risl=&amp;pid=ImgRaw&amp;r=0" alt="毫无意义的工作"></p>
]]></content>
      <categories>
        <category>随笔与个人文集</category>
      </categories>
      <tags>
        <tag>读书</tag>
      </tags>
  </entry>
  <entry>
    <title>《完美主义扼杀效率》</title>
    <url>/2022/11/27/%E9%9A%8F%E7%AC%94%E4%B8%8E%E4%B8%AA%E4%BA%BA%E6%96%87%E9%9B%86/2-2%E3%80%8A%E5%AE%8C%E7%BE%8E%E4%B8%BB%E4%B9%89%E6%89%BC%E6%9D%80%E6%95%88%E7%8E%87%E3%80%8B/</url>
    <content><![CDATA[<p>◆ 完美主义扼杀效率！工作的目标是成果，而不是完美！</p>
<p>◆ 33个完美主义思维误区！</p>
<p>◆ 完美根本不存在！做出成果只需抓住20%核心工作</p>
<p>◆ 日本上班族人手一本！</p>
<p>◆ 完美主义：以追求完美为借口，不断拖延、犹豫、推迟。</p>
<p>◆ 时效主义：快速响应，开始行动，在有限条件下追求成果。</p>
<p>◆ 插图活泼生动，含完美主义诊断测试，蓝黑双色印刷！</p>
<p>总以追求完美为借口，无论大事小事，一切工作都崇尚极致严谨，不允许出现任何失误，想靠自己的力量去完成所有工作，结果总在拖延、犹豫、推迟……不仅工作还毫无成果，还把自己折腾得疲惫不堪。要知道，工作的目标是成果，而不是完美。实际上，完美根本不存在。</p>
<p>日本习惯专家古川武士根据多年来从事企业经营、商务人士咨询顾问的经验，对比了33个完美主义者和时效主义者的思维习惯，彻底讲透了职场人如何在有限时间、精力的条件下追求最优解。一旦你掌握了时效主义工作方式，就能在职场上如鱼得水，付出最少的精力，收获最大的成果！</p>
<p>翻开本书，在有限时间内收获最大化成果<br><img src="https://cdn.staticaly.com/gh/peirsist/blog_img@master/s34153013.2vg7xqdasou0.jpg" alt="s34153013"></p>
]]></content>
      <categories>
        <category>随笔与个人文集</category>
      </categories>
      <tags>
        <tag>读书</tag>
      </tags>
  </entry>
  <entry>
    <title>【夜读】2022年的最后一个月，坚持做这4件事</title>
    <url>/2022/12/04/%E9%9A%8F%E7%AC%94%E4%B8%8E%E4%B8%AA%E4%BA%BA%E6%96%87%E9%9B%86/%E3%80%90%E5%A4%9C%E8%AF%BB%E3%80%912022%E5%B9%B4%E7%9A%84%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E6%9C%88%EF%BC%8C%E5%9D%9A%E6%8C%81%E5%81%9A%E8%BF%994%E4%BB%B6%E4%BA%8B/</url>
    <content><![CDATA[<p>今天过后，2022 年只剩最后一个月。年初许下的愿望都实现了吗？十二月，加倍珍惜，加倍努力，向着未来继续出发。</p>
<ol type="1">
<li><strong>不遗余力地提升自己</strong>　</li>
</ol>
<p>生活的转机，其实就藏在你每一个想要变更好的念头里。</p>
<p>即便2022年只剩下一个月，也不要着急、不要焦虑，要利用最后的一个月，提升自己，跟时间赛跑。</p>
<p>放下你的迷茫，放下你的懒惰，放下你的三分钟热情，静下心来好好去做你想做的事情。</p>
<p>请相信，努力从来不会白费，今日撒下的种子，正在你看不见、想不到的某处，悄悄地生根发芽。</p>
<ol start="2" type="1">
<li><strong>发自内心地爱惜身体</strong></li>
</ol>
<p>请记住，身体健康永远是第一位的。没有健康，一切都会大打折扣。</p>
<p>2022年的最后一个月里，少熬夜，规律作息，累了就休息一下，没事就早点睡，别让健康透支。</p>
<p>认真对待每天的一粥一菜，早起感受清晨温暖的阳光，给身体一些放松的时间。</p>
<p>好好照顾自己，就是对生活最好的珍惜，也是给家人最大的安心。</p>
<ol start="3" type="1">
<li><strong>全力以赴地珍惜当下</strong></li>
</ol>
<p>我们身边有太多的人，总是觉得来日方长，今天完不成的事情拖到明天再做。</p>
<p>珍惜时间最好的方式，是用时间成就更好的自己。</p>
<p>2022年已经过去11个月，在这最后的一个月里，与其蹉跎岁月，不如好好把握住当下的分分秒秒，让自己不断成长进步。</p>
<p>不浪费时间，不挥霍光阴，多做让自己变好的事，时间会给我们答案。</p>
<ol start="4" type="1">
<li><strong>留一些时间总结复盘</strong></li>
</ol>
<p>真正厉害的人都善于总结复盘。从得失中分析原因，总结自己的不足并及时修正，才能避免更多的错误，做出更加正确的选择。</p>
<p>2022年的最后一个月，给自己留出一些总结复盘的时间。</p>
<p>可以回望自己年初定下的目标，看看实现了多少。也可以梳理自己这一年的经历，看哪些地方可以改进。</p>
<p>复盘总结，调整步调，让前路走得更顺，也让自己变得更好。</p>
]]></content>
      <categories>
        <category>随笔与个人文集</category>
      </categories>
      <tags>
        <tag>夜读</tag>
      </tags>
  </entry>
</search>
